diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..2d79d9c
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,12 @@
+init:
+	pip install -r requirements.txt
+
+build: 
+	python setup.py build
+
+
+install: 
+	python setup.py install
+
+test:
+	nosetests tests
diff --git a/README.md b/README.md
index d872f58..0c02157 100755
--- a/README.md
+++ b/README.md
@@ -12,7 +12,7 @@ The tool when used for importing partitions or creating partition from template,
 How to Use the Tool:
 
 => Git clone the code from the repository to your local system "git clone https://github.com/preethipy/Partition_Export_Import_TemplateEngine.git"
-=> The main script that has be run is src/Console.py. The tool is quite interactive and hence very easy to use. 
+=> The main script that has be run is export_import_template_engine/Console.py. The tool is quite interactive and hence very easy to use. 
 
 Prerequisites:
 => The tool should can be run from any system which has access to HMC webservices API
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/Console.py b/build/lib.linux-x86_64-2.7/partitionengine/Console.py
new file mode 100644
index 0000000..912aeca
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/Console.py
@@ -0,0 +1,322 @@
+from getpass import *
+
+#from babel.messages.catalog import Catalog
+
+from CreateTemplate import *
+from CreateTemplatePartition import *
+from utils.wsautils import *
+import ConfigParser
+
+
+session = None
+
+
+CONFIG_FILE=".saved-settings"
+config = ConfigParser.RawConfigParser()
+
+
+def print_helper(print_string=None, operationFailed=False, exception=None):
+    string_out = ''
+    if (operationFailed):
+        string_out += ("\n" + "*"*100)
+        string_out += ("\n**********************************Operation Failed**************************************************")
+        
+    else:
+        string_out += ("\n" + "*"*100)
+    string_out += ("\n" + print_string)
+    string_out += ("\n" + "*"*100)
+    print string_out
+    logging.debug(string_out)
+    if not (exception == None):
+        logging.debug("Failure Reason:")
+        logging.debug(exception)
+        exc_type, exc_value, exc_traceback = sys.exc_info()
+        traceback_details = {
+                         'filename': exc_traceback.tb_frame.f_code.co_filename,
+                         'lineno'  : exc_traceback.tb_lineno,
+                         'name'    : exc_traceback.tb_frame.f_code.co_name,
+                         'type'    : exc_type.__name__,
+                         'message' : exc_value.message, # or see traceback._some_str()
+                        }
+        del(exc_type, exc_value, exc_traceback)
+        logging.debug(traceback.format_exc())
+        
+    return
+        
+
+
+
+
+
+finalSelectedOption = 0
+def option_choser(queryString='Choose from Index',option_title='', indexLength=0,chosenOption = 0):
+    logging.info('option_choser method invoked') 
+    if chosenOption < 1 or chosenOption > indexLength:
+        try:
+            chosenOption = int(user_input('\n'+queryString, 'OPTIONS', option_title))#raw_input('\n' + queryString.ljust(30) + ':'))         
+        except:
+            print("Invalid Value!!! ")
+        option_choser(queryString,option_title,indexLength,chosenOption)
+    else:
+        global finalSelectedOption
+        finalSelectedOption = chosenOption   
+    logging.debug("chosen option: " + str(chosenOption))
+    return finalSelectedOption
+
+def createPartitionIteratively(temp_name='', no_of_partitions=0, cpc_uri=''):
+    logging.info('-> createPartitionIteratively for the templatename ' + temp_name + " number of Partitions: " + str(no_of_partitions) + " CPC URI: " + cpc_uri)
+    partionList=dict();
+    for num in range(0, no_of_partitions):
+        print_helper("Creating Partition " + str(num+1), False)
+        try:
+            partition_unique_name,part_uri=createTemplatePartition(temp_name, session, cpc_uri, ''.join(random.choice(string.ascii_uppercase + string.digits) for num in range(4)))
+        except Exception as ex:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(ex))
+        except:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(sys.exc_info()[:2]))
+        #partionList[partition_unique_name] = part_uri
+    logging.info('<- createPartitionIteratively')
+    return partionList
+
+def createPartitionFromTemplate(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromTemplate')
+    partitionStatus=''
+    try:
+        template_dir_name = os.path.join(os.path.dirname(os.path.abspath(__file__)) , 'templates/cpc_' + cpc_name);
+        logging.debug(template_dir_name)
+        if not(os.path.isdir(template_dir_name)):
+            print_helper("No Template File exists")
+            return
+        template_files = os.listdir(template_dir_name)
+        logging.debug('template_files ' + str(template_files))
+        
+        print("\nChoose one of the below Templates:\n")
+        
+        for index in range(0, len(template_files)):
+            print index + 1, '. '.ljust(10), os.path.splitext(template_files[index])[0]
+        selected_template = option_choser("Select a template available to create partition:","TEMPLATE" ,len(template_files))
+        
+        temp_name = template_files[selected_template - 1]
+        logging.debug("Selected Template..." + temp_name)
+        
+        no_of_partitions = option_choser('Enter the number of partitions to be created ',"PARTITIONCOUNT", 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/cpc_' + cpc_name, temp_name)
+        logging.debug('template_name ' + template_name)
+        
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        partitionList=createPartitionIteratively(template_name, no_of_partitions, cpc_uri)
+        partitionStatus = 'Partition Created Successfully from template\n'
+        for part in partitionList.keys():
+        
+            partitionStatus+= 'Partition Name: '+part+'\n'
+            partitionStatus+= 'Partition URI: ' +partitionList[part]+'\n'
+    except:
+        print_helper('Partition Creation failed to create from given Template', True, str(sys.exc_info()[:2]))
+    logging.info('<-createPartitionFromTemplate')    
+    
+    print_helper(partitionStatus, False)
+    
+    print_helper("Process Completed", False)    
+    return
+
+def createPartitionFromPartition(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        for  index in range(0, len(partitions)):
+            print index + 1, '  ', partitions[index]['name']
+        partition_option = option_choser('Select partition by index','PARTITION_INDEX', len(partitions))
+        
+        partition_name = partitions[partition_option - 1]['name']
+        no_of_partitions = option_choser('Enter the number of partitions to be created ','NUMPARTS', 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        
+        
+        
+        temp_name = createTemplate(session,[partitions[partition_option - 1]], cpc_name, partition_name)
+        logging.debug('template_name '+ temp_name)
+        
+        time.sleep(1)
+        p.stop()      
+        
+        time.sleep(2)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("File not found: " + temp_name)
+        
+        createPartitionIteratively(temp_name, no_of_partitions, cpc_uri)
+    except:
+        print_helper('Partition Creation failed to create from chosen partition ' + partition_name, True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-createPartitionFromPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def exportPartition(cpc_name="",cpc_uri=""):
+    logging.info('->exportPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        temp_name = createTemplate(session,partitions, cpc_name)
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        time.sleep(1)
+        p.stop()
+        time.sleep(2)   
+        logging.debug('template_name '+ temp_name)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("Partition Inventory is not exported to the file " + temp_name)
+    except:
+        print_helper('Partition Export failed', True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-exportPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def importPartition(cpc_name='', cpc_uri=''):
+    logging.info('->importPartition')
+    try:
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/base_' + cpc_name, 'base_template.json')
+        logging.debug('template_name '+ template_name)
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        createTemplatePartition(template_name, session, cpc_uri)
+    except:
+        print_helper("Sorry! There is no backup inventory for the CPC selected", True, str(sys.exc_info()[:2]))
+    logging.info('<-importPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def readConfig():
+    config.read('savedsettings.cfg')
+    return config
+
+def updateConfig(params=None):
+    with open('savedsettings.cfg', 'wb') as configfile:
+        config.write(configfile)
+    return
+
+def user_input(inputStr='',section='',parameter='', password=False):
+    config = readConfig()
+    
+    userinput=''
+    
+    try: 
+        value=config.get(section, parameter)
+    except ConfigParser.NoSectionError:
+        if not section == '':
+            config.add_section(section)
+        value = ''
+    except:
+        value = ''    
+    if password:
+        userinput=getpass(inputStr.ljust(15) + ':')        
+    else:
+        userinput=raw_input(inputStr +' ['+ value + ']'.ljust(15) + ':')
+        
+    if not userinput == '':
+        value = userinput
+       
+    if not parameter=='':
+        config.set(section,parameter,value)
+    updateConfig()
+    return value 
+
+
+
+def main():
+    initializeLogging()
+    logging.info('Starting the PartitionManagementTemplating Tool')
+    print "*"*100
+    print "Capture and replay partition creation".center(100)
+    print "*"*100   
+    
+            
+    hmc_ip = user_input('Enter HMC IP', 'BASE_PARAMS', 'HMC_IP')#raw_input('Enter HMC IP ['+ config.get('BASE_PARAMS', 'HMC_IP') + ']'.ljust(30) + ':')
+    hmc_user = user_input('Enter Username', 'BASE_PARAMS', 'HMC_USER')#raw_input('Enter Username ['+ config.get('BASE_PARAMS', 'HMC_USER') + ']'.ljust(30) + ':')
+    hmc_password = user_input('Enter Password','','',True)#('Enter Password'.ljust(30) + ':')
+    
+    #hmc_ip = '9.152.151.49'
+    #hmc_user = 'pedebug'
+    #hmc_password = 'password'
+    # print hmc_password
+    logging.debug('hmc_ip: '+hmc_ip+' hmc_user '+hmc_user+' hmc_password '+hmc_password)
+    cpcs = []
+    global session
+    try:
+        
+        p = progress_bar_loading()
+        p.configure("Establishing session")
+        p.start()     
+        session = session_startup(host=hmc_ip, user=hmc_user, pwd=hmc_password)
+        logging.debug("Printing the session details... /n"+ str(session))
+        time.sleep(2)
+        p.stop()
+        
+        p = progress_bar_loading()
+        p.configure("Fetching CPC List")
+        p.start()
+        cpcs = list_cpcs(session)
+        p.stop()        
+        time.sleep(2)
+        
+        logging.debug("Printing the cpcs... /n"+ str(cpcs))
+    except ApiFatalException as ex:
+        print_helper("Sorry! Session could not be established. Please verify the IP, HMC Username/Password", True)
+        time.sleep(1)
+        p.stop() 
+        return
+    
+    print "****************************************************************************************************"
+    if len(cpcs) > 0:        
+        print "List of CPCs available"
+    else:
+        print_helper("No CPCs managed by the HMC!!!")
+        return
+    
+    
+    for  index in range(0, len(cpcs)):
+        print index + 1, '  ', cpcs[index]['name']
+    
+    try:
+        cpc_option = option_choser("Select cpc by index from the given list",'CPCSEL', len(cpcs))
+    
+        cpc_uri = cpcs[cpc_option - 1]['object-uri']
+        cpc_name = cpcs[cpc_option - 1]['name']
+        print_helper('CPC ' + cpc_name + ' is selected')
+        print("Choose one of the below options:")
+        options = '\n1.  create n partitions from existing templates?\n2.  create a partition based on another partition?\n3.  Export Partition Inventory?\n4.  Import Partition Inventory? '
+        print options
+        selected_option = option_choser('Select an option by index','FLAVOR', 4)
+    
+    
+        if selected_option == 1:
+            createPartitionFromTemplate(cpc_name, cpc_uri)
+            
+        elif selected_option == 2:
+            createPartitionFromPartition(cpc_name, cpc_uri)
+            
+        elif selected_option == 3:
+            exportPartition(cpc_name, cpc_uri)
+            
+        if selected_option == 4:
+            importPartition(cpc_name, cpc_uri)
+    except:
+        print_helper('Process Failed ', True, str(sys.exc_info()[:2]))
+   
+main()
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplate.py b/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplate.py
new file mode 100644
index 0000000..cd9c35e
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplate.py
@@ -0,0 +1,152 @@
+
+import ast
+import json
+import os
+from utils.wsautils import *
+
+
+roce_nic_writable_properties = ['description','device-number','name','network-adapter-port-uri']
+vfn_writable_properties = ['description','device-number','name','adapter-uri']
+vs_nic_writable_properties = ['description','device-number','name','virtual-switch-uri']
+writable_properties = [u'ifl-processing-weight-capped', u'minimum-cp-processing-weight',  u'maximum-ifl-processing-weight', u'access-problem-state-counter-set', u'ifl-processors',  u'cp-absolute-processor-capping-value',  u'reserve-resources', u'maximum-memory', u'boot-timeout', u'boot-os-specific-parameters',  u'processor-management-enabled', u'boot-device', u'access-basic-sampling', u'cp-absolute-processor-capping',  u'boot-record-lba', u'permit-cross-partition-commands', u'acceptable-status', u'maximum-cp-processing-weight', u'minimum-ifl-processing-weight',   u'access-global-performance-data', u'cp-processing-weight-capped', u'permit-aes-key-import-functions',  u'ifl-absolute-processor-capping-value', u'initial-ifl-processing-weight', u'access-extended-counter-set',  u'initial-cp-processing-weight', u'access-crypto-activity-counter-set', u'initial-memory', u'access-basic-counter-set', u'name', u'boot-configuration-selector', u'description', u'cp-processors',  u'access-diagnostic-sampling',u'permit-des-key-import-functions', u'processor-mode',u'ifl-absolute-processor-capping', u'access-coprocessor-group-set']
+hba_writable_properties = ['description','device-number','name','adapter-port-uri']
+boot_device = {'storage-adapter':['boot-logical-unit-number','boot-world-wide-port-name','boot-storage-device'],'network-adapter':['boot-network-device'],'ftp':['boot-ftp-host','boot-ftp-insfile','boot-ftp-password','boot-ftp-username'],'iso-image':['boot-iso-image-name','boot-iso-ins-file'],'removable-media':['boot-removable-media', 'boot-removable-media-type']}
+global nic_device_uri
+global hba_device_uri
+    
+class Object:
+    def to_JSON(self):
+        return json.dumps(self, default=lambda o: o.__dict__, 
+            sort_keys=True, indent=4)
+class Payload(object):
+    def __init__(self, j):
+        self.__dict__ = json.loads(j)
+        
+        
+def getNicList(session,ob,ob1):
+    logging.info('->getNicList')
+    nic_list = []
+    global nic_device_uri
+    for nic in getattr(ob,'nic-uris'):
+        logging.debug(str(nic))
+        response = session.get(nic)
+        
+        logging.debug(str(response.body))
+        nic_ob1= Payload(json.dumps(response.body))
+        nic_ob = Object()
+        for key in nic_ob1.__dict__.keys():
+            if response.body['type'] == 'roce':
+                if key in roce_nic_writable_properties:
+                    logging.debug(str(getattr(nic_ob1,key)))
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            else:
+                #print key
+                if key in vs_nic_writable_properties:
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'network-adapter' and getattr(nic_ob1, key) == nic_device_uri:
+                    setattr(ob1, 'nic-boot-device-number', getattr(nic_ob1, 'device-number')) 
+        nic_list.append(nic_ob)
+        
+        logging.debug(str(nic_list));
+        logging.info('<-getNicList')
+    return nic_list 
+
+def getHbaList(session,ob,ob1):
+    logging.info('->getHbaList')
+    hba_list = []
+    global hba_device_uri
+    for hba in getattr(ob,'hba-uris'):
+        response = session.get(hba)
+        hba_ob = Object()
+        hba_ob1= Payload(json.dumps(response.body))
+        for key in hba_ob1.__dict__.keys():
+            if key in hba_writable_properties:
+                setattr(hba_ob,key,getattr(hba_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'storage-adapter' and getattr(hba_ob1, key) == hba_device_uri:
+                    setattr(ob1, 'hba-boot-device-number', getattr(hba_ob1, 'device-number')) 
+        hba_list.append(hba_ob)
+    logging.info('<-getHbaList')
+    return hba_list 
+
+def getVfnList(session,ob):
+    logging.info('->getVfnList')
+    vfn_list = []
+    for vfn in getattr(ob,'virtual-function-uris'):
+        response = session.get(vfn)
+        vfn_ob = Object()
+        vfn_ob1= Payload(json.dumps(response.body))
+        for key in vfn_ob1.__dict__.keys():
+            if key in vfn_writable_properties:
+                setattr(vfn_ob,key,getattr(vfn_ob1,key))
+    
+        vfn_list.append(vfn_ob)
+    logging.info('<-getVfnList')
+    return vfn_list 
+
+def setBootDevice(ob,ob1):
+    logging.info('->setBootDevice')
+    global hba_device_uri
+    global nic_device_uri
+    if getattr(ob, 'boot-device') == 'storage-adapter':
+        hba_device_uri = getattr(ob, 'boot-storage-device')
+            
+    if getattr(ob, 'boot-device') == 'network-adapter':
+        nic_device_uri = getattr(ob, 'boot-network-device')
+           
+    if getattr(ob, 'boot-device') in boot_device.keys():
+        for boot_property in boot_device[getattr(ob, 'boot-device')]:
+            setattr(ob1,boot_property,getattr(ob, boot_property))
+    logging.info('<-setBootDevice')
+    return
+                
+def getPartitionTemplate(session,inv_response,partition_list):
+    logging.info('Retriving the partition info and loading into template....')
+    logging.info('->getPartitionTemplate')
+    ob1 = Object()
+    ob = Payload(json.dumps(inv_response))
+    for key in ob.__dict__.keys():
+        if key in writable_properties:
+            setattr(ob1,key,getattr(ob,key))
+        if key == 'crypto-configuration':
+            setattr(ob1,'cryptos',getattr(ob,key))
+    setBootDevice(ob, ob1)
+    nic_list = getNicList(session,ob,ob1)
+    hba_list = getHbaList(session, ob,ob1)
+    vfn_list = getVfnList(session, ob)
+    setattr(ob1,'nics',nic_list)
+    setattr(ob1,'virtual-functions',vfn_list)
+    setattr(ob1,'hbas',hba_list)
+    partition_list.append(ob1)
+    logging.info('<-getPartitionTemplate')
+    return partition_list
+        
+def createTemplate(session,inv_response,cpc_name,partition_name = None):
+    logging.info('->createTemplate')
+    logging.debug(str(inv_response))
+    partition_list = []
+    complete = Object()
+    for partition in inv_response:
+            response = session.get(partition['object-uri'])
+            complete = Object()
+            partition_list = getPartitionTemplate(session, response.body, partition_list) 
+            
+    setattr(complete,'partition',partition_list)  
+    if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates'):
+        os.mkdir(os.path.dirname(os.path.abspath(__file__))+'/templates')
+    if partition_name == None:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/base_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name,'base_template.json')
+    else:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/cpc_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name,partition_name+'_template.json')
+    file = open(file_name,'w+')        
+    file.write(complete.to_JSON())
+    file.close()
+    logging.info('template created successfully...')
+    logging.info('<-createTemplate')
+    
+    return file_name
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplatePartition.py b/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplatePartition.py
new file mode 100644
index 0000000..5e06d02
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/CreateTemplatePartition.py
@@ -0,0 +1,147 @@
+
+import ast
+import json
+import random
+
+from utils.wsautils import *
+
+import sys
+import time
+import threading
+
+
+
+
+
+def remove(body,keys_list):
+    for key in keys_list:
+        if key in body.keys():
+            del body[key]
+
+def createTemplatePartition(temp_filename,session,cpc,partition_unique_name=None):
+    logging.info('==>>################# createTemplatePartition invoked#################')
+    logging.debug('Template file name: '+ temp_filename)
+    logging.debug('cpc uri: '+ cpc)
+    logging.debug('Partition unique name: '+ str(partition_unique_name))
+    temp_file = open(temp_filename,'r')
+    json_text = temp_file.read()
+    ip = json.loads((json_text))
+    ip_body = ip['partition']
+    p = progress_bar_loading()
+    try:
+        for partition in ip_body:
+            body = {'processor-mode':partition['processor-mode'], 'initial-memory':partition['initial-memory'],'maximum-memory':partition['maximum-memory']}
+            if partition_unique_name != None:
+                body.update({'name':partition['name']+'_'+str(partition_unique_name)})
+            else:
+                body.update({'name':partition['name']})
+            if partition['cp-processors'] != 0:
+                body.update({'cp-processors':partition['cp-processors']})
+            else:
+                body.update({'ifl-processors':partition['ifl-processors']})
+                
+            p = progress_bar_loading()
+            p.configure("Creating Partition")
+            p.start()
+            response = session.post(cpc+'/partitions',json.dumps(body))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Respose from partitions Post request" + str(response)) 
+            
+            
+            part_uri = response.body['object-uri']
+            logging.debug("Partition URI from newly created partition" + part_uri)
+            
+            
+            p = progress_bar_loading()
+            p.configure("Creating VNics")
+            p.start()   
+            for nic in partition['nics']:
+                logging.info("Iterating through nic URIS")            
+                response = session.post(part_uri+'/nics',json.dumps(nic))            
+                logging.debug("Respose from nics Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'network-adapter') and (nic['device-number'] == partition['nic-boot-device-number']) :            
+                    nicRes = response.body['element-uri']
+                    partition['boot-network-device'] = nicRes
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+             
+             
+            p = progress_bar_loading()
+            p.configure("Creating HBAs")
+            p.start()       
+            for hba in partition['hbas']:
+                logging.info("Iterating through hba URIS")
+                
+                response = session.post(part_uri+'/hbas',json.dumps(hba))
+                
+                logging.debug("Respose from hbas Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'storage-adapter') and (hba['device-number'] == partition['hba-boot-device-number']) :            
+                    hbaRes = response.body['element-uri']
+                    partition['boot-storage-device'] = hbaRes
+                 
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            
+            p = progress_bar_loading()
+            p.configure("Creating VirtualFunctions")
+            p.start()       
+            for vfn in partition['virtual-functions']:
+                logging.info("Iterating through virtual-functions URIS")
+                
+                response = session.post(part_uri+'/virtual-functions',json.dumps(vfn))
+                
+                
+                logging.debug("Respose from virtual-functions Post request" + str(response))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            p = progress_bar_loading()
+            p.configure("Configuring Cryptos")
+            p.start()
+            if partition['cryptos'] != None:
+                logging.info("Adding crypto configurations")
+                
+                response = session.post(part_uri+'/operations/increase-crypto-configuration',json.dumps(partition['cryptos']))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            remove(partition,['nics','hbas','virtual-functions','name','hba-boot-device-number','nic-boot-device-number','cryptos'])
+            logging.debug("Removed unwanted attributes")
+            
+            p = progress_bar_loading()
+            p.configure("\nUpdating Partition Properties")        
+            p.start()
+            response = session.post(part_uri,json.dumps(partition))        
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Response from Update Partition request"+ str(response))
+            
+            
+            p = progress_bar_loading()
+            p.configure("Retrieve and Verify Partition Properties")        
+            p.start()
+            response = session.get(part_uri)            
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            if(response.status == 200):
+                sys.stdout.write("Partition: " + response.body['name']+" Created Successfully" )
+            logging.debug("Partition Properties"+ str(response))
+    except:
+        time.sleep(1)
+        p.stop()
+        raise
+        
+    logging.info('<<=########## createTemplatePartition invoked#########')
+    return partition_unique_name,part_uri
\ No newline at end of file
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/__init__.py b/build/lib.linux-x86_64-2.7/partitionengine/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/delete_all.py b/build/lib.linux-x86_64-2.7/partitionengine/delete_all.py
new file mode 100644
index 0000000..74fda68
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/delete_all.py
@@ -0,0 +1,14 @@
+'''
+Created on Apr 13, 2016
+
+@author: sowmya
+'''
+from utils.wsautils import *
+
+session= session_startup(host='9.12.38.77')
+cpc_uri = list_cpcs(session)[0]['object-uri']
+part = session.get(cpc_uri+'/partitions')
+print part
+
+for partition in part.body['partitions']:
+    print session.delete(partition['object-uri'])
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/utils/__init__.py b/build/lib.linux-x86_64-2.7/partitionengine/utils/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaconst.py b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaconst.py
new file mode 100644
index 0000000..b16f4d9
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaconst.py
@@ -0,0 +1,685 @@
+
+WSA_CONST_VERSION = "1.1"  # Current version of the API constants
+
+# Make a copy of the input array.  This copy contains lowercase versions of each
+# array element that is not already lowercase.
+def make_lowercase_copy(tokens):
+    lower_tokens = []
+    for token in tokens:
+        lower_token = token.lower()
+        #print "token: %s (%s)" % (token, lower_token)
+        if lower_token not in tokens:
+            lower_tokens.append(lower_token)
+        #print "lower_tokens(%s): %s" % (len(lower_tokens), lower_tokens)
+    return lower_tokens
+
+# ??? FVT regression test framework to-do's
+# - Need to add testcase_properties definition to all existing testcases.  Use this template
+#   and replace the items in angle brackets with the appropriate strings:
+#
+#      testcase_properties = {TC_FULL_NAME : get_testcase_full_filename(),
+#                             TC_COMPONENT : TC_COMPONENT_<component>,
+#                             TC_ID : get_testcase_id(),
+#                             TC_TITLE : '<title>',
+#                             TC_URI : '<uri>',
+#                             TC_MINIMUM_API_VERSION : TC_API_VERSION_<minimum_version>,
+#                             TC_SCENARIO_TYPE : TC_SCENARIO_TYPE_<scenario_type>,
+#                             TC_EXECUTION_TYPE : TC_EXECUTION_TYPE_<execution_type>,
+#                             TC_CAPABILITIES : [<appropriate TC_CAPABILITY_<capability> values, OR empty array>]}
+#
+# x Consider reworking skeleton.py to follow the above model, so that future automated updates are easier,
+#   and as many as possible of these properties can come from the FVT Lotus Notes database. [done]
+#   x Consider adding code to the skeleton to fetch the minimum version out of testcase_properties for
+#     use in a testcase environment check. [done]
+#   x Need to fetch the component, id and title from testcase_properties as well, because they are used
+#     in some print statements at the beginning of the testcase execution. [done]
+# x Need a proper implementation of is_api_version_at_least(). [done]
+# - Should probably add an is_api_version_at_most() method for potential use in the future.
+# - Add a check for required testcase properties???  When?  --get-properties?  --check-properties?
+#   - The list of required properties would be defined in a constant in wsaconst.py
+# x Add support for creating a CSV file of testcases that meet specified criteria? ["done".  Not CSV though.  See runregress.py]
+#   - Add --csv-file option to specify the output CSV filename
+#   - If testcase meets requirements, *append* a line to the CSV file
+#     - If file doesn't exist, create it by writing a header line that defines the columns
+#       - column names and order would be defined in a constant in wsaconst.py
+#   - Requires caller to erase any leftover CSV file before beginning this run
+# x Add an option to runregress.py to specify a top directory to search for testcases to run 
+#     and run all it finds that meet the requirements. [done]
+#   x The requirements can be specified as a single complex string option which is passed
+#     as a bunch of arguments to the testcase.  Maybe something like this:
+#        runregress.py --top-dir <dir> --requirements "--component SVM --component VSM --scenario success --execution-type self-checking" [done]
+
+
+# The name of the variable that defines a testcase's properties.  
+# Each testcase must define this variable appropriately.
+TESTCASE_PROPERTIES_VARIABLE_NAME = 'testcase_properties'
+
+#############################################################################
+# These constants define property names and values that are used to describe
+# testcases.  They are intended for use in the definition of the 
+# TESTCASE_PROPERTIES_VARIABLE_NAME dictionary in each testcase's source code.
+# Some of them can be specified on the command line as testcase requirements.
+#############################################################################
+# Testcase filename, with full path information
+TC_FULL_NAME = 'full_name'
+
+# Testcase ID.  The numeric ID, typically found in the testcase filename, which is of the form:
+# comp_id.py, where comp is the component and id is the testcase ID.
+TC_ID = 'id'
+
+# Testcase title
+TC_TITLE = 'title'
+
+# Primary URI being tested by this testcase
+TC_URI = 'uri'
+
+# API versions.  They must be defined in such a way that they can be meaningfully supported by the is_api_version_*() methods.
+# Be sure to add any new ones to TC_API_VERSION_LIST.
+TC_MINIMUM_API_VERSION = 'min_api_version'
+TC_MAXIMUM_API_VERSION = 'max_api_version'
+TC_API_VERSION_ZGRYPHON_GA2  = '1.1'
+TC_API_VERSION_ZGRYPHON_GA2A = '1.2'
+TC_API_VERSION_ZHELIX_GA1    = '1.3'
+TC_API_VERSION_ZHELIX_GA2    = '1.4'
+TC_API_VERSION_ZHELIX_GA2A   = '1.5'    # LI 1065 - Support for Shutdown and Power-off Tasks
+TC_API_VERSION_ZSPHINX_GA1   = '1.6'
+TC_API_VERSION_ZSPHINX_GA2   = '1.7'
+TC_API_VERSION_ZMIDAS_GA1    = '1.8'
+# List of all valid API versions, used for command line validation
+TC_API_VERSION_LIST = [TC_API_VERSION_ZGRYPHON_GA2, TC_API_VERSION_ZGRYPHON_GA2A, TC_API_VERSION_ZHELIX_GA1, TC_API_VERSION_ZHELIX_GA2,
+                       TC_API_VERSION_ZHELIX_GA2A, TC_API_VERSION_ZSPHINX_GA1, TC_API_VERSION_ZSPHINX_GA2,TC_API_VERSION_ZMIDAS_GA1]
+
+# Testcase capabilities.  These define API/HMC/SE "capabilities" that are tested by certain testcases.
+# They can be, for example, MCF bundles, line items, parts of line items, ODTs, MCFs, MCLs, optional facilities, etc...
+# Be sure to add any new ones to TC_CAPABILITY_LIST.
+TC_CAPABILITIES = 'capabilities'
+TESTCASE_CAPABILITIES = TC_CAPABILITIES  # ??? Temp duplicate of TC_CAPABILITIES until FVT API database is updated to use TC_CAPABILITIES
+TC_CAPABILITY_ZVM           = 'ZVM'  # This testcase requires a z/VM system
+TC_CAPABILITY_IEDN          = 'IEDN'
+TC_CAPABILITY_QDIO          = 'QDIO'
+TC_CAPABILITY_VSWITCH       = 'VIRTUAL SWITCH'
+TC_CAPABILITY_PRSM          = 'PRSM'
+TC_CAPABILITY_XHYP          = 'X86'
+TC_CAPABILITY_POWERVM       = 'POWER-VM'
+#TC_CAPABILITY_BLADEXHYP     = 'X86-BLADE'
+#TC_CAPABILITY_BLADEPOWER    = 'POWER-BLADE'
+TC_CAPABILITY_BLADEISAOPT   = 'ISAOPT-BLADE'
+TC_CAPABILITY_BLADEDPXI50Z  = 'DPXI50Z-BLADE'
+TC_CAPABILITY_ZAWARE  = 'ZAWARE'
+TC_CAPABILITY_ZBX  = 'ZBX'
+TC_CAPABILITY_ZFX  = 'ZFX'
+TC_CAPABILITY_ZHYP  = 'ZHYP'
+TC_CAPABILITY_ZXN  = 'ZXN' # For zExtension nodes - zFX Mod 001 & zBX Mod 004 nodes
+TC_CAPABILITY_ZBXMOD004 = 'ZBXMOD004'
+# List of all valid capabilities, used for command line validation
+TC_CAPABILITY_LIST = [TC_CAPABILITY_ZVM, TC_CAPABILITY_IEDN, TC_CAPABILITY_QDIO, TC_CAPABILITY_VSWITCH, TC_CAPABILITY_PRSM, TC_CAPABILITY_XHYP, 
+                      TC_CAPABILITY_POWERVM, TC_CAPABILITY_BLADEISAOPT, TC_CAPABILITY_BLADEDPXI50Z, TC_CAPABILITY_ZAWARE]
+TC_CAPABILITY_LIST.extend(make_lowercase_copy(TC_CAPABILITY_LIST))  # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase components
+# Be sure to add any new ones to TC_COMPONENT_LIST.
+TC_COMPONENT = 'component'
+TC_COMPONENT_CONS = 'CONS'  #CreateTemplate
+TC_COMPONENT_CPC  = 'CPC'   #Central Processor Complex
+TC_COMPONENT_CREC = 'CREC'  #Capacity Records
+TC_COMPONENT_EAM  = 'EAM'   #Enterprise Availability Management
+TC_COMPONENT_EM   = 'EM'    #Energy Management
+TC_COMPONENT_EMM  = 'EMM'   #Ensemble Membership Management
+TC_COMPONENT_EMF  = 'EMF'   #Ensemble Measurement Facility
+TC_COMPONENT_GPRO = 'GPRO'  #Group Profiles
+TC_COMPONENT_GRP  = 'GRP'   #Groups
+TC_COMPONENT_GS   = 'GS'    #General Services
+TC_COMPONENT_HVM  = 'HVM'   #Hypervisor Virtualization Management
+TC_COMPONENT_IOM  = 'IOM'   #I/O Configuration Management
+TC_COMPONENT_IPRO = 'IPRO'  #Image Activation Profiles
+TC_COMPONENT_IS   = 'IS'    #Inventory Service
+TC_COMPONENT_LGR  = 'LGR'   #Live Guest Relocation
+TC_COMPONENT_LPAR = 'LPAR'  #Logical Partition
+TC_COMPONENT_LPRO = 'LPRO'  #Load Activation Profile
+TC_COMPONENT_MDM  = 'MDM'   #Monitors Dashboard Metric Groups
+TC_COMPONENT_MS   = 'MS'    #Metrics Service
+TC_COMPONENT_NVM  = 'NVM'   #Network Virtualization Management
+TC_COMPONENT_PPM  = 'PPM'   #Workloads and Performance Management
+TC_COMPONENT_RPRO = 'RPRO'  #Reset Activation Profiles
+TC_COMPONENT_SEC  = 'SEC'   #Security and User Management
+TC_COMPONENT_SVM  = 'SVM'   #Storage Virtualization Management
+TC_COMPONENT_VSM  = 'VSM'   #Virtual Server Management
+TC_COMPONENT_zBX  = 'zBX'   #zEnterprise Blade Extension
+TC_COMPONENT_ZFX  = 'ZFX'   #zEnterprise Flex System
+TC_COMPONENT_ZXN  = 'ZXN'   #zNode for both zFX and zBX nodes
+TC_COMPONENT_HVM_2 = 'HVM_2'#hvm for prsm2
+TC_COMPONENT_SVM_2 = 'SVM_2'#svm for prsm2
+TC_COMPONENT_VSM_2 = 'VSM_2'#vsm for prsm2
+TC_COMPONENT_CPC_2 = 'CPC_2'#cpc for prsm2
+TC_COMPONENT_NVM_2 = 'NVM_2'#nvm for prsm2
+
+# List of all valid components, used for command line validation
+TC_COMPONENT_LIST = [TC_COMPONENT_CONS, TC_COMPONENT_CPC, TC_COMPONENT_CREC, TC_COMPONENT_EAM, TC_COMPONENT_EM, TC_COMPONENT_EMM,
+                     TC_COMPONENT_GPRO, TC_COMPONENT_GRP, TC_COMPONENT_GS, TC_COMPONENT_HVM, TC_COMPONENT_IPRO, TC_COMPONENT_IS,
+                     TC_COMPONENT_LPAR, TC_COMPONENT_LPRO, TC_COMPONENT_MDM, TC_COMPONENT_MS, TC_COMPONENT_NVM, TC_COMPONENT_PPM,
+                     TC_COMPONENT_RPRO, TC_COMPONENT_SVM, TC_COMPONENT_VSM, TC_COMPONENT_SEC,TC_COMPONENT_zBX, 
+                     TC_COMPONENT_HVM_2, TC_COMPONENT_SVM_2,TC_COMPONENT_NVM_2,TC_COMPONENT_VSM_2,TC_COMPONENT_CPC_2]
+TC_COMPONENT_LIST.extend(make_lowercase_copy(TC_COMPONENT_LIST))    # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase scenario type
+# Be sure to add any new ones to TC_SCENARIO_TYPE_LIST.
+TC_SCENARIO_TYPE = 'scenario_type'
+TC_SCENARIO_TYPE_AUTHORIZATION = 'authorization'
+TC_SCENARIO_TYPE_FAILURE       = 'failure'
+TC_SCENARIO_TYPE_NOTIFICATION  = 'notification'
+TC_SCENARIO_TYPE_SUCCESS       = 'success'
+# List of all valid scenario types, used for command line validation
+TC_SCENARIO_TYPE_LIST = [TC_SCENARIO_TYPE_AUTHORIZATION, TC_SCENARIO_TYPE_FAILURE, TC_SCENARIO_TYPE_NOTIFICATION, TC_SCENARIO_TYPE_SUCCESS]
+TC_SCENARIO_TYPE_LIST.extend(make_lowercase_copy(TC_SCENARIO_TYPE_LIST))    # Add lowercase versions as needed, for command line convenience
+
+# Testcase execution type
+# Be sure to add any new ones to TC_EXECUTION_TYPE_LIST.
+TC_EXECUTION_TYPE = 'execution_type'
+TC_EXECUTION_TYPE_DISRUPTIVE               = 'disruptive'
+TC_EXECUTION_TYPE_MANUAL                   = 'manual'
+TC_EXECUTION_TYPE_SELF_CHECKING            = 'self-checking'
+TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE  = 'self-checking-exclusive'
+TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP = 'self-checking-with-setup'
+TC_EXECUTION_TYPE_SUBTEST                  = 'subtest'
+# List of all valid execution types, used for command line validation
+TC_EXECUTION_TYPE_LIST = [TC_EXECUTION_TYPE_DISRUPTIVE, TC_EXECUTION_TYPE_MANUAL, TC_EXECUTION_TYPE_SELF_CHECKING,
+                          TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE, TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP, TC_EXECUTION_TYPE_SUBTEST]
+TC_EXECUTION_TYPE_LIST.extend(make_lowercase_copy(TC_EXECUTION_TYPE_LIST))  # Add lowercase versions as needed, for command line convenience
+
+# Marker lines for output of --get-properties requests
+GET_PROPERTIES_BEGIN_MARKER = "***%s begin***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+GET_PROPERTIES_END_MARKER = "***%s end***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+
+
+#############################################################################
+# Miscellaneous constants
+#############################################################################
+
+# Flag to indicate whether ODT Z9474 is applied to the target system.  It changes some
+# characteristics of notification messages.  This flag allows the message validation
+# code to react accordingly.
+Z9474_applied = True
+
+
+#############################################################################
+# "Temporary object" support.  These are constants that support the creation
+# (via the various object-specific "create_temporary_<object-type>()" methods)
+# and deletion of "temporary" objects.
+#############################################################################
+
+# System-defined users, used for admin-type operations during testcase scenario setup
+# and cleanup.  These constants are intended for use as values for the KEY_ADMIN_USERID 
+# property in the temporary_object_types_info collection and on calls to get_admin_session(userid).
+ACCESS_ADMINISTRATOR =      'ACSADMIN'
+ADVANCED_OPERATOR =         'ADVANCED'
+ENSEMBLE_ADMINISTRATOR =    'ENSADMIN'
+ENSEMBLE_OPERATOR =         'ENSOPERATOR'
+SYSTEM_OPERATOR =           'OPERATOR'
+SERVICE_REPRESENTATIVE =    'SERVICE'
+SYSTEM_PROGRAMMER =         'SYSPROG'
+PEDEBUG =                   'PEDEBUG'
+
+# These constants identify the kinds of objects that are supported by the
+# "temporary object" support in wsautils.  Each type must be added to the
+# temporary_object_types_deletion_order list in the appropriate position,
+# and it must also be added to the temporary_object_types_info collection
+# so it can be identified and handled properly.
+TEMP_OBJ_TYPE_USER =                'user'
+TEMP_OBJ_TYPE_USER_ROLE =           'role'
+TEMP_OBJ_TYPE_USERID_PATTERN =      'userid-pattern'
+TEMP_OBJ_TYPE_PASSWORD_RULE =       'password-rule'
+TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG =  'ldap'
+TEMP_OBJ_TYPE_CUSTOM_GROUP =        'group'
+TEMP_OBJ_TYPE_VIRTUAL_SERVER =      'virtual-server'
+TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP = 'workload-resource_group'
+TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP = 'workload-element_group'
+
+# An ordered list of object types supported as "temporary objects".  This list defines
+# the order in which the temporary objects are deleted at the end of testcase execution.
+temporary_object_types_deletion_order = [TEMP_OBJ_TYPE_USERID_PATTERN,  # must be before User (specifically, before type=template Users are deleted)
+                                         TEMP_OBJ_TYPE_USER,
+                                         TEMP_OBJ_TYPE_USER_ROLE,       # must be after User
+                                         TEMP_OBJ_TYPE_CUSTOM_GROUP,    # must be after User Role and User
+                                         TEMP_OBJ_TYPE_PASSWORD_RULE,   # must be after User
+                                         TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG,  # must be after patterns
+                                         TEMP_OBJ_TYPE_VIRTUAL_SERVER,
+                                         TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP,
+                                         TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP, # must be after Workload Element Groups
+                                        ]
+
+# Keys for info in the temporary_object_types_info map
+KEY_ADMIN_USERID = 'admin_userid'   # Key for the name of the system-defined user that has administration privileges for this type of object
+KEY_URI_PREFIX =   'uri_prefix'     # Key for the initial constant part of the URI that identifies an object this type
+
+# Map of information about the object types that are supported as "temporary objects"
+temporary_object_types_info = dict({TEMP_OBJ_TYPE_USER :                {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/users/'}, 
+                                    TEMP_OBJ_TYPE_USER_ROLE :           {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/user-roles/'},
+                                    TEMP_OBJ_TYPE_USERID_PATTERN :      {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/user-patterns/'},
+                                    TEMP_OBJ_TYPE_PASSWORD_RULE :       {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/password-rules/'},
+                                    TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG :  {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/ldap-server-definitions/'},
+                                    TEMP_OBJ_TYPE_CUSTOM_GROUP :        {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/groups/'},
+                                    TEMP_OBJ_TYPE_VIRTUAL_SERVER :      {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/virtual-servers/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP   : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-resource-groups/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP    : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-element-groups/'},
+                                  })
+
+
+# Map of URI prefixes to the name of the system-defined user that has administrator permissions for objects with that URI prefix.
+# This map is used to locate/create an API session with administrator permissions for the URI prefix.
+# Note that these prefixes must be listed from most-specific to least-specific, since they are searched in order.
+# It is recommended to include a trailing slash only on URI prefixes that require it in order for it to be a valid URI.
+# (Some URI prefixes can be used in their entirety on List operations, and thus should not include a trailing slash;
+# if needed, two entries can be included: one with a trailing slash and one without).
+# TODO: add support for expressions or wildcards for objects that contain multiple IDs (e.g., element objects often have multiple IDs)
+uri_admin_info = dict({'/api/ensembles' : ENSEMBLE_ADMINISTRATOR,
+                       '/api/console/hardware-messages' : SYSTEM_PROGRAMMER,
+                       '/api/console/users' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-roles' : ACCESS_ADMINISTRATOR,
+                       '/api/console/tasks' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-patterns' : ACCESS_ADMINISTRATOR,
+                       '/api/console/password-rules' : ACCESS_ADMINISTRATOR,
+                       '/api/console/ldap-server-definitions' : ACCESS_ADMINISTRATOR,
+                       '/api/users/' : ACCESS_ADMINISTRATOR,
+                       '/api/user-roles/' : ACCESS_ADMINISTRATOR,
+                     })
+#############################################################################
+# ActiveMQ
+# Note that the HMC must be configured to explicitly use the non-SSL ports.
+#############################################################################
+
+# PyActiveMQ ports
+WSA_ACTIVEMQ_PORT_NON_SSL = 61616
+WSA_ACTIVEMQ_PORT_SSL     = 61617
+
+# STOMP ports
+WSA_STOMP_PORT_NON_SSL = 61613
+WSA_STOMP_PORT_SSL = 61612
+
+# Supported ActiveMQ clients
+# These constants are used as command line option values.
+AMQ_CLIENT_PYACTIVEMQ = 'pyactivemq'
+AMQ_CLIENT_STOMP = 'stomp'
+WSA_DEFAULT_AMQ_CLIENT = AMQ_CLIENT_STOMP
+
+# ActiveMQ socket types.
+# These constants are used as command line option values.
+SOCKET_TYPE_SSL = 'ssl'
+SOCKET_TYPE_NON_SSL = 'non-ssl'
+
+#############################################################################
+# Test systems information
+#############################################################################
+### R32 ensemble
+# The name of the ensemble on the primary FVT test system.  This can be used
+# in testcases with certain prerequisites/restrictions that are known to
+# exist on R32.
+ENSEMBLE_NAME_R32 = 'R32Ensemble'
+DEFAULT_ENSEMBLE_NAME = 'ZBX51'
+DEFAULT_CPC_NAME = 'S32'
+DEFAULT_VIRTUALIZATION_HOST_NAME = 'B.1.12'
+DEFAULT_VIRTUAL_SERVER_NAME = 'APIVM1'
+DEFAULT_LPAR_NAME = 'APIVM1'
+PREFERRED_ZVM_VIRTUALIZATION_HOST_R32 = 'APIVM1'
+IP_ADDRESS_R32_HMC = 'Y.Y.Y.Y'         # (R32 is no longer available for API testing)
+IP_ADDRESS_R32_ALT_HMC = '9.60.14.45'     # (R32 is no longer available for API testing)
+FAMILIAR_NAME_R32_HMC = 'S32'          # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+# Ichabod ensemble
+IP_ADDRESS_ICHABOD_HMC = '9.60.14.63'
+FAMILIAR_NAME_ICHABOD_HMC = 'ICHABOD'  # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+#===============================================================================
+# Constant file to run the Testcase : lpar_5433
+# 
+LPAR_CPC_NAME = 'APIVM1'
+LPAR_NAME     = 'VMALT' # remove the postfix '1' from the lpar name.
+LPAR_NAME_ONE = 'VMALT1'
+LPAR_NAME_TWO = 'VMALT2'
+LPAR_NAME_THREE = 'VMALT3'
+#===============================================================================
+
+#############################################################################
+# API URIs
+#############################################################################
+
+# Log onto an HMC
+WSA_URI_LOGON   = '/api/session'
+
+# Log off of an HMC
+WSA_URI_LOGOFF  = '/api/session/this-session'
+
+# Retrieve the API version
+WSA_URI_VERSION = '/api/version'
+
+# List all ensembles
+WSA_URI_ENSEMBLES      = '/api/ensembles'
+
+# Retrieve properties of a specific ensemble
+WSA_URI_ENSEMBLE       = '/api/ensembles/{0}'
+
+# Retrieve all CPCs
+WSA_URI_CPCS           = '/api/cpcs'
+
+# Retrieve all virtualization hosts of a specific ensemble
+WSA_URI_VIRT_HOSTS_ENS = '/api/ensembles/{0}/virtualization-hosts'
+
+# Retrieve all virtualization hosts of a specific cpc
+WSA_URI_VIRT_HOSTS_CPC = '/api/cpcs/{0}/virtualization-hosts'
+
+# Retrieve all properties of a specific virtualization host
+WSA_URI_VIRT_HOST      = '/api/virtualization-hosts/{0}'
+
+
+#############################################################################
+# Testcase exit return codes
+#############################################################################
+
+# Exit return code for successful testcase execution
+WSA_EXIT_SUCCESS = 0
+
+# Exit return code for an API error
+WSA_EXIT_ERROR_API = 1
+
+# Exit return code for an unexpected error such as a communication failure
+WSA_EXIT_ERROR_UNCAUGHT = 2
+
+# Exit return code for successful --get-properties request
+WSA_EXIT_GET_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for successful --check-properties request
+WSA_EXIT_CHECK_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for an invalid command line (e.g., an invalid combination of options)
+WSA_EXIT_INVALID_COMMAND_LINE = 5
+
+# Exit return code for an error due to missing testcase properties
+WSA_EXIT_MISSING_TESTCASE_PROPERTIES = 6
+
+# Exit return code indicating that a specific testcase property is not defined
+WSA_EXIT_PROPERTY_NOT_DEFINED = 7
+
+# Exit return code indicating that a testcase requirement was not met
+WSA_EXIT_REQUIREMENT_NOT_MET = 8
+
+
+WSA_EXIT_ERROR_CLEANUP = 9
+#############################################################################
+# HTTP Request and Response
+# Note that the HMC must be configured to explicitly use the non-SSL port.
+#############################################################################
+
+# Non-SSL HTTP Port ... need HTTPConnection ...
+WSA_PORT_NON_SSL = 6167
+
+# SSL HTTP Port ... needs HTTPSConnection ...
+WSA_PORT_SSL     = 6794
+
+# HTTP GET command
+WSA_COMMAND_GET    = 'GET'
+
+# HTTP DELETE command
+WSA_COMMAND_DELETE = 'DELETE'
+
+# HTTP POST command
+WSA_COMMAND_POST   = 'POST'
+
+# HTTP PUT command
+WSA_COMMAND_PUT    = 'PUT'
+
+# Header for content type ... both request and response
+WSA_HEADER_CONTENT    = 'content-type'
+WSA_HEADER_CONTENT_TYPE   = WSA_HEADER_CONTENT  # Synonym with better name
+WSA_HEADER_CONTENT_LENGTH = 'content-length'
+
+# Header for API session ... request header only
+WSA_HEADER_RQ_SESSION = 'x-api-session'
+
+# Header for API session ... response header only
+WSA_HEADER_RS_SESSION = 'api-session'
+
+# Response headers (these are published in the examples in the WS API customer book)
+WSA_HEADER_RESP_SERVER = 'server'
+WSA_HEADER_RESP_CACHE_CONTROL = 'cache-control'
+WSA_HEADER_RESP_DATE = 'date'
+WSA_HEADER_RESP_LOCATION = 'location'
+WSA_HEADER_RESP_TRANSFER_ENCODING = 'transfer-encoding'
+
+WSA_CONTENT_JSON = 'application/json'
+WSA_CONTENT_XML  = 'application/xml'
+WSA_CONTENT_ZIP  = 'application/zip'
+
+# Currently supported content types
+WSA_SUPPORTED_CONTENT = [ WSA_CONTENT_JSON, WSA_CONTENT_XML, WSA_CONTENT_ZIP ]
+
+#############################################################################
+# Common property names
+#############################################################################
+PROPERTY_OBJECT_URI   = 'object-uri'
+PROPERTY_NAME         = 'name'
+PROPERTY_DESCRIPTION  = 'description'
+PROPERTY_LPAR_NAME    = 'lpar-name'
+PROPERTY_ID           = 'partition-id'
+PROPERTY_TYPE         = 'type'
+PROPERTY_ADAPTER_ID   = 'adapter-id'
+PROPERTY_ADAPTER_PORT = 'adapter-port'
+PROPERTY_PORT_INDEX   = 'port-index'
+
+
+
+#############################################################################
+# Command line option names
+#############################################################################
+OPTION_ADDR = '--addr'
+OPTION_PORT = '--port'
+OPTION_USER = '--user'
+OPTION_PASS = '--pass'
+OPTION_GET_PROPERTIES = '--get-properties'
+OPTION_CHECK_PROPERTIES = '--check-properties'
+OPTION_RUN_IF_APPLICABLE = '--run-if-applicable'
+OPTION_CAPABILITY = '--capability'
+OPTION_COMPONENT = '--component'
+OPTION_SCENARIO = '--scenario'
+OPTION_EXECUTION_TYPE = '--execution-type'
+#OPTION_MIN_VERSION = '--min-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+#OPTION_MAX_VERSION = '--max-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+OPTION_REQUIRED_VERSION = '--required-version'
+OPTION_API_VERSION = '--api-version'
+
+
+# Command line destination variable names
+OPTION_ADDR_DEST = 'host'
+OPTION_PORT_DEST = 'port'
+OPTION_USER_DEST = 'user'
+OPTION_PASS_DEST = 'pwd'
+
+#############################################################################
+# Command line default values
+#############################################################################
+DEFAULT_ADDR = '9.56.198.64'#'9.152.151.49'# '9.12.38.189' #'9.56.192.214' # '9.60.15.124'# ''9.56.192.214' #  '9.60.31.100'#'9.152.151.49' #'9.56.192.214' #'9.152.151.49' #'9.60.31.168'#'9.60.31.170'#'9.12.38.183'    # A dummy default, to force the user to specify --addr.  (R32 is no longer available)
+#DEFAULT_ADDR = '9.60.15.62'  #p15
+#DEFAULT_ADDR = '9.60.14.63'   #Ichabod
+#DEFAULT_ADDR = '9.56.196.93'
+DEFAULT_PORT = WSA_PORT_SSL
+WSA_DEFAULT_USERID   = 'ensadmin'
+WSA_DEFAULT_PASSWORD = 'password'
+
+#############################################################################
+# API feature strings.  These identify optional WS API features that may be
+# available on the HMC.  A list of available features is included in the 
+# response to the API Version and Logon requests.  The available features
+# are specified in files in the /console/data/webapi/features/ directory on
+# the HMC.
+#############################################################################
+FEATURE_GET_FILES_FROM_SE = 'internal-get-files-from-se' # Internal-use only API to fetch a specified file(s) from an SE
+
+#############################################################################
+# Response Validation
+#############################################################################
+
+STATUS       = 'status'
+CONTENT_TYPE = 'content-type'
+REQUIRED     = 'required'
+OPTIONAL     = 'optional'
+
+
+STATUS_200     = ( STATUS, 200 )
+STATUS_201     = ( STATUS, 201 )
+STATUS_202     = ( STATUS, 202 )
+STATUS_204     = ( STATUS, 204 )
+CONTENT_JSON   = ( CONTENT_TYPE, WSA_CONTENT_JSON )
+REQUIRED_EMPTY = ( REQUIRED, [] )
+OPTIONAL_EMPTY = ( OPTIONAL, [] )
+OPTIONAL_API1DOT4 = ( OPTIONAL, ['acceptable-avail-status','avail-policies','avail-status','element-groups','perf-policies','absolute-ziip-capping','workload-element-groups','shutdown-timeout', 'shutdown-timeout-source','gpmp-network-adapter'] )
+OPTIONAL_PASSWORD_EXPIRES = (OPTIONAL, ['password-expires'])
+
+
+# Logon and Version #########################################################
+
+__ver_required       = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'hmc-name', 'hmc-version' ] )
+__ver_optional       = ( OPTIONAL, [ 'api-features' ] )
+__logon_required     = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic' ] )
+__logon_required_job = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic','job-notification-topic' ] )
+__logon_optional     = ( OPTIONAL, [ 'password-expires', 'api-features' ] )
+
+# Validate response from 'Get Version' operation
+WSA_VERSION_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __ver_required, __ver_optional ] )
+
+# Validate response from 'Logon' operation
+WSA_LOGON_VALIDATE     = dict( [ STATUS_200, CONTENT_JSON, __logon_required, __logon_optional ] )
+WSA_LOGON_VALIDATE_JOB     = dict( [ STATUS_200, CONTENT_JSON, __logon_required_job, __logon_optional ] )
+
+# Ensembles #################################################################
+
+__list_ensembles_required = ( REQUIRED, [ 'ensembles' ] )
+
+__get_ensemble_required   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix' ] )
+
+__get_ensemble_optional   = ( OPTIONAL, [ 'alt-hmc-name',
+                                            'alt-hmc-ipv4-address',
+                                            'alt-hmc-ipv6-address',
+                                          'cpu-perf-mgmt-enabled-x-hyp',
+                                            'cpu-perf-mgmt-enabled-x-hyp',  #temporarily resumed by lv, for zHelixGA2 testing, but notice it is not running on lower version
+
+                                            'load-balancing-enabled',
+                                            'load-balancing-ip-addresses',
+                                            'load-balancing-port',
+                                            'max-nodes',
+                                            'max-cpc-nodes',
+                                            'max-zbx-nodes' ] )
+
+# Validate response from 'List Ensembles' operation
+WSA_LIST_ENSEMBLES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_ensembles_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each ensemble returned by 'List Ensembles' operation
+WSA_LIST_ENSEMBLE_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Validate response from 'Get Ensemble Properties' operation
+WSA_GET_ENSEMBLE_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required,   __get_ensemble_optional ] )
+
+
+# CPCs ######################################################################
+
+__list_cpcs_required = ( REQUIRED, [ 'cpcs' ] )
+
+# Validate response from 'List CPCs' operation
+WSA_LIST_CPCS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_cpcs_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each cpc returned by 'List CPCs' operation
+WSA_LIST_CPC_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Required keys for 'Get CPC Properties' operation
+__get_cpc_properties_required  = ( REQUIRED, [ 'name',
+                                               'object-uri',
+                                               'type',
+                                               'status' ] )
+
+# Validate response from 'Get CPC Properties' operation
+WSA_GET_CPC_PROPERTIES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __get_cpc_properties_required, OPTIONAL_EMPTY ] )
+
+
+# Virtualization Hosts ######################################################
+
+__list_virt_hosts_required = ( REQUIRED, [ 'virtualization-hosts' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOSTS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_hosts_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each virtualization host returned by 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOST_REQUIRED  = [ 'name', 'object-uri', 'status', 'type' ]
+
+# Wait period for all zvm tests
+WAIT_PERIOD_FOR_ZVM_TEST = 30 
+
+# These are the properties of a notification message that are not of type string.
+# When an incoming message is received, it is used to populate a dictionary of
+# key-value pairs.  Most of the properties are strings, but some are not and require
+# special handling.  Identify them here along with their datatype.  The addition of
+# a new type here will require corresponding changes where this list is processed.
+if Z9474_applied:
+    nonstring_message_properties = [
+                                    ('global-sequence-nr', 'long'), 
+                                    ('session-sequence-nr', 'long'),
+                                   ]
+else:
+    nonstring_message_properties = [
+                                   ]
+
+
+#added by lv start
+APA_TESTENV_CPC_UNDER_TEST = 'BLUECORE'
+
+__list_virt_servers_required = ( REQUIRED, [ 'virtual-servers' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_SERVERS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_servers_required, OPTIONAL_EMPTY ] )
+
+__list_virt_server_groups_required = ( REQUIRED, [ 'virtual-server-groups' ] )
+
+WSA_LIST_VIRT_SERVER_GROUPS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_server_groups_required, OPTIONAL_EMPTY ] )
+#added by lv end
+
+#adding the constants need for Ensemble properties for node properties
+__get_ensemble_required_nodes   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix',
+                                            'max-cpc-nodes',
+                                            'max-nodes',
+                                            'max-zbx-nodes' ] )
+
+
+WSA_GET_ENSEMBLE_VALIDATE_NODES   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required_nodes,   __get_ensemble_optional ] )
+WSA_DEFAULT_ZBX_NAME = 'ZBX2'
\ No newline at end of file
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaglobals.py b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaglobals.py
new file mode 100644
index 0000000..65e6f61
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsaglobals.py
@@ -0,0 +1,33 @@
+# Global variables for use by wsaconst and friends
+# 
+# Change history:
+# - 2014/07/17 L. Brocious      Initial version.  Added for "temporary object" support.
+# - 2015/02/16 L. Brocious      Add "temporary session" support.
+
+# This is the list of additional command line options (those defined in addition
+# to the "standard" options) defined for the current testcase execution.  This is
+# saved when the Session is created and is used only to allow successful re-parsing
+# of the command line when additional sessions are created during testcase execution
+# (typically during scenario setup and cleanup).
+global global_saved_additional_options
+global_saved_additional_options = None
+
+# The list of all registerd "temporary objects".  This list is managed by the 
+# register_temporary_object() and deregister_temporary_object() methods.  All
+# objects in this list are deleted by default during session shutdown.
+global global_temporary_objects_list
+global_temporary_objects_list = []
+
+# The list of all known "admin" sessions.  Such privileged sessions are typically needed
+# during scenario setup and cleanup.  For performance reasons, they are cached here and
+# reused if needed.  This list is managed by get_admin_session() and delete_all_admin_sessions().
+global global_admin_sessions
+global_admin_sessions = dict()
+
+
+# The list of all registerd "temporary sessions".  A temporary session is associated
+# with a temporary user and is intended for testcase scripts that perform authorization
+# testing.  All sessions in this list are deleted by default during shutdown of the
+# testcase's main session (via the standard session_shutdown(session) call before exit).
+global global_temporary_sessions
+global_temporary_sessions = []
diff --git a/build/lib.linux-x86_64-2.7/partitionengine/utils/wsautils.py b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsautils.py
new file mode 100644
index 0000000..5a578dc
--- /dev/null
+++ b/build/lib.linux-x86_64-2.7/partitionengine/utils/wsautils.py
@@ -0,0 +1,2902 @@
+#############################################################################
+#
+# Some utility classes and functions that may be useful for API Testing
+#
+# In order to import this module for use in testcases, set the PYTHONPATH
+# environment variable to point to the directory where the modules are
+# located.
+#
+# from wsaconst import *
+# from wsautils import *
+#
+# The call to os.getenv can be used to retrieve any environment variable, so
+# defining a variable that points to the Python common utilities directory
+# could be established in a test environment startup script, then referenced
+# above in the sys.path.append method call ...
+#
+#############################################################################
+
+from wsaconst import *
+import wsaglobals  # True global variables
+
+import httplib
+import pprint
+import json
+import optparse  # use argparse with Python 2.7.x ...
+from optparse import make_option
+from optparse import OptionGroup
+import string
+
+import sys
+import threading
+import time
+import traceback
+import types
+import ssl
+import os
+import re
+import __main__
+
+import logging
+import logging.config
+
+class progress_bar_loading(threading.Thread):
+
+    def run(self):
+            global stop
+            global kill
+            global progress_str
+            print progress_str + '....  ',
+            sys.stdout.flush()
+            i = 0
+            while stop != True:
+                    if (i % 4) == 0: 
+                        sys.stdout.write('\b/')
+                    elif (i % 4) == 1: 
+                        sys.stdout.write('\b-')
+                    elif (i % 4) == 2: 
+                        sys.stdout.write('\b\\')
+                    elif (i % 4) == 3: 
+                        sys.stdout.write('\b|')
+
+                    sys.stdout.flush()
+                    time.sleep(0.2)
+                    i += 1
+
+            if kill == True: 
+                print '\b\b\b\b ABORT!'
+            else: 
+                print '\b\b done!'
+            return
+        
+    def stop(self):
+        global stop
+        stop = True
+        
+    def configure(self,progress_string='Processing'):
+        global progress_str
+        progress_str = progress_string
+        global stop
+        stop = False
+        
+        
+
+progress_str = "Processing"
+kill = False      
+stop = False
+
+def initializeLogging():
+    logging.basicConfig(level=logging.DEBUG,
+                        format='%(asctime)s %(levelname)-8s %(message)s',
+                        datefmt='%a, %d %b %Y %H:%M:%S',
+                        filename='logs/console.log',
+                        filemode='w')
+
+
+
+
+
+WSA_UTILS_VERSION = "1.1"  # Current version of the API utilities
+
+#############################################################################
+# Determine which, if any, ActiveMQ clients are installed.  Set global flags
+# for later use.
+#############################################################################
+# Try STOMP
+try:
+    import stomp
+    stomp_present = True
+except ImportError:
+    # print "STOMPPY not installed or not supported"
+    stomp_present = False
+
+# Try PyActiveMQ
+try:
+    import pyactivemq
+    pyactivemq_present = True
+except ImportError:
+    # print "Pyactivemq not installed or not supported"
+    pyactivemq_present = False
+
+#############################################################################
+# Exceptions
+#############################################################################
+
+# General exception raised when api errors occur ...
+class ApiException(Exception) :
+
+    def __init__(self, text, response=None, keys=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text of exception
+        self.response = response  # Response object, if applicable
+        self.keys = keys  # Keys in error, only used by validate_response and
+                                 # validate_dictionary methods
+
+    def __str__(self) :
+
+        text = self.text
+        keys = self.keys
+        resp = self.response
+
+        result = []
+        result.append('ApiException caught ...\n\n')
+        result.append('MESSAGE :\n')
+        result.append(text)
+        result.append('\n')
+
+        if resp is None or not hasattr(resp, 'body'):
+            if keys is not None :
+                result.append(keys)
+        else :
+            body = resp.body
+            message = body[ 'message' ]     if 'message'     in body else None
+            status = body[ 'http-status' ] if 'http-status' in body else None
+            reason = body[ 'reason' ]      if 'reason'      in body else None
+            uri = body[ 'request-uri' ] if 'request-uri' in body else None
+            result.append('\nReturn Code = ')
+            if status is not None and reason is not None :
+                result.append(status)
+                result.append('.')
+                result.append(reason)
+            else :
+                result.append(str(resp.status))
+            result.append(' ')
+            result.append(resp.reason)
+            if message is not None :
+                result.append('\nResponse Message = ')
+                result.append(message)
+            if keys is not None :
+                result.append(' : ')
+                result.append(keys)
+            if uri is not None :
+                result.append('\nRequest URI = ')
+                result.append(uri)
+            result.append('\n\n')
+            result.append(resp)
+
+        result.append('\n\nStack Trace :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+
+        return ''.join([ str(s) for s in result ])
+
+
+#############################################################################
+#
+# Fatal exception ... used for non-API errors ...
+#
+# @parm text      - message text
+# @parm response  - response from HTTP request.  This can be either an
+#                   httplib.HTTPResponse or wsautils.Response object
+# @parm traceback - stack trace, usually taken from a caught exception
+#                   since it will differ from the stack trace created
+#                   when the ApiFatalException is created.
+# @parm request   - a wsautils.Request object representing the information
+#                   sent via an HTTP request.  Since testcase writers do not
+#                   generally have access to the HTTP request, this parameter
+#                   should be considered internal to wsautils only.
+# @parm other     - additional, relevant data provided by the testcase writer
+#                   that may help with diagnostics.
+#
+#############################################################################
+
+class ApiFatalException(Exception) :
+
+    def __init__(self, text, response=None, traceback=None, other=None, request=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text for exception
+        self.response = response
+        self.traceback = traceback
+        self.other = other
+        self.request = request
+
+    def __str__(self) :
+
+        result = []
+        result.append('ApiFatalException caught\n\n')
+        result.append('MESSAGE :\n')
+        result.append(self.text)
+        result.append('\n\n')
+
+        if self.response is None and self.request is not None :
+            result.append('REQUEST :\n')
+            result.append(self.request)
+            result.append('\n\n')
+
+        if self.response is not None :
+            result.append('RESPONSE :\n')
+            if isinstance(self.response, httplib.HTTPResponse) :
+                result.append(Response(self.response.status,
+                                         self.response.reason,
+                                         self.response.getheaders(),
+                                         self.response.read()))
+            else :
+                result.append(self.response)
+
+            result.append('\n\n')
+
+        # Append the stack trace created when raising this exception ...
+        result.append('TRACEBACK (most recent stack) :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+        result.append('\n')
+
+        # If present, this should be the stack trace created by the
+        # 'caught' exception that was wrapped inside the ApiFatalException
+        if self.traceback is not None :
+            result.append('TRACEBACK (from caught exception) :\n')
+            stack = traceback.format_tb(self.traceback)
+            result.append(''.join([ s for s in stack ]))
+            result.append('\n')
+
+        if self.other is not None :
+            result.append('OTHER :\n')
+            result.append(self.other)
+            result.append('\n')
+
+        return ''.join([ str(s) for s in result ]).strip()
+
+
+#############################################################################
+# Request Class
+#############################################################################
+
+class Request :
+
+    """This class encapsulates an HTTP request"""
+
+    def __init__(self, operation, uri, headers, body) :
+        self.operation = operation
+        self.uri = uri
+        self.headers = headers
+        self.body = body
+
+    def __str__(self) :
+        l = []
+        l.append('Request Operation : ')
+        l.append(str(self.operation))
+        l.append('\nRequest URI       : ')
+        l.append(str(self.uri))
+
+        l.append('\nRequest Headers   : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nRequest Body      : ')
+        if self.body == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(json.loads(self.body), sort_keys=True, indent=1, separators=(',', ':')))
+
+        return ''.join([ s for s in l ])
+
+
+#############################################################################
+#
+# Response Class
+#
+# This class models an HTTP response object.  The response headers will be
+# converted to a Python dictionary and the response body will be processed
+# through the JSON parser if the content-type header is 'application/json'.
+#
+# If the 'content-type' indicates the body is a json-formatted string and
+# the subsequent call to json.loads fails to parse the body, an
+# ApiFatalException with be raised.  The response will be added to the
+# exception, but the body will the unparse HTTP response body.
+#
+#############################################################################
+
+class Response :
+
+    """This class encapsulates an HTTP response"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    # Initialize a response
+    def __init__(self, status, reason, headers, body, request=None) :
+
+        # ##print '====================== begin body ====================================================='
+        # ##print body
+        # ##print '====================== end body ======================================================='
+        self.status = status  # HTTP response status
+        self.reason = reason  # HTTP response reason
+        self.headers = dict(headers)  # HTTP response headers
+        self.body = body  # HTTP response body
+        self.request = request  # HTTP request
+        self.bodyIsJSON = False  # Indicates whether the saved response body is a parsed JSON string
+
+        if body is not None and len(body) > 0 :
+            if self.headers[ CONTENT_TYPE ].startswith(WSA_CONTENT_JSON) :
+                try :
+                    # Parse the body and save the parsed version
+                    self.body = json.loads(body)
+                    self.bodyIsJSON = True  # Body is now a parsed JSON string
+                except :
+                    raise ApiFatalException(''.join([ str(s) for s in sys.exc_info()[1].args ]), response=self)
+            else :
+                self.body = body
+        else :
+            self.body = '{}'
+            self.bodyIsJSON = True  # Body is a parsed JSON string (an empty body)
+
+    # Print out a string representation of the response
+    def __str__(self) :
+        l = []
+        if self.request is not None :
+            l.append(self.request)
+            l.append('\n\n')
+        l.append('Response Status  : ')
+        l.append(self.status)
+        l.append('\nResponse Reason  : ')
+        l.append(self.reason)
+
+        l.append('\nResponse Headers : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nResponse Body    : ')
+        if self.bodyIsJSON:
+            l.append(json.dumps(self.body, sort_keys=True, indent=1, separators=(',', ':')))
+            if 'stack' in self.body:
+                l.append('\n\nstack (again, but in a more programmer-friendly format):\n')
+                l.append(self.body[ 'stack' ])
+        else:
+            l.append(str(self.body))
+
+
+        return ''.join([ str(s) for s in l ])
+
+
+#############################################################################
+#
+# Session Class
+#
+# This class represents a persistent HTTP connection to an HMC.  As such,
+# when the test code is finished with the HTTP connection, the close
+# method should be called to ensure resources are cleaned up.
+#
+# Currently, only JSON-formatted request bodies are supported.  Addtional
+# formats can be added in the future, as needed.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted for this Session.  See parse_standard_options()
+# for more details.  The option values may be referenced via the "opts" member
+# of the Session object.  For example, if an option was defined with dest='sr_name':
+#      name = session.opts.sr_name
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  See
+# parse_standard_options() for more details.  The command line arguments can
+# be referenced via the "args" member of the Session object, for example,
+# to access the first testcase-specific positional argument:
+#      property_name = session.args[session.arg_start_index + 0]
+#
+# Note that the __init__ method calls parse_standard_options(), which uses os._exit(rc)
+# in some cases rather than the more common sys.exit(rc).  See the prolog of
+# parse_standard_options for more details.
+#############################################################################
+
+class Session :
+
+    """This class supports connecting to an Ensemble HMC via HTTP"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    def __init__(self, host=None, port=None, user=None, pwd=None, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+        """Initialize an instance of the Session class"""
+        # Save any additional command line option definitions so that they're available
+        # when the command line is re-parsed if another session is established.
+        wsaglobals.global_saved_additional_options = additional_options
+#       print 'in Session init: global_saved_additional_options=%s' % wsaglobals.global_saved_additional_options
+        opts, args = parse_standard_options(additional_options, additional_arguments_usage_info)  # Read in command line arguments and options, if any ...
+        self.opts = opts  # Keep all parsed options for anyone that might need them
+        self.args = args  # Keep all parsed arguments for anyone that might need them
+        self.arg_start_index = 0  # The index of the first test-case specific argument, if any.
+                                    # There are currently no "standard" arguments, so all arguments
+                                    # are, in effect, test-case specific; thus this index is 0.
+
+        # Save values from the command line or our caller, as appropriate
+        self.__host = opts.host if host is None else host
+        self.__port = opts.port if port is None else port
+        self.__user = opts.user if user is None else user
+        self.__pass = opts.pwd  if pwd  is None else pwd
+        self.__amq_client = opts.amq_client if amq_client is None else amq_client
+        self.__amq_socket_type = opts.amq_socket_type if amq_socket_type is None else amq_socket_type
+        self.__api_version_override = opts.api_version_override
+        self.__get_properties = opts.get_properties
+        self.__check_properties = opts.check_properties
+        self.__run_if_applicable = opts.run_if_applicable
+        self.__required_version = opts.required_version
+        self.__required_capabilities = opts.required_capabilities
+        self.__required_components = opts.required_components
+        self.__required_scenario_types = opts.required_scenario_types
+        self.__required_execution_types = opts.required_execution_types
+
+        self.__args = args
+
+        self.__connection = None  # Persistent HTTP connection
+        self.__session = None  # Session id
+        self.__topic = None  # Topic id for ActiveMQ notifications
+                                   #
+        self.__api_version = None  # WSA API version supported by HMC
+        self.__hmc_name = None  # Name of the connected HMC
+        self.__hmc_version = None  # Version of the connected HMC
+        self.__jobtopic = None  # Topic id for ActiveMQ JOB Notifications
+        self.__api_features = None  # List of available WS API features
+                                   #
+        self.__consumer = None  # ActiveMQ notification consumer
+        self.__callback = None  # Callback method for notification messages
+
+
+        #########################################################################
+        # If no ActiveMQ client was specified, choose one based on what's installed
+        # and available if possible.  Then, if no SSL preference was specified,
+        # select a sensible one based on the ActiveMQ client.  Then, set the ActiveMQ
+        # port to the appropriate port number.
+        #########################################################################
+        # Determine the client type
+        if self.__amq_client is None:
+            if stomp_present == True:  # STOMP is installed; use it
+                self.__amq_client = AMQ_CLIENT_STOMP
+            elif pyactivemq_present == True:  # No STOMP, but PyActiveMQ is installed; use it
+                self.__amq_client = AMQ_CLIENT_PYACTIVEMQ
+            else:  # None installed, so just go with the default here; errors will be surfaced later if an AMQ client is actually required.
+                self.__amq_client = WSA_DEFAULT_AMQ_CLIENT
+
+        # Use PyActiveMQ ActiveMQ client
+        if self.__amq_client == AMQ_CLIENT_PYACTIVEMQ:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_NON_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:  # Sensible?  Current versions of pyactivemq don't support SSL
+                self.__amq_port = WSA_ACTIVEMQ_PORT_SSL
+            else:
+                self.__amq_port = WSA_ACTIVEMQ_PORT_NON_SSL
+
+        # Use STOMP ActiveMQ client
+        else:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:
+                self.__amq_port = WSA_STOMP_PORT_SSL
+            else:
+                self.__amq_port = WSA_STOMP_PORT_NON_SSL
+
+#       print "pyactivemq_present = " + str(pyactivemq_present)
+#       print "stomp_present = " + str(stomp_present)
+#       print "leaving parse_standard_options() with"
+#       print "\t self.__amq_client=" + str(self.__amq_client)
+#       print "\t self.__amq_socket_type=" + str(self.__amq_socket_type)
+#       print "\t self.__amq_port=" + str(self.__amq_port)
+#       print "\t self.__get_properties=" + str(self.__get_properties)
+
+
+    #########################################################################
+    # Open connection to HMC
+    #########################################################################
+
+    def open(self) :
+
+        """Create a persistent HTTP connection to an HMC, then logon"""
+
+        body = json.dumps({ 'userid':self.__user, 'password':self.__pass })
+
+        # Issue the Logon request
+        response = self.__executeRequest(WSA_COMMAND_POST, WSA_URI_LOGON, body, WSA_CONTENT_JSON)
+
+        # Check the status code to be sure logon succeeded before trying to validate
+        # the response details.  For example, the response body might not even be a dictionary.
+        if response.status != 200:
+            raise ApiFatalException('Logon failed', response)
+
+
+#       print '****************'
+#       print response.request
+#       print '****************'
+#       print response.request.headers
+#       print '****************'
+#       print response.headers
+#       print '****************'
+
+
+
+        # Parse and validate the response to the Logon request.  Save info for later use.
+
+        if 'job-notification-topic' in response.body.keys():
+            self.__jobtopic = str(response.body[ 'job-notification-topic' ])
+            validate_response(response, WSA_LOGON_VALIDATE_JOB)
+        else :
+            validate_response(response, WSA_LOGON_VALIDATE)
+
+        self.__session = str(response.body[ 'api-session'        ])
+        self.__topic = str(response.body[ 'notification-topic' ])
+
+        if 'api-features' in response.body.keys():
+            self.__api_features = response.body[ 'api-features' ]  # List of strings
+        
+        # Now issue an API Version request and validate the response
+        response = self.get(WSA_URI_VERSION)
+        validate_response(response, WSA_VERSION_VALIDATE)
+
+        # Parse and save this session's version information
+        ver = []
+        ver.append(str(response.body[ 'api-major-version' ]))
+        ver.append('.')
+        ver.append(str(response.body[ 'api-minor-version' ]))
+
+        self.__api_version = "".join(ver)
+        self.__hmc_name = response.body[ 'hmc-name' ]
+        self.__hmc_version = response.body[ 'hmc-version' ]
+
+        # print "Topic ID: \t%s"     % self.__topic
+        # print "Job Topic ID: \t%s" % self.__jobtopic
+        # print "API version: \t%s"  % self.__api_version
+        # print "API features: \t%s" % self.__api_features
+
+        return self.__connection
+
+
+    #########################################################################
+    # Close connection to HMC
+    #########################################################################
+
+    def close(self) :
+        """Logoff from the HMC, then close the HTTP connection"""
+
+# # TODO : Close ActiveMQ consumer, too?
+
+        if self.__connection is not None :
+            try :
+                # Logoff active session, if needed ...
+                if self.__session is not None :
+                    response = self.delete(WSA_URI_LOGOFF)
+                    if response.status != 204 :
+                        raise ApiFatalException('Unexpected response status during logoff', response=response)
+            finally :
+                try :
+                   # Close the HTTP session
+                   self.__connection.close()
+                finally :
+                    if self.__consumer is not None and self.__consumer.isRunning() :
+                        self.__consumer.stop()
+
+
+    #########################################################################
+    # Get
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def get(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP GET operation"""
+        return self.__executeRequest(WSA_COMMAND_GET, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Put
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def put(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP PUT operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_PUT, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Post
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def post(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP POST operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_POST, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Delete
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def delete(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP DELETE operation"""
+        return self.__executeRequest(WSA_COMMAND_DELETE, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Host
+    #########################################################################
+
+    def host(self) :
+        """Return the host"""
+        return self.__host
+
+
+    #########################################################################
+    # Port
+    #########################################################################
+
+    def port(self) :
+        """Return the port"""
+        return self.__port
+
+
+    #########################################################################
+    # Userid
+    #########################################################################
+
+    def userid(self) :
+        """Return the userid"""
+        return self.__user
+
+
+    #########################################################################
+    # Password
+    #########################################################################
+
+    def password(self) :
+        """Return the password"""
+        return self.__pass
+
+
+    #########################################################################
+    # Session
+    #########################################################################
+
+    def session(self) :
+        """Return the active session identifier"""
+        return self.__session
+
+
+    #########################################################################
+    # Topic and job topic
+    #########################################################################
+
+    def topic(self) :
+        """Return the active topic identifier"""
+        return self.__topic
+
+
+    def jobtopic(self) :
+        """Return the active job topic identifier"""
+        return self.__jobtopic
+
+
+    #########################################################################
+    # Values related to the FVT regression tools
+    #########################################################################
+
+    def api_version_override(self) :
+        """Return the API version value from the command line"""
+        return self.__api_version_override
+
+    def get_properties(self) :
+        """Return the OPTION_GET_PROPERTIES setting"""
+        return self.__get_properties
+    def check_properties(self) :
+        """Return the OPTION_CHECK_PROPERTIES setting"""
+        return self.__check_properties
+    def run_if_applicable(self) :
+        """Return the OPTION_RUN_IF_APPLICABLE setting"""
+        return self.__run_if_applicable
+
+    def required_version(self) :
+        """Return the testcase required_version"""
+        return self.__required_version
+
+    def required_capabilities(self) :
+        """Return the testcase required_capabilities"""
+        return self.__required_capabilities
+    def required_components(self) :
+        """Return the testcase required_components"""
+        return self.__required_components
+    def required_scenario_types(self) :
+        """Return the testcase required_scenario_types"""
+        return self.__required_scenario_types
+    def required_execution_types(self) :
+        """Return the testcase required_execution_types"""
+        return self.__required_execution_types
+
+
+    #########################################################################
+    # API Version
+    #########################################################################
+
+    def api_version(self) :
+        """Return the reported API version supported by the HMC"""
+        return self.__api_version
+
+
+    #########################################################################
+    # API Features
+    #########################################################################
+
+    def api_features(self) :
+        """Return the reported API features supported by the HMC"""
+        return self.__api_features
+
+
+    #########################################################################
+    # HMC Name
+    #########################################################################
+
+    def hmc_name(self) :
+        """Return the name of the connected HMC"""
+        return self.__hmc_name
+
+
+    #########################################################################
+    # HMC Version
+    #########################################################################
+
+    def hmc_version(self) :
+        """Return the version of the connected HMC"""
+        return self.__hmc_version
+
+
+    #########################################################################
+    # Register and start receiving general notification messages
+    #########################################################################
+
+    def start_receiving_messages(self, callback=None) :
+        # print "in start_receiving_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__topic, callback)  # Start receiving messages for the general notification topic
+
+
+    #########################################################################
+    # Register and start receiving job notification messages
+    #########################################################################
+
+    def start_receiving_job_messages(self, callback=None) :
+        # print "in start_receiving_job_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__jobtopic, callback)  # Start receiving messages for the job notification topic
+
+
+    #########################################################################
+    # Register and start receiving audit log notification messages
+    #########################################################################
+
+    def start_receiving_audit_messages(self, callback=None) :
+        # print "in start_receiving_audit_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'audit')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the audit notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the audit notification topic
+
+
+    #########################################################################
+    # Register and start receiving security log notification messages
+    #########################################################################
+
+    def start_receiving_security_messages(self, callback=None) :
+        # print "in start_receiving_security_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'security')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the security notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the security notification topic
+
+
+    #########################################################################
+    # Register and start receiving messages for the specified topic
+    #########################################################################
+
+    def start_message_consumer(self, topic, callback=None) :
+        try :
+            # print "in start_message_consumer(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+
+            if (self.__amq_client == AMQ_CLIENT_PYACTIVEMQ):  # Use PyActiveMQ ActiveMQ consumer.  It supports only non-SSL connections
+                if pyactivemq_present == False:
+                    raise ApiFatalException("Cannot use PyActiveMQ ActiveMQ client - pyactivemq module is not installed")
+                self.__consumer = PyActiveMQ_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+            else:  # Use STOMP ActiveMQ consumer.  It supports both SSL and non-SSL connections
+                if stomp_present == False:
+                    raise ApiFatalException("Cannot use STOMP ActiveMQ client - stomp module is not installed")
+                self.__consumer = STOMP_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+
+            # print "About to start() the message consumer"
+            self.__consumer.start()
+        except :
+            raise ApiFatalException(sys.exc_info()[1].args)
+
+
+
+    #########################################################################
+    # Stop receiving notification messages
+    #########################################################################
+
+    def stop_receiving_messages(self) :
+        self.__consumer.stop()
+
+
+    #########################################################################
+    # Determine whether any notification messages have been received
+    #########################################################################
+
+    def has_messages(self) :
+        return self.__consumer.has_messages()
+
+    #########################################################################
+    # Retrieve existing notification messages ... empty message queue
+    #########################################################################
+
+    def get_received_messages(self) :
+        return self.__consumer.get_messages()
+
+
+    #########################################################################
+    # Retrieve raw notification messages ... empty message queue
+    # Should be used for debug only ...
+    #########################################################################
+
+    def get_raw_messages(self) :
+        return self.__consumer.get_raw_messages()
+
+
+    #########################################################################
+    #
+    # __executeRequest (package private method)
+    #
+    # This method is private to the class and NOT called directly.
+    #
+    # Currently, the supported content types are :
+    #
+    #    None and 'application/json'
+    #
+    # Specify return_full_response=False to prevent this method from reading
+    # response body and closing the HTTP(S) connection.  This allows the
+    # caller to read the response as it sees fit, for example, one byte at a
+    # time.  In this case, the caller is responsible for closing the HTTP(S)
+    # connection.  The read_response_streamed method in this class can be used
+    # to read the response body one byte at a time and then close the connection.
+    #
+    #########################################################################
+
+    def __executeRequest(self, operation, uri, body, content, headers=None, return_full_response=True) :
+
+        """Execute an HTTP request"""
+
+        request = None
+        response = None
+
+        try :
+
+            # Build up the default HTTP headers
+            if headers is None :
+                requestHeaders = {}
+                requestHeaders[ 'Accept' ] = '*/*'
+                if content in WSA_SUPPORTED_CONTENT :
+                    requestHeaders[ WSA_HEADER_CONTENT ] = content
+                if body is not None :
+                    requestHeaders[ WSA_HEADER_CONTENT_LENGTH ] = len(body)
+                if self.__session is not None :
+                    requestHeaders[ WSA_HEADER_RQ_SESSION ] = self.__session
+            else :
+                requestHeaders = headers.copy()
+
+            request = Request(operation, uri, requestHeaders, body)
+
+            # **MHB**
+            # Persistent connections, both SSL and non-SSL, are being closed after sitting
+            # idle for 15-30 seconds.  As a workaround, create a new HTTP connection for
+            # each request until a solution can be found ...
+            if self.__port == WSA_PORT_SSL :
+                # Beginning with Python 2.7.9, SSL connections are more secure and require a valid
+                # X509 certificate signed by a trusted CA.  Since the HMC uses a self-signed certificate,
+                # we revert to previous Python behavior by explicitly requesting an unverified context.
+                # This is generally not advisable, for obvious reasons, but it is acceptable in the
+                # development and test environments in which these API test utilities are intended to
+                # be used.
+                if sys.hexversion < 0x020709F0:  # Prior to 2.7.9; use default behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port)
+                else:  # 2.7.9 or later; specifically request prior behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port, context=ssl._create_unverified_context())
+                    print ""
+                    
+            else :
+                self.__connection = httplib.HTTPConnection(self.__host, self.__port)
+
+            try :
+                self.__connection.request(operation, uri, body, requestHeaders)
+                response = self.__connection.getresponse()
+                # If we're returning the full Response object, then read the response body and construct a Response object;
+                # otherwise, we just return the response from the HTTP(S)Connection object.
+                if return_full_response is True :
+                    result = Response(response.status, response.reason, response.getheaders(), response.read(), request)
+                else :
+                    result = response
+            finally :
+                # If we're returning the full Response object, then we've already read the response and can close out HTTP(S) connection.
+                # Otherwise, leave it open for later reading by, for example, read_response_streamed().  Callers that specify
+                # return_full_response=False are responsible for closing this connection.
+                if return_full_response is True :
+                    self.__connection.close()
+
+        except (ApiFatalException, ApiFatalException) :
+            raise
+        except :
+            text = self.buildExceptionMessage()
+            raise ApiFatalException(text, response=response, traceback=sys.exc_info()[2])
+
+        return result
+
+
+    def buildExceptionMessage(self) :
+        name = sys.exc_info()[0]
+        args = []
+        for arg in sys.exc_info()[1].args :
+            if len(str(arg)) > 0 :
+                args.append(arg)
+                args.append(' ')
+        text = ''.join([ str(s) for s in args ]).strip()
+        return str(name) + ' ' + text
+
+
+    #########################################################################
+    #
+    # read_response_streamed method
+    #
+    # Use this method to read the response to a request that was issued via
+    # __executeRequest with return_full_response==False.  This method will
+    # read the response one byte at a time and then close the connection.
+    #
+    # The response argument is the response as returned from
+    # self.__connection.getresponse().
+    #
+    #########################################################################
+
+    def read_response_streamed(self, response):
+        try :
+            print "\nAbout to read the response one byte at a time...\n"
+            responseString = ""
+            chunk = response.read(1)
+            while (chunk != ""):
+                responseString += chunk
+                sys.stdout.write(chunk)
+                chunk = response.read(1)
+
+        finally :
+            self.__connection.close()
+
+        return responseString
+
+
+#############################################################################
+#
+# Class PyActiveMQ_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a PyActiveMQ client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class PyActiveMQ_Consumer() :
+    # Only define the internals of this class if PyActiveMQ is installed, due to references to the pyactivemq module
+    if (pyactivemq_present == True):
+        """Private class ... do not use directly"""
+
+        class __MessageListener(pyactivemq.MessageListener):
+
+            def __init__(self, topic, callback):
+                pyactivemq.MessageListener.__init__(self)
+                self.topic = topic
+                self.callback = callback
+
+            def onMessage(self, message):
+                try :
+                    self.callback(self.topic, message)
+                except :
+                    print traceback.print_exc()
+
+
+        def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+            """This is the constructor ... all parameters required, exception callback"""
+
+            self.messageLock = threading.Lock()  # Control access to message queue
+
+            self.running = False
+
+            self.host = host
+            self.port = port
+            self.username = username
+            self.password = password
+            self.topic = topic
+            self.use_ssl = use_ssl
+
+            if callback is None :
+                self.callback = self.__callback
+                self.messages = []
+                self.raw_messages = []
+            else :
+                self.callback = callback
+
+            self.url = 'tcp://' + str(self.host) + ':' + str(self.port)
+
+            self.factory = pyactivemq.ActiveMQConnectionFactory(self.url)
+            self.factory.username = self.username;
+            self.factory.password = self.password;
+            print("Creating PyActiveMQ consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+            self.connection = self.factory.createConnection()
+            self.session = self.connection.createSession()
+            self.consumer = self.session.createConsumer(self.session.createTopic(self.topic), "")
+            self.listener = self.__MessageListener(self.topic, self.callback)
+            self.consumer.messageListener = self.listener
+
+
+        def start(self) :
+            """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+            self.connection.start()
+
+
+            self.running = True
+
+        def stop(self) :
+            """Stop consuming messages from the ActiveMQ server"""
+            time.sleep(2)
+
+            self.connection.close()
+            self.running = False
+
+        def isRunning(self) :
+            """Connection still active?"""
+            return self.running
+
+        def has_messages(self) :
+            """Test whether any messages have been received"""
+            self.messageLock.acquire()
+            try :
+                return len(self.messages) > 0
+            finally :
+                self.messageLock.release()
+
+        def get_messages(self) :
+            """Get the current list of received messages ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.messages)
+                self.messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def get_raw_messages(self) :
+            """Get the list of raw messges received so far ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.raw_messages)
+                self.raw_messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def __toDictionary(self, message) :
+            """Convert a raw message to a dictionary"""
+            if message is None : return None
+
+            result = {}
+            result[ 'expiration' ] = message.expiration
+            result[ 'timestamp'  ] = message.timestamp
+            result[ 'text'       ] = message.text if len(message.text) > 0 else None
+
+            # Fetch each property in the message and put it into the dictionary.  Treat each
+            # property as a string, unless specifically identified otherwise.  Use the 
+            # appropriate getXXXProperty() method to fetch the value from the raw message.
+            for property in message.propertyNames :
+                string_type = True  # Assume a standard string type, not handled yet
+                # See if this is one of the non-string properties
+                for property_name, property_type in nonstring_message_properties:
+                    if not string_type:  # Known not to be a string; already handled
+                        break
+                    if property == property_name:  # Some non-string type; handle specially
+                        # ##print "Fetching " + property_name + " as type " + property_type
+                        if property_type == 'long':
+                            try:
+                                result[ property ] = message.getLongProperty(property)
+                                string_type = False  # Non-string type; handled
+                            except :  # Failed conversion; ignore and leave it as a string...
+                                print "\n********** error fetching '" + property + "' property as type " + property_type + " from incoming notification message! ***********"
+                                print "Treating it as type string\n"
+                                traceback.print_exc()
+                                # (Allow this code path to continue and attempt to fetch it as a string...)
+                if string_type:
+                    try :
+                        # ##print "Fetching " + property_name + " as type string"
+                        result[ property ] = message.getStringProperty(property)
+                    except :
+                        print "\n********** error fetching '" + property + "' property as type string from incoming notification message! ***********\n"
+                        traceback.print_exc()
+                        result[ property ] = None
+
+                # ##print "property name: " + property + "; value=" + str(result[property]) + "; type=" + str(type(result[property]))
+
+            return result
+
+        def __callback(self, topic, message) :
+            """The default callback method to receive incoming messages"""
+            self.messageLock.acquire()
+            try :
+                if message is not None :
+                    self.messages.append(self.__toDictionary(message))
+                    self.raw_messages.append(message)
+            finally :
+                self.messageLock.release()
+
+        def __execute(self, connection) :
+            """Start listening for messages - deprecated"""
+            try :
+                self.running = True
+                connection.start()
+                while self.running :
+                    time.sleep(1)
+            finally :
+                self.running = False
+                connection.close()
+
+
+#############################################################################
+#
+# Class STOMP_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a STOMP client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class STOMP_Consumer() :
+    """Private class ... do not use directly"""
+
+    class __STOMPInternalListener():
+
+            def __init__(self, topic, callback):
+                self.callback = callback
+                self.topic = topic
+
+            def on_connecting(self, host_and_port):
+
+                print "Started connecting to broker..."
+
+            def on_connected(self, headers, message):
+
+                print "Now connected to broker: %s" % message
+
+            def on_disconnected(self, headers, message):
+
+                print "No longer connected to broker: %s" % message
+
+            def on_error(self, headers, message):
+
+                print "Received an error: %s" % message
+
+            def on_message(self, headers, message):
+                # This method processes an HMC APi notificaiton message which
+                # always have header fields, and may optionally contain a body
+                # that is a string containing a JSON object.
+
+                try :
+                    # print "inside on_message block"
+                    # print "H is", headers
+                    # print "M is",message
+                    
+                    # If this is a Property Change notification or a Status Change notification, put the body into
+                    # a header named 'text'.  That's where PyActiveMQ puts it, and this hides that difference from
+                    # other places in our Test utilities and the testcase programs themselves.
+                    if (headers['notification-type'] == 'property-change' or headers['notification-type'] == 'status-change' or headers['notification-type'] == 'log-entry'):
+                        headers['text'] = message
+
+                    self.callback(self.topic, headers)
+                except :
+                    print traceback.print_exc()
+
+
+
+
+    def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+        """This is the constructor ... all parameters required, exception callback"""
+
+        self.messageLock = threading.Lock()  # Control access to message queue
+
+        self.running = False
+
+        self.host = host
+        self.port = port
+        self.username = username
+        self.password = password
+        self.topic = topic
+        self.use_ssl = use_ssl
+
+        if callback is None :
+            self.callback = self.__callback
+            self.messages = []
+            self.raw_messages = []
+        else :
+            self.callback = callback
+
+        self._dest = "/topic/" + self.topic
+        print("Creating STOMP consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+        self.connection = stomp.Connection([(self.host, self.port)], self.username,
+                                            self.password, use_ssl=self.use_ssl,
+                                            ssl_version=ssl.PROTOCOL_SSLv23)
+
+        self._internal_listener = self.__STOMPInternalListener(self.topic, self.callback)
+        self.connection.set_listener('', self._internal_listener)
+
+
+    def start(self) :
+        """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+        self.connection.start()
+        self.connection.connect(wait=True)
+        time.sleep(10)
+        self.connection.subscribe(destination=self._dest, ack="auto")
+
+        self.running = True
+
+    def stop(self) :
+        """Stop consuming messages from the ActiveMQ server"""
+        time.sleep(2)
+
+        self.connection.stop()
+        self.running = False
+
+    def isRunning(self) :
+        """Connection still active?"""
+        return self.running
+
+    def has_messages(self) :
+        """Test whether any messages have been received"""
+        self.messageLock.acquire()
+        try :
+            return len(self.messages) > 0
+        finally :
+            self.messageLock.release()
+
+    def get_messages(self) :
+        """Get the current list of received messages ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.messages)
+            self.messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def get_raw_messages(self) :
+        """Get the list of raw messges received so far ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.raw_messages)
+            self.raw_messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def __toDictionary(self, message) :
+        """Convert a raw message to a dictionary"""
+        if message is None : return None
+        result = message
+        return result
+
+    def __callback(self, topic, message) :
+        """The default callback method to receive incoming messages"""
+        self.messageLock.acquire()
+        try :
+            if message is not None :
+
+                # Regardless of the type specified by the HMC code that builds the JMS message, 
+                # the properties always seem to arrive as strings.  Convert the non-string
+                # properties to their proper type here.
+                for property_name, property_type in nonstring_message_properties:
+                    try:
+                        if property_type == 'long':
+                            # ##print "Converting " + property_name + " to " + property_type
+                            message[property_name] = long(message[property_name])
+                    except ValueError:  # Failed conversion; ignore and leave it as a string...
+                        print "\n********** error converting '" + property_name + "' property to type " + property_type + " from incoming notification message! ***********"
+                        print "Leaving it as type " + str(type(message[property_name])) + "\n"
+
+                self.messages.append(self.__toDictionary(message))
+                self.raw_messages.append(message)
+        finally :
+            self.messageLock.release()
+
+    def __execute(self, connection) :
+        """Start listening for messages - deprecated"""
+        try :
+            self.running = True
+            connection.start()
+            while self.running :
+                time.sleep(1)
+        finally :
+            self.running = False
+            connection.close()
+
+#############################################################################
+# Miscellaneous Functions
+#############################################################################
+
+#############################################################################
+#
+# Function parse_standard_options
+#
+# Parses command line options
+#
+# Standard options available to all testcases are :
+#
+#    --addr = IP address of the target HMC
+#    --port = Port number to connect to on the target HMC
+#    --user = Logon userid to use on the target HMC
+#    --pass = Logon password to use on the target HMC
+#    --amq-client = ActiveMQ client to use for notification messages
+#    --amq-socket-type = Type of socket to use for ActiveMQ messages; either ssl or non-ssl
+#    --api-version = Version of the API being tested.  Use this to override the version 
+#                    information reported by the API framework.
+#    
+#    These options are provided primarily to support the FVT regression testing tools.  They are
+#    available to all testcases:
+#    --get-properties = a request to return the testcase's properties
+#    --check-properties = a request to check the testcase's properties against the specified required properties
+#    --run-if-applicable = a request to check the testcase's properties and then run the testcase if all requirements are met
+#    --min-version = required minimum version
+#    --max-version = required maximum version
+#    --capability = required capability; may be specified multiple times
+#    --component = required component; may be specified multiple times
+#    --scenario  = required scenario type; may be specified multiple times
+#    --execution-type = required execution type; may be specified multiple times
+#
+# NOTE : Currently, if ommitted, these values will default to :
+#
+#    Logon to R32 HMC ( 9.60.15.48 ) on the default WSA SSL port with user ensadmin
+#    An ActiveMQ client is chosen based on what is installed; STOMP over SSL is preferred.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted.  It is a list of Option objects created via
+# the make_option() function in the optparse library.  For example:
+#     additional_opts = [
+#         make_option("--srname", dest="storage_resource_name", type="string", default="tempSR", help='The name of the storage resource to be created.  Default is %default.'),
+#         make_option("--count", dest="iteration_count", metavar="COUNT", type="int", help='The number of iterations to run'),
+#         make_option("--treat", dest="dessert", type="choice", choices=["candy", "soda", "fudge"], help='Your dessert choice')
+#         make_option("--verbose", "-v", dest="verbose", action="store_true", default=False, help="Specify this option to get lots of output.  Default is %default."),
+#         ]
+#         
+# Those option definitions are then passed to session_startup():
+#       # Create a session and parse the command line, including our additional options
+#       session = session_startup(additional_options=additional_opts)
+#
+# Note that it is permissible to override any of the standard options by specifying them in additional_options.
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  For example,
+#      my_args_usage_info = "property_name timeout_seconds"
+#
+# To see the usage and help information on the command line, issue:
+#         "<script_name> -h" or "<script_name> --help"
+#               
+# Note that this method uses os._exit(rc) in some cases rather than the more
+# common sys.exit(rc).  os._exit(rc) makes a quick exit from the testcase
+# script without raising any exception, including SystemExit.  This makes
+# for a cleaner exit sequence in these special situations.  Note, however,
+# that it also bypasses any finally block; this should be OK, since no
+# session has been created yet and there is most likely no resource cleanup
+# necessary at this point in testcase execution.
+#
+#############################################################################
+
+def parse_standard_options(additional_options=None, additional_arguments_usage_info=None) :
+    # Define the standard options
+    option_list = [
+       make_option(OPTION_ADDR, dest='host', type='string', default=DEFAULT_ADDR,
+           help='The IP address or hostname of the target HMC.  Default=%default'),
+       make_option(OPTION_PORT, dest='port', type='int', default=DEFAULT_PORT,
+           help='The TCP/IP port number on which to connect to the target HMC for Web Services API requests.  Default=%default'),
+       make_option(OPTION_USER, dest=OPTION_USER_DEST, type='string', default=WSA_DEFAULT_USERID,
+           help='The HMC userid to use for the API request.  Default=%default'),
+       make_option(OPTION_PASS, dest=OPTION_PASS_DEST, type='string', default=WSA_DEFAULT_PASSWORD,
+           help='The login password for the HMC userid to use for the API request.  Default is the default user\'s standard password.'),
+       make_option('--amq-client', dest='amq_client', type='choice', choices=[AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP],
+           help='ActiveMQ client: %s or %s.  Default is %s unless it is not installed and %s is installed.'
+               % (AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP, AMQ_CLIENT_STOMP, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option('--amq-socket-type', dest='amq_socket_type', type='choice', choices=[SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL],
+           help='ActiveMQ socket type: %s or %s.  Default depends on the ActiveMQ client: %s for %s; %s for %s.'
+               % (SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL, SOCKET_TYPE_SSL, AMQ_CLIENT_STOMP, SOCKET_TYPE_NON_SSL, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option(OPTION_API_VERSION, dest='api_version_override', metavar='API_VERSION', type='string',
+           help='The version information for the API implementation being tested.  Specify this to override the version level reported by the API framework on the target HMC.'),
+       # for force tags
+       make_option("--include", type='string', default=""),
+       make_option("--exclude", type='string', default=""),
+       make_option("--variablefile", type='string', default=""),
+       make_option("--outputdir", type='string', default=""),
+        
+       ]
+
+    # Define our usage statement
+    usage_info = "%prog [options]"  # There are no standard command line arguments, only options
+
+    # Add any additional testcase-specific options
+    if additional_options is not None:
+        option_list.extend(additional_options)
+    
+
+    # Add any additional testcase-specific usage information
+    if additional_arguments_usage_info is not None:
+        usage_info += " " + additional_arguments_usage_info
+    # Create a parser with the options
+    parser = optparse.OptionParser(option_list=option_list, usage=usage_info, conflict_handler="resolve")
+
+    # Define a group of options intended for use by the FVT regression bucket and then add the specific option definitions to the group.
+    # This group will appear separate from the other command line options in the usage and help information.
+    FVT_option_group = OptionGroup(parser, 'Function Verification Test (FVT) regression test options', 'These options are intended primarily for use by the FVT regression tools.'
+        + '  Only one of %s, %s or %s may be specified.' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        + '  Some options may each be specified more than once.  If so, a testcase need only support one of the specified values in order to satisfy that requirement.'
+        + '  These options are: %s, %s, %s and %s' % (OPTION_CAPABILITY, OPTION_COMPONENT, OPTION_SCENARIO, OPTION_EXECUTION_TYPE))
+    
+    # The type of operation to perform.  Only 1 of these should be specified.
+    FVT_option_group.add_option(make_option(OPTION_GET_PROPERTIES, dest='get_properties', action='store_true', default=False,
+        help='Denotes a request to return the testcase properties.  These are defined by the %s variable in the testcase source code.' % TESTCASE_PROPERTIES_VARIABLE_NAME))
+    FVT_option_group.add_option(make_option(OPTION_CHECK_PROPERTIES, dest='check_properties', action='store_true', default=False,
+        help='Denotes a request to check testcase properties against the required testcase properties specified on the command line.'))
+    FVT_option_group.add_option(make_option(OPTION_RUN_IF_APPLICABLE, dest='run_if_applicable', metavar='APPLICABLE', action='store_true', default=False,
+        help='Denotes a request to check properties as if %s were specified and then, if the testcase meets the specified requirements, actually execute the testcase.' % OPTION_CHECK_PROPERTIES))
+    # Required API version
+    FVT_option_group.add_option(make_option(OPTION_REQUIRED_VERSION, dest='required_version', metavar='VERSION', type='choice', choices=TC_API_VERSION_LIST,
+        help='A required testcase property: the required API version.  The testcase must support this API level.'
+             '  That is, this level must be between the testcase\'s supported minimum and maximum levels, inclusive.  Valid values are: %s' % TC_API_VERSION_LIST))
+    # Testcase properties that can have multiple values.  If a property is specified more than once on the command line, a testcase is
+    # considered to meet that criterion if it includes at least one of the specified values.  That is, they are logically OR'd together.
+    # Then the different properties are AND'd together.
+    FVT_option_group.add_option(make_option(OPTION_CAPABILITY, dest='required_capabilities', metavar='CAPABILITY', action='append', choices=TC_CAPABILITY_LIST,
+        help='A required testcase property: a capability.  May be specified multiple times.  Valid values are: %s' % TC_CAPABILITY_LIST))
+    FVT_option_group.add_option(make_option(OPTION_COMPONENT, dest='required_components', metavar='COMPONENT', action='append', choices=TC_COMPONENT_LIST,
+        help='A required testcase property: a component.  May be specified multiple times.  Valid values are: %s' % TC_COMPONENT_LIST))
+    FVT_option_group.add_option(make_option(OPTION_SCENARIO, dest='required_scenario_types', metavar='SCENARIO_TYPE', action='append', choices=TC_SCENARIO_TYPE_LIST,
+        help='A required testcase property: a scenario.  May be specified multiple times.  Valid values are: %s' % TC_SCENARIO_TYPE_LIST))
+    FVT_option_group.add_option(make_option(OPTION_EXECUTION_TYPE, dest='required_execution_types', metavar='EXECUTION_TYPE', action='append', choices=TC_EXECUTION_TYPE_LIST,
+        help='A required testcase property: an execution type.  May be specified multiple times.  Valid values are: %s' % TC_EXECUTION_TYPE_LIST))
+
+    # Add the group of FVT regression bucket options
+    parser.add_option_group(FVT_option_group)
+
+    (opts, args) = parser.parse_args()
+
+    #
+    # The command line options have been parsed and validated.  Some of them will be handled
+    # here.  These are the FVT regression run options.  Individual testcases don't even need
+    # to know that these options exist.  Handle them and then exit the testcase directly (not
+    # even "finally:" blocks are executed).  If none of these special options was specified,
+    # return the option and argument collections to the caller for handling of the other
+    # options and arguments, if any.
+    #
+
+    # Determine and validate the type of request specified on the command line, if any
+    get_properties_request = opts.get_properties
+    check_properties_request = opts.check_properties
+    run_if_applicable_request = opts.run_if_applicable
+    option_count = ((1 if get_properties_request else 0)
+                  + (1 if check_properties_request else 0)
+                  + (1 if run_if_applicable_request else 0))
+
+    if (option_count > 1):  # Only 0 (they're all optional) or 1 of these options may be specified at a time
+        print 'At most 1 of the following options may be specified: %s, %s, %s' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        os._exit(WSA_EXIT_INVALID_COMMAND_LINE)  # Make a direct exit
+
+    # Fetch the testcase properties from the testcase source code itself
+    testcase_props = getattr(__main__, TESTCASE_PROPERTIES_VARIABLE_NAME, None)
+
+    # Certain requests need the testcase properties.  Make sure they are defined.
+    if get_properties_request or check_properties_request or run_if_applicable_request:
+        if testcase_props is None:
+            print "The testcase source code does not define the %s variable" % TESTCASE_PROPERTIES_VARIABLE_NAME
+            os._exit(WSA_EXIT_MISSING_TESTCASE_PROPERTIES)  # Make a direct exit
+
+    # Handle a request to display the testcase properties
+    if get_properties_request:
+        print GET_PROPERTIES_BEGIN_MARKER
+        print "%s=\n%s" % (TESTCASE_PROPERTIES_VARIABLE_NAME, pprint.pformat(testcase_props))
+        print GET_PROPERTIES_END_MARKER
+        os._exit(WSA_EXIT_GET_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    # Handle requests that need to check the testcase properties against the required properties.
+    if check_properties_request or run_if_applicable_request:
+        # Check all simple string properties.  Some may have been specified multiple times on the command line.
+        properties_to_check = [(testcase_props, TC_CAPABILITIES, opts.required_capabilities),
+                               (testcase_props, TC_COMPONENT, opts.required_components),
+                               (testcase_props, TC_SCENARIO_TYPE, opts.required_scenario_types),
+                               (testcase_props, TC_EXECUTION_TYPE, opts.required_execution_types),
+                              ]
+
+        for property in properties_to_check:
+            # print 'checking %s' % property[1]
+            if check_testcase_requirement(property[0], property[1], property[2]) is False:
+                print "The testcase does not support any required value for the '%s' property, supplied values are " % (property[1]), (property[2])
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Doesn't meet this requirement, so exit.  Make a direct exit.
+    
+        # If a required API version was specified, check it now by making sure it is within the
+        # range defined by the testcase's minimum supported version and its maximum supported version
+        # (if defined).  First make sure its minimum supported version is <= the requirement.
+        required_version = opts.required_version
+        if required_version is not None:
+            if TC_MINIMUM_API_VERSION not in testcase_props.keys():
+                print "The testcase properties do not define the %s property" % (TC_MINIMUM_API_VERSION)
+                os._exit(WSA_EXIT_PROPERTY_NOT_DEFINED)  # Make a direct exit
+
+            available_minimum_version = testcase_props[TC_MINIMUM_API_VERSION]  # Get the value of this testcase property
+            # print "required & supported min versions: %s, %s" % (required_version, available_minimum_version)
+            # if required_minimum_version < available_minimum_version:
+            if not is_version_at_most(required_version, available_minimum_version):  # required < supported min
+                print "The testcase does not support the %s required API version; the testcase supports a minimum version of %s" % (required_version, available_minimum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If a required maximum version was specified and the testcase provides it, check it now.  This is
+        # an optional property that is not expected to be used very often.  It is intended to denote a
+        # testcase that has become obsolete at a certain API level.  Make sure the testcase's maximum
+        # supported version is >= the requirement.
+        if required_version is not None and TC_MAXIMUM_API_VERSION in testcase_props.keys():
+            available_maximum_version = testcase_props[TC_MAXIMUM_API_VERSION]  # Get the value if this testcase property
+            # print "required & supported max versions: %s, %s" % (required_maximum_version, available_maximum_version)
+            # if required_version > available_maximum_version:
+            if not is_version_at_most(available_maximum_version, required_version):  # required > supported max
+                print "The testcase does not support the %s required API version; the testcase supports a maximum version of %s" % (required_version, available_maximum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If we're only checking testcase requirements, all requirements are met and we're done!
+        # If this is a run-if-applicable request, all requirements have been met, so continue and
+        # actually execute the testcase.
+        if check_properties_request:   
+            print "The testcase meets the specified requirements"
+            os._exit(WSA_EXIT_CHECK_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    return (opts, args)
+
+
+#############################################################################
+#
+# This method provides a simple method to validate the response from an HTTP
+# request.
+#
+# @param rs - the Response object returned by one of the Session methods,
+#             such as Session.get, for example.
+# @param vm - validation map that can contain on or more of the following:
+#             status       : the expected status code from the operation
+#             content-type : the expected content type in the response
+#             required     : a list of required properties in the
+#                            response body
+#             optional     : a list of optional properties in the
+#                            response body
+#
+# An example validation map :
+#  { 'status':200,
+#    'content-type':'application/json',
+#    'required':[],
+#    'optional':[] }
+#
+# All validation map parameters are optional.  Parameters that are not
+# present in the map will not be used as part of the validation test.
+#
+# @return True is validation is successful, False otherwise
+#
+#############################################################################
+
+def validate_response(rs, vm) :
+
+    if vm is None : return True  # Nothing to validate in this case ...
+
+    if rs is None or not isinstance(rs, Response) :
+        raise ApiFatalException('Response missing or invalid', response=rs)
+
+    # Validate the status
+    if 'status' in vm and rs.status != vm[ 'status' ] :
+        raise ApiException('Invalid status ' + str(rs.status) + ' ' + str(rs.reason), response=rs)
+
+    # Validate the content type
+    content = rs.headers[ WSA_HEADER_CONTENT ] if WSA_HEADER_CONTENT in rs.headers else None
+    if WSA_HEADER_CONTENT in vm :
+        if content is None or not content.startswith(vm[ WSA_HEADER_CONTENT ]) :
+            raise ApiException('Invalid content type ' + str(content), response=rs)
+
+    if content is not None and content.startswith(WSA_CONTENT_JSON) :
+        req = vm[ 'required' ] if 'required' in vm else None
+        opt = vm[ 'optional' ] if 'optional' in vm else None
+        try :
+            validate_dictionary(rs.body, req, opt)
+        except ApiException as exception :
+            exception.response = rs
+            raise exception
+
+    return True
+
+
+
+
+# Verify the response is consistent with No Content (204)
+# @param response Response object
+def validate_no_content_response (response) :
+    print
+    print 'Validating that Response is a proper No Content (204) response'
+    if response.status != 204 :
+        print_response(response)
+        raise Exception('Failed: Expected No Content status 204, got ' + str(response.status))
+    if response.headers.get(WSA_HEADER_CONTENT) != None :
+        print_response(response)
+        raise Exception('Failed: Expected no content-type header for 204 response, got ' + str(response.headers.at(WSA_HEADER_CONTENT)))
+    if (response.body != None) and (response.body != '') and (response.body != '{}') :  # Response object returns {} for no content?
+        print_response(response)
+        raise Exception('Failed: Expected no content in body, got ' + str(response.body))
+# end validate_no_content_response
+
+#############################################################################
+#
+#############################################################################
+
+def validate_dictionary(dict, req, opt) :
+
+    if dict is None or type(dict) is not types.DictType :
+        raise ApiFatalException('Dictionary missing or invalid type')
+
+    if req is None : req = []
+    if opt is None : opt = []
+
+    if req == [] and opt == [] : return True
+
+    allKeys = set(dict.keys())
+    reqKeys = set(req)
+    result = reqKeys.difference(allKeys)
+    if len(result) > 0 :
+        raise ApiException('Missing required keys', keys=sorted(list(result)))
+
+    optKeys = set(opt)
+    result = allKeys.difference(reqKeys).difference(optKeys)
+    if len(result) > 0 :
+        raise ApiException('Extraneous keys found', keys=sorted(list(result)))
+
+    return True
+
+
+#############################################################################
+# Return a list of all ensembles, after first validating the response
+#############################################################################
+
+def list_ensembles(session) :
+    ensembles = None
+    response = session.get(WSA_URI_ENSEMBLES)
+    validate_response(response, WSA_LIST_ENSEMBLES_VALIDATE)
+    for ensemble in response.body[ 'ensembles' ] :
+        validate_dictionary(ensemble, WSA_LIST_ENSEMBLE_REQUIRED, [])
+    return response.body[ 'ensembles' ]
+
+
+#############################################################################
+# Update the ensemble properties 
+# ensemble_uri : the uri of the ensemble to be updated (str)
+# request_body : request body containing the fields to update (dict)
+#############################################################################
+
+def update_ensemble(session, ensemble_uri, request_body):
+    response = None
+    print 'ensemble update body: ' + json.dumps(request_body)
+    response = session.post(ensemble_uri, json.dumps(request_body))
+    print 'Ensemble update response status: ' + str(response.status)
+    return response
+
+
+#############################################################################
+# Return information about the ensemble on the system
+#############################################################################
+
+def get_ensemble_info(session) :
+    print '\nGet the ensemble information'
+    ensembles = list_ensembles(session)
+    if len(ensembles) == 0 :
+        raise Exception('No ensemble defined on system')
+    ensemble_info = ensembles[0]
+    ensemble_uri = ensemble_info['object-uri']
+    print 'Ensemble uri is [' + ensemble_uri + ']'
+    return ensemble_uri, ensemble_info
+
+
+#############################################################################
+# Return all the properties of the specified ensemble
+#############################################################################
+
+def get_ensemble_properties(session, ensemble) :
+    response = session.get(ensemble[ 'object-uri' ])
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return all the properties of the ensemble identified by its URI
+#############################################################################
+
+def get_ensemble_properties_by_uri(session, ensemble_uri) :
+    response = session.get(ensemble_uri)
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return a list of all cpcs, afer first validating the response
+#############################################################################
+
+def list_cpcs(session) :
+    cpcs = None
+    response = session.get(WSA_URI_CPCS)
+    if response.status != 200:
+        raise ApiException("ERROR: status=" + response.status + ", uri=" + WSA_URI_CPCS)
+    strCPCs = str(response)
+    cpcCount = strCPCs.count('object-uri')
+    if cpcCount == 0 :
+        raise ApiException('No cpcs defined on system')
+    validate_response(response, WSA_LIST_CPCS_VALIDATE)
+    for cpc in response.body[ 'cpcs' ] :
+        validate_dictionary(cpc, WSA_LIST_CPC_REQUIRED, [])
+    cpcs = response.body['cpcs']
+    return cpcs
+    
+
+#############################################################################
+# Return either the default CPC or the first cpc found in the operating state
+#############################################################################
+
+def get_operating_cpc(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    # # See how many cpcs we have
+    strCPCs = str(cpcs)
+    n = strCPCs.count('object-uri')
+    cpc_name = ''
+    # # See if we have a default CPC name to find
+    if DEFAULT_CPC_NAME != '' :
+        # # Find the default cpc
+            for i in range(0, n):
+                if (cpcs[i]['name'] == DEFAULT_CPC_NAME) & (cpcs[i]['status'] == 'operating') :
+                    cpc_uri = cpcs[i]['object-uri']
+                    cpc_name = cpcs[i]['name']
+                    print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                    break
+    # # If default CPC is not found and operating, look for the first operating CPC
+    if cpc_name == '' :
+        # # Find an operating cpc
+        for i in range(0, n):
+            if (cpcs[i]['status'] == 'operating') :
+                cpc_uri = cpcs[i]['object-uri']
+                cpc_name = cpcs[i]['name']
+                print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                break
+    # # Make sure we found an operating cpc
+    if cpc_name == '' :
+        raise Exception('No operating cpcs defined on system')
+    else :
+        # cpc_uri = cpcs[0]['object-uri']
+        return cpc_uri
+    
+    
+#############################################################################
+# Return either the default CPC or the first cpc found
+#############################################################################
+
+def get_cpc_new(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    targetCpc = None
+    for cpc in cpcs :
+        if cpc['name'] == APA_TESTENV_CPC_UNDER_TEST :
+            targetCpc = cpc
+            break
+    if targetCpc is None :
+        raise ApiFatalException("Unable to find a required CPC, exiting")    
+    cpc_uri = targetCpc['object-uri']
+    return cpc_uri
+
+
+##########################################################################################
+# Return either the default virtualization host or the first found in the operating state
+##########################################################################################
+
+def get_operating_virtualization_host(session, virtualization_hosts) :
+    print '\nGet the operating virtualization host'
+    virtualization_host_name = None
+    for virtualization_host in virtualization_hosts :
+        if virtualization_host[ 'name' ] == DEFAULT_VIRTUALIZATION_HOST_NAME :
+            if  virtualization_host[ 'status' ] == 'operating' :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    if virtualization_host_name is None :
+        for virtualization_host in virtualization_hosts :
+            if (virtualization_host[ 'status' ] == 'operating') & (virtualization_host[ 'type' ] == 'zvm')  :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    # # Make sure we found an operating virtualization host
+    if virtualization_host_name is None :
+        raise ApiFatalException('No zvm virtualization host present in the Ensemble or is not in the right state to perform this test')
+    else :
+        return virtualization_host
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble(session, ensemble_info, query=None) :
+    return list_virtualization_hosts_by_ensemble_uri(session, ensemble_info['object-uri'], query)
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=None) :
+    response = None
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    if query is None :
+        response = session.get(node_uri + '/virtualization-hosts')
+    else :
+        response = session.get(node_uri + '/virtualization-hosts?' + query)
+    validate_response(response, WSA_LIST_VIRT_HOSTS_VALIDATE)
+    for host in response.body[ 'virtualization-hosts' ] :
+        validate_dictionary(host, WSA_LIST_VIRT_HOST_REQUIRED, [])
+    return response.body[ 'virtualization-hosts' ]
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for an arbitrary
+# (or specific, if virtualization_host_name is specified) virtualization
+# host of the specified type, managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host(session, virtualization_host_type, ensemble_uri=None, virtualization_host_name=None):
+    print '\nSearching the ensemble for a virtualization_host of type ' + virtualization_host_type
+    typefilter = 'type=%s' % (virtualization_host_type)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+    
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, 'name=ZBX51.*&'+typefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    if len(nodes) == 0 :
+        raise Exception('No suitable node (name=' + WSA_DEFAULT_ZBX_NAME + ') is defined in ensemble ' + ensemble_name)
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + typefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_type + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    # Set the virtualization host name to search for, if any
+    vh_name = None
+    if virtualization_host_name is None:
+        # If we're looking for a zvm virtualization host on the R32 ensemble, restrict Test usage to a specific virtualization host
+        if virtualization_host_type == 'zvm':
+            if ensemble_name == ENSEMBLE_NAME_R32:
+                vh_name = PREFERRED_ZVM_VIRTUALIZATION_HOST_R32
+    else:
+        vh_name = virtualization_host_name
+
+    virtualization_host_info = None  # Assume no appropriate virtualization host will be found
+    if vh_name is None:
+        virtualization_host_info = virtualization_hosts[0]  # Use the first one (arbitrary choice)
+    else:
+        for virtualization_host in virtualization_hosts:  # Iterate over all vh info objects that match the desired vh type
+            if virtualization_host['name'] == vh_name:  # Found it
+                virtualization_host_info = virtualization_host
+        if virtualization_host_info is None:
+            raise Exception('No ' + virtualization_host_type + ' virtualization host with name ' + vh_name + ' is defined in ensemble ' + ensemble_name)
+
+    virtualization_host_uri = virtualization_host_info['object-uri']
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for a specified
+# virtualization host managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host_by_name(session, virtualization_host_name, ensemble_uri=None):
+    print '\nSearching the ensemble for a virtualization_host of name ' + virtualization_host_name
+    namefilter = 'name=%s' % (virtualization_host_name)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=namefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + namefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_name + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    virtualization_host_info = virtualization_hosts[0]
+    virtualization_host_uri = virtualization_host_info['object-uri']
+
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI of a virtual server object with the specified name owned
+# by the specified virtualization host.  If return_response is True, then
+# the response object is always returned; otherwise, the URI is returned
+# or an exception is raised.
+#############################################################################
+
+def find_virtual_server_in_virtualization_host(session, virtualization_host_uri, virtual_server_name, return_response=False) :
+    # Find the VS within the specified VH
+    response = session.get(virtualization_host_uri + "/virtual-servers?name=" + virtual_server_name)
+    if response.status != 200:
+        msg = "An error occurred fetching virtual server information for the virtualization host"
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    virtual_servers = response.body["virtual-servers"]
+    if len(virtual_servers) == 0 :
+        msg = "The virtualization host has no virtual server with name " + virtual_server_name
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    if return_response :
+        return response
+    else :
+        return virtual_servers[0]["object-uri"]
+
+
+#############################################################################
+# Startup method to create session and logon ...
+# Connection parameters (host, port, user, and pwd) should not be overridden
+# by test scripts unless there is an explicit need (eg log in under different
+# users to verify access permission)
+# @param host - IP address of the target HMC (str)
+# @param port - Port number to connection on the target HMC (int)
+# @param user - Logon userid to use on the target HMC (str)
+# @param pwd  - Logon password to use on the target HMC(str)
+# @param additional_options - any additional command line option definitions.
+#               See parse_standard_options() and the Session class for more details.
+#               (list of Option objects created via make_option())
+# @param additional_arguments_usage_info - Usage information for any additional
+#               command line arguments.  See parse_standard_options() and the
+#               Session class for more details. (str)
+# @param amq-client - ActiveMQ client to use for notification messages
+# @param amq-socket-type - Type of socket to use for ActiveMQ messages;
+#               either ssl or non-ssl
+#
+# Note that the Session __init__ method calls parse_standard_options(), which 
+# uses os._exit(rc) in some cases rather than the more common sys.exit(rc).
+# See the prolog of parse_standard_options for more details.
+#############################################################################
+
+#############################################################################
+# Find the object with a given name from a list of objects
+#############################################################################
+def find_object_by_name(session, object_list, object_name) :
+    result = None
+    for obj in object_list :
+        if type(obj['name']) is unicode :
+            obj_name = obj['name'].encode('utf-8')
+        if (obj_name == object_name) :
+            result = obj
+    return result
+
+
+def session_startup(host=None, port=None, user=None, pwd=None, verbose=False, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+    session = Session(host, port, user, pwd, additional_options, additional_arguments_usage_info, amq_client, amq_socket_type)
+
+    # Now open the session by establishing an HTTP connection to the target HMC
+    if verbose :
+        print 'Connecting to', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+    session.open()
+    if verbose :
+        print 'Session ID: \t%s' % session.session()
+
+    return session
+
+
+#############################################################################
+# Determine if the API version being tested is at least as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# added or changed in an incompatible fashion after the initial API release.
+# The testcase can use this function in order to know what behavior to expect
+# from the API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_least(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    # return (api_version >= version_to_check)  #??? Need to do a real implementation of this that can handle all valid version formats!  (For example, need to be able to compare "1.2" and "1.12")
+    return is_version_at_least(version_to_check, api_version)
+
+
+# See is_api_version_at_least() above for description
+def is_version_at_least(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_least: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version >= version_to_check)
+
+    # Iterate over the numeric parts of the input version number and compare them to the
+    # corresponding parts of the session's API version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(version_to_check_parts)):
+        version_to_check_part = int(version_to_check_parts[i])
+        if len(api_version_parts) >= i + 1:
+            api_version_part = int(api_version_parts[i])
+        else:  # Not enough parts in api_version; supply a 0
+            api_version_part = 0
+        if version_to_check_part < api_version_part:
+            return True
+        elif version_to_check_part > api_version_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the input version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # version_to_check has fewer parts, which means that it cannot be greater than
+    # api_version.  Thus it must be <=, so we return True.
+    return True
+
+
+#############################################################################
+# Determine if the API version being tested is exactly the same as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.
+# 
+# Returns:
+#    True if it is; otherwise, False.
+#############################################################################
+
+def is_api_version_exactly(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    return (api_version == version_to_check)
+
+
+#############################################################################
+# Determine if the API version being tested is at most as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# removed or changed in an incompatible fashion at some point.  The testcase
+# can use this function in order to know what behavior to expect from the
+# API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_most(session, version_to_check):
+    api_version = api_effective_version(session)
+    return is_version_at_most(version_to_check, api_version)
+
+
+# See is_api_version_at_most() above for description
+def is_version_at_most(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_most: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version <= version_to_check)
+
+    # Iterate over the numeric parts of the session's API version number and compare them to the
+    # corresponding parts of the input version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(api_version_parts)):
+        api_version_part = int(api_version_parts[i])
+        if len(version_to_check_parts) >= i + 1:
+            version_to_check_part = int(version_to_check_parts[i])
+        else:  # Not enough parts in version_to_check; supply a 0
+            version_to_check_part = 0
+        if api_version_part < version_to_check_part:
+            return True
+        elif api_version_part > version_to_check_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the API version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # api_version has fewer parts, which means that it cannot be greater than
+    # version_to_check.  Thus it must be <=, so we return True.
+    return True
+
+# Return the "effective" version (the version reported by the HMC itself, or the override
+# value from the command line (if specified).
+def api_effective_version(session):
+    return session.api_version() if session.api_version_override() is None else session.api_version_override()
+
+#############################################################################
+# Determine if the specified WS API feature is available to the current session.
+# 
+# Returns:
+#    True if the feature is available; otherwise, False.
+#############################################################################
+
+def is_feature_available(session, feature):
+    features = session.api_features()
+    return (features is not None and feature in features)
+
+
+#############################################################################
+# Check the supplied testcase properties to see if they meet at least one of
+# the required values for the specified property.  This is effectively a
+# logical OR of the required property values.
+# 
+# Returns:
+#    True if the testcase supports at least one of the required property
+#    values; otherwise, False.
+#############################################################################
+
+def check_testcase_requirement(testcase_properties, property_name, required_properties):
+    if required_properties is None:
+        required_found = True
+    else:
+        # Check required property; these are OR'd together
+        required_found = False  # Something is required; assume we don't have it
+
+        if property_name in testcase_properties.keys():
+            available = testcase_properties[property_name]
+            for r in required_properties :
+                # Many requirement values are accepted in upper or lower case, so 
+                # convert everything to lowercase before looking for a match.
+                # We currently support testcase properties whose values are of
+                # type string or list.
+                # if r.upper() in available:
+                if type(available) is types.StringType:  # A string
+                    if r.lower() == available.lower():
+                        required_found = True
+                        break
+                else:  # Assume a list
+                    if r.lower() in make_lowercase_copy(available):
+                        required_found = True
+                        break
+        else:
+            print "The testcase properties do not define the %s property" % (property_name)
+
+    return required_found
+
+
+#############################################################################
+# Exit test code cleanly ...
+# By default, all "temporary" objects are deleted, and any "admin sessions"
+# and "temporary sessions" are shutdown after the specified session is shutdown.
+#############################################################################
+
+def session_shutdown(session, verbose=True, delete_temporary_objects=True, delete_admin_sessions=True, delete_temporary_sessions=True) :
+    if session is not None :
+        if verbose :
+            print 'Disconnecting from', session.hmc_name(), 'at', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+        try :
+            session.close()
+        except (ApiException, ApiFatalException) as exception :
+            print
+            print 'Exception raised during shutdown ...'
+            print exception
+            print
+
+
+    # Delete temporary sessions first, in case one is for a temporary user that we're
+    # about to delete in delete_all_temporary_objects().
+    if delete_temporary_sessions:
+        delete_all_temporary_sessions()
+
+    if delete_temporary_objects:
+        delete_all_temporary_objects()
+
+    if delete_admin_sessions:
+        delete_all_admin_sessions()
+
+
+#############################################################################
+# This function returns True if value is a number, False otherwise.
+#############################################################################
+
+def isNumeric(value) :
+    try :
+        float(value)
+    except (ValueError) :
+        return False
+    return True
+
+
+#############################################################################
+#
+# This function prints out data as formatted columns.
+#
+# Formatting is simple : Strings will be left-justified
+#                        Numbers will be right-justified
+#
+# Input :
+#
+#   The keys parameter is a list of keys whose values should be printed
+#   The data parameter is a list of dictionaries
+#
+# No error checking is done currently ...
+#
+# Example :
+#
+#    keys = [ 'name', 'status', 'type' ]
+#    data = [ { 'name':'abc',     'type':'foo',    'status':'operating',     'count':1    },
+#             { 'name':'abcde',   'type':'bar',    'status':'not_operating', 'count':10   },
+#             { 'name':'ab',      'type':'foobar', 'status':'status_check',  'count':100  },
+#             { 'name':'abcdefg', 'type':'fubar',  'status':'starting',      'count':1000 } ]
+#
+#    prettyPrint( data, keys ) will print ...
+#
+#       abc     operating     foo
+#       abcde   not_operating bar
+#       ab      status_check  foobar
+#       abcdefg starting      fubar
+#
+#############################################################################
+
+def prettyPrint(data, keys) :
+    if data is None or len(data) == 0 : return
+    if keys is None or len(keys) == 0 : return
+    width = {}
+    for key in keys :
+        width[ key ] = max([ len(str(row[ key ])) for row in data ])
+    for row in data :
+        for key in keys :
+            if isNumeric(row[ key ]) :
+                print str(row[ key ]).rjust(width[ key ]),
+            else :
+                print str(row[ key ]).ljust(width[ key ]),
+        print
+
+
+# Print a Response object with formatted headers and body
+# @param response - API response (Response)
+def print_response(response, sort_body=True) :
+    if response is None or response.__class__ is not Response :
+        raise ApiFatalException('response is missing or invalid type')
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(response.headers, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    print json.dumps(response.body, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    if 'stack' in response.body:
+        print 'stack (again, but in a more programmer-friendly format):'
+        print response.body['stack']
+    return
+# end print_response
+
+
+# Print information in a formatted fashion from a response object and an optional response body.
+# This is useful for streamed responses; see return_full_response in wsautils.py and the 
+# read_response_streamed() function.
+def print_response_info(response, response_body=None) :
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(dict (response.getheaders()), indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    if response_body is None:
+        print json.dumps(response.read(), indent=1, separators=(',', ':'))
+    else:
+        body = json.loads(response_body)
+        print json.dumps(body, indent=1, separators=(',', ':'))
+    return
+   # end print_response_info
+
+
+# Print a line(s) between separator lines so that they stand out among the testcase output.
+# Optional text can be included in the separator line that precedes the lines and the one 
+# that follows the lines.  The length and composition of the separator line can by customized
+# with input parameters.
+def print_between_separator_lines(lines, header_text=None, footer_text=None, length=90, box_char="=", blank_lines=1):
+    if header_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(header_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, header_text)  # Leading box chars and header text
+
+    header_line = "%s%s%s" % ("\n"*blank_lines, line, box_char * (length - len(line)))  # Add the blank lines and trailing box chars
+    print header_line
+
+    # Write all of the input lines
+    for line in lines:
+        print line
+    
+    if footer_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(footer_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, footer_text)  # Leading box chars and footer text
+
+    footer_line = "%s%s%s" % (line, box_char * (length - len(line)), "\n"*blank_lines)  # Add the trailing box chars and blank lines
+    print footer_line
+
+
+#############################################################################
+#
+# Filter a list of dictionaries based on keys and values
+#
+# This function is a "generator", meaning its output should be wrapped
+# in a list in order to iterate over the results.
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'foo'.
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'foo'
+# print list( filter_dictionary( data, func ) )
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'bar' with the value of 'bar2'
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'bar' and v == 'bar2'
+# print list( filter_dictionary( data, func ) )
+#
+#############################################################################
+
+def filter_list(data, predicate=lambda k, v: True) :
+    for d in data:
+         for k, v in d.items():
+               if predicate(k, v):
+                    yield d
+
+#########################################################################
+# Determine the Output body, response, and reason code
+#
+# NOTE : The Response object has been updated to raise an
+# ApiFatalException if the HTTP headers indicate a content type of json,
+# but the response body fails to parse with json.loads.
+# This negates the need for 'determine' to check for a malformed body
+# with a subsequent return code of '2'.
+#########################################################################
+
+def determine(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code and reason == reason_code :
+        return(0)
+    else :
+        return(1)
+    
+# added by lv start
+def determine_with_raise_exception(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code :
+        if reason == reason_code :
+            return (0)
+        else: 
+            raise ApiException('expected reason code' + str(reason_code) + ' not seen')
+    else :
+        raise ApiException('expected status code' + str(status_code) + ' not seen')
+# added by lv end
+
+
+#########################################################################
+# Get the current time, formatted
+#########################################################################
+def get_time_stamp() :
+    return time.strftime("%Y%m%d %H:%M:%S %z", time.localtime())
+# end get_time_stamp
+
+
+#########################################################################
+# Get the fully-qualified filename of the current testcase
+#########################################################################
+
+def get_testcase_full_filename ():
+    return sys.argv[0]
+
+
+#########################################################################
+# Get the testcase ID for the current testcase, based on its filename,
+# or for a specified filename.
+# The expected format for testcase filenames is
+#           <comp>_<id>.py
+# where <comp> is the component (e.g., svm, vsm, lpar) and <id> is the
+# testcase ID number.  For example, vsm_3588.py
+#########################################################################
+
+def get_testcase_id (filename=None):
+    name = get_testcase_full_filename() if filename == None else filename
+    basename = os.path.basename(name)  # Just the filename, no path
+    (name, ext) = os.path.splitext(basename)  # Separate name from extension (e..g, svm_3588)
+    parts = string.split(name, '_')  # Split at underscore (e.g., 'svm', '3588')
+    id = parts[len(parts) - 1]  # ID is the last one of the parts
+    return id
+
+
+
+
+def get_files_from_se(remote_files, local_zip_file):
+    return
+# Get the name of the user's notification topic for a specified topic type
+#
+# Inputs:
+# - requested_topic_type: the type of topic to find.  Must be a valid topic type as
+#                         returned by the Get Notification Topics operation:
+#                         'object', 'job', 'audit' or 'security'.
+#
+# Returns: the name of the topic, or None if there is no such topic for the user (e.g.,
+#          the user is not authorized to connect to it).
+#
+# Any failure is reported via an exception
+def get_notification_topic(session, requested_topic_type):
+    """Get the name of the user's notification topic for the specified topic type"""
+
+    # Make sure the targetted HMC supports the request required to fetch the notification topics
+    if not is_api_version_at_least(session, TC_API_VERSION_ZSPHINX_GA1):
+        raise ApiFatalException('The targetted HMC (effective version %s) does not support audit or security notifications; must be version %s or later' % (api_effective_version(session), TC_API_VERSION_ZSPHINX_GA1))
+
+    valid_topic_types = ['object', 'job', 'audit', 'security']
+    if requested_topic_type not in valid_topic_types:
+        raise ApiException("get_notification_topic(): Invalid topic type: " + requested_topic_type)
+    true_topic_type = requested_topic_type + "-notification"  # The name returned by Get Notification Topics
+
+    # Issue a Get Notification Topics request to get all of the user's authorized topics
+    uri = "/api/sessions/operations/get-notification-topics"
+    response = session.get(uri)
+    if response.status != 200:
+        raise ApiException("Get Notification Topics operation failed", response)
+    topics = response.body['topics']
+
+    if len(topics) == 0:  # No topics!  Should never happen, per the doc
+        print 'User is not authorized for any notification topics - this should never happen!'
+        return None
+
+    # Iterate over the user's authorized topics looking for the specified one
+    for topic in topics:
+        topic_type = topic['topic-type']
+        topic_name = topic['topic-name']
+#       print 'Topic type: %s, topic_name: %s' % (topic_type, topic_name)
+        if topic_type == true_topic_type:  # Found it
+            return topic_name
+
+    # Not found
+    return None
+
+
+# Issue the provided request and return the response along with a string containing 
+# the formatted request and response.  This formatted version is suitable for inclusion
+# in the HMC Web Services API external customer publication.  It contains:
+# - the caption text for the request example
+# - the HTTP method and full request URI
+# - certain request headers
+# - the request body, if any, alphabetized, nicely formatted and indented
+# - the caption text for the response example
+# - the HTTP status code and its meaning (e.g., "201 (Created)")
+# - certain response headers
+# - the response body, if any, alphabetized, nicely formatted and indented
+#
+# The operation_name should be the full name by which the operation is known in the external book
+# The URI may contain query parms.  This is handy for limiting the size of the response body
+# for List <class> operations.  It is OK to publish these, but not necessary.
+# The request_body is a dictionary (and is optional).
+def capture_example_for_book(session, operation_name, uri, method="get", request_body=None):
+    indent_amount = 3
+    request_headers_to_publish_get = [WSA_HEADER_RQ_SESSION]
+    request_headers_to_publish_post = [WSA_HEADER_RQ_SESSION,
+                                       WSA_HEADER_CONTENT_TYPE,
+                                       WSA_HEADER_CONTENT_LENGTH]
+    request_headers_to_publish_delete = [WSA_HEADER_RQ_SESSION]
+    response_headers_to_publish = [WSA_HEADER_RESP_SERVER,
+                                   WSA_HEADER_RESP_TRANSFER_ENCODING,  # "chunked" is of interest
+                                   WSA_HEADER_RESP_LOCATION,
+                                   WSA_HEADER_RESP_CACHE_CONTROL,
+                                   WSA_HEADER_RESP_DATE,
+                                   WSA_HEADER_CONTENT_TYPE,
+                                   WSA_HEADER_CONTENT_LENGTH]
+
+    if method == 'get':
+        request_headers_to_publish = request_headers_to_publish_get
+        response = session.get(uri)
+    elif method == 'post':
+        request_headers_to_publish = request_headers_to_publish_post
+        response = session.post(uri, json.dumps(request_body))
+    elif method == 'delete':
+        request_headers_to_publish = request_headers_to_publish_delete
+        response = session.delete(uri)
+
+    request_headers = response.request.headers
+    response_headers = response.headers
+
+    # First format the request URI, filtered headers and body
+    formatted_request_response = "\n\n%s: Request\n\n" % operation_name
+    formatted_request_response += "\n%s %s %s" % (method.upper(), uri, "HTTP/1.1")
+
+    for header_name in request_headers_to_publish:
+        formatted_request_response += "\n%s: %s" % (header_name, request_headers[header_name])
+
+    if request_body != None:
+        formatted_request_body = json.dumps(request_body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+        formatted_request_response += "\n" + formatted_request_body
+
+    #------- end request, begin response --------
+    # Noe format the filtered response headers and the response body
+    formatted_request_response += "\n\n%s\n\n%s: Response\n\n" % (20 * '-', operation_name)
+    formatted_request_response += "\n%s %s" % (response.status, response.reason)
+
+    for header_name in response_headers_to_publish:
+        if header_name in response_headers.keys():
+            formatted_request_response += "\n%s: %s" % (header_name, response_headers[header_name])
+
+    if response.status == 204 or response.body == None:
+        formatted_response_body = "\n<No response body>"
+    else:  # There is a response body; make it look pretty
+        formatted_response_body = json.dumps(response.body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+    formatted_request_response += "\n" + formatted_response_body
+
+    # Formatting is complete
+
+#   # Make sure the request succeeded; assume any 2xx indicates success
+#   if response.status < 200 or response.status > 299:
+#       print_response(response)
+#       raise ApiException("The request appears to have failed.  URI '%s' returned HTTP status code %d (%s)" % (uri, response.status, response.reason))
+
+    # Return the complete Response object and the formatted request/response string
+    return response, formatted_request_response
+
+
+#########################################################################
+#                  "Temporary object" support
+#########################################################################
+
+# Add a temporary object to the registry.  All objects in the registry will
+# be deleted by default when the session is shutdown.  The object must be
+# of a type that is supported by the "temporary object" support.
+# See the temporary_object_types_deletion_order and temporary_object_types_info
+# constants in wsaconst.py.
+def register_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        if is_supported_temporary_object_type(temporary_object_uri):
+            wsaglobals.global_temporary_objects_list.append(temporary_object_uri)
+        else:
+            raise ApiFatalException('URI "%s" does not designate an object of a type that is supported by the "temporary object" support in wsautils' % temporary_object_uri)
+
+
+# Remove a temporary object from the registry
+def deregister_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        wsaglobals.global_temporary_objects_list.remove(temporary_object_uri)
+
+
+# Gets a copy of the list of all registered temporary objects.
+# Use register_temporary_object() and deregister_temporary_object()
+# to update this list if needed.
+def get_temporary_objects_list():
+    return list(wsaglobals.global_temporary_objects_list)  # Return a copy
+
+
+# Determine if the specified URI designates an object of a type that is supported
+# by the "temporary object" support.
+def is_supported_temporary_object_type(uri):
+    if uri is None or not isinstance(uri, types.StringTypes):  # Not a string (likely to be a Response object from a failed request...)
+        return False
+    
+    for info_entry in temporary_object_types_info.values():
+        uri_prefix = info_entry[KEY_URI_PREFIX]
+        if uri.startswith(uri_prefix):  # It's a supported type
+            return True
+    return False
+
+
+# Delete all temporary objects in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_objects():
+    temporary_objects_list = get_temporary_objects_list()  # Get a copy to iterate over; the real list gets updated
+    if temporary_objects_list is not None and len(temporary_objects_list) > 0:  # There are temporary objects to be deleted
+        print '\nTemporary objects to delete: %d' % len(temporary_objects_list)
+
+        # Iterate over all supported object types and delete all instances of each type,
+        # then move on to the next type
+        for object_type in temporary_object_types_deletion_order:  # Go in a certain order, since it sometimes matters
+            info_entry = temporary_object_types_info[object_type]  # Get handling info about the current object type
+            uri_prefix = info_entry[KEY_URI_PREFIX]
+#           print 'Looking for temporary objects with a URI prefix of "%s"' % uri_prefix
+            
+            # Iterate over all temporary objects in the registry, searching for those
+            # of the type we're currently handling.  Delete each as it is found and 
+            # remove it from the registry.
+            for uri in temporary_objects_list:
+                if uri is not None and uri.startswith(uri_prefix):  # Its type matches the type we're handling now
+                    try:
+                        admin_user = info_entry[KEY_ADMIN_USERID]
+
+                        admin_session = get_admin_session(admin_user)
+
+                        print 'Using %s to delete temporary object: %s' % (admin_user, uri)
+                        response = admin_session.delete(uri)
+                        if response.status != 204:
+                            print '\nError deleting temporary object: %s\n%s' % (uri, response)
+
+                        deregister_temporary_object(uri)  # Remove it from the list of temporary objects, since we've deleted it
+#                       print 'There are %d temporary objects left to delete' % len(wsaglobals.global_temporary_objects_list)
+                    except:
+                        print 'Caught exception!!'
+                        traceback.print_exc()
+                        print 'Continuing with any remaining temporary objects...'
+        print
+
+    # Get a current copy of the list; check to see if it's empty (it should be)
+    temporary_objects_list = get_temporary_objects_list()
+    if len(temporary_objects_list) > 0:  # Hmmmm, must have had an error trying to delete something; tell the user
+        print '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
+        print 'Not all temporary objects were deleted.  There are still %d temporary objects in the registry.' % len(temporary_objects_list)
+        print '\n%s\n' % temporary_objects_list
+        print '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n'
+
+
+# Get a Session authenticated as the specified userid.  This method is intended for use when
+# a priviledged (admin-type) user is required for performing scenario setup in the beginning
+# of a testcase (e.g., creating objects, setting properties)and at the end when that setup is
+# being undone (e.g., deleting temporary objects, resetting properties back to original values).
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase
+# exit.  There are constants for the standard system-defined  userids (e.g., 
+# ACCCES_ADMINISTRATOR, ENSEMBLE_ADMINISTRATOR) in wsaconst.py.
+def get_admin_session(admin_userid):
+    if admin_userid in wsaglobals.global_admin_sessions:
+        admin_session = wsaglobals.global_admin_sessions[admin_userid]
+#       print 'fetched cached session: %s' % admin_session
+    else:
+        admin_session = session_startup(user=admin_userid, additional_options=wsaglobals.global_saved_additional_options)
+        wsaglobals.global_admin_sessions.update({admin_userid : admin_session})
+#       print 'created and cached new session: %s' % admin_session
+
+#   print 'There are %d admin sessions' % len(wsaglobals.global_admin_sessions)
+#   print 'Returning admin session for admin user %s: %s' % (admin_userid, admin_session)
+    return admin_session
+
+
+# Get a Session object authenticated as the system-defined user that is appropriate for performing
+# administrative operations relative to the specified URI.  If no specific administrator has been
+# identified in the uri_admin_info map, then a session authenticated as PEDEBUG is returned.
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase exit.
+def get_admin_session_for_uri(uri):
+    admin_session = None
+    # See if the specified URI has an associated administrator userid
+    for uri_prefix in uri_admin_info:
+        if uri.startswith(uri_prefix):
+            admin_session = get_admin_session(uri_admin_info[uri_prefix])
+    if admin_session == None:
+        admin_session = get_admin_session(PEDEBUG)
+    return admin_session
+
+
+# Delete all (cached) admin sessions created by get_admin_session().
+# This method is intended to be called during session shutdown immediately before testcase exit.
+def delete_all_admin_sessions():
+    admin_sessions = dict(wsaglobals.global_admin_sessions)  # Make a copy to iterate over; the real list gets updated
+    if admin_sessions is not None and len(admin_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nAdmin sessions to shutdown: %d' % len(admin_sessions)
+        for admin_user_name in admin_sessions.keys():
+            try:
+                admin_session = admin_sessions[admin_user_name]
+                print 'Shutting down session for admin user: %s' % admin_user_name
+                # Shutdown this admin session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(admin_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)  # Delete just the session, and nothing else
+                del wsaglobals.global_admin_sessions[admin_user_name]  # Remove it from the list of admin sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining admin sessions...'
+
+#   print 'There are now %d admin sessions' % len(wsaglobals.global_admin_sessions)
+
+
+# Delete all temporary sessions in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_sessions():
+    temporary_sessions = get_temporary_sessions()  # Make a copy to iterate over; the real list gets updated
+    if temporary_sessions is not None and len(temporary_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nTemporary sessions to shutdown: %d' % len(temporary_sessions)
+        for temporary_session in temporary_sessions:
+            try:
+                print 'Shutting down temporary session for user: %s' % temporary_session.userid()
+                # Shutdown this temporary session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(temporary_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)
+                wsaglobals.global_temporary_sessions.remove(temporary_session)  # Remove it from the list of temporary sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining temporary sessions...'
+
+
+
+# Gets a copy of the list of all registered temporary sessions.
+def get_temporary_sessions():
+    return list(wsaglobals.global_temporary_sessions)  # Return a copy
+
+def start_receiving_messages(session):
+    session.start_receiving_messages()
+    
+def stop_receiving_messages(session):
+    session.stop_receiving_messages()
+    msgs = session.get_received_messages()
+    print msgs
+    return msgs
+
+def create_python_list(item):
+    return [item]
+
+def create_python_dict(prop, value):
+    return {prop:value}
+
+"""
+Generic function that finds an object of type ObjectType by its attribute.    
+The function looks for a objectToFind which is a string type by it's attribute.
+Params: Field Name refers to properties like name, status etc
+        objectType refers to objects like cpcs, groups, members etc
+        FielddNameValue is the string that is searched for in the listOfDictionaries 
+"""
+def verify_object_in_list_by_attribute(listOfDictionaries, fieldNameValue, objectType, fieldName):
+    verifyIn = False
+    for myObject in listOfDictionaries.body[objectType]:
+        if myObject[fieldName] == fieldNameValue:
+            verifyIn = True
+            break
+    return verifyIn
+
+def get_partition_list(session, cpc):
+    response = session.get(cpc, '/partitions')
+    for partition in response.body['partitions']:
+        print partition['name']
+    return response.body['partitions']
+    
diff --git a/build/lib/partitionengine/Console.py b/build/lib/partitionengine/Console.py
new file mode 100644
index 0000000..912aeca
--- /dev/null
+++ b/build/lib/partitionengine/Console.py
@@ -0,0 +1,322 @@
+from getpass import *
+
+#from babel.messages.catalog import Catalog
+
+from CreateTemplate import *
+from CreateTemplatePartition import *
+from utils.wsautils import *
+import ConfigParser
+
+
+session = None
+
+
+CONFIG_FILE=".saved-settings"
+config = ConfigParser.RawConfigParser()
+
+
+def print_helper(print_string=None, operationFailed=False, exception=None):
+    string_out = ''
+    if (operationFailed):
+        string_out += ("\n" + "*"*100)
+        string_out += ("\n**********************************Operation Failed**************************************************")
+        
+    else:
+        string_out += ("\n" + "*"*100)
+    string_out += ("\n" + print_string)
+    string_out += ("\n" + "*"*100)
+    print string_out
+    logging.debug(string_out)
+    if not (exception == None):
+        logging.debug("Failure Reason:")
+        logging.debug(exception)
+        exc_type, exc_value, exc_traceback = sys.exc_info()
+        traceback_details = {
+                         'filename': exc_traceback.tb_frame.f_code.co_filename,
+                         'lineno'  : exc_traceback.tb_lineno,
+                         'name'    : exc_traceback.tb_frame.f_code.co_name,
+                         'type'    : exc_type.__name__,
+                         'message' : exc_value.message, # or see traceback._some_str()
+                        }
+        del(exc_type, exc_value, exc_traceback)
+        logging.debug(traceback.format_exc())
+        
+    return
+        
+
+
+
+
+
+finalSelectedOption = 0
+def option_choser(queryString='Choose from Index',option_title='', indexLength=0,chosenOption = 0):
+    logging.info('option_choser method invoked') 
+    if chosenOption < 1 or chosenOption > indexLength:
+        try:
+            chosenOption = int(user_input('\n'+queryString, 'OPTIONS', option_title))#raw_input('\n' + queryString.ljust(30) + ':'))         
+        except:
+            print("Invalid Value!!! ")
+        option_choser(queryString,option_title,indexLength,chosenOption)
+    else:
+        global finalSelectedOption
+        finalSelectedOption = chosenOption   
+    logging.debug("chosen option: " + str(chosenOption))
+    return finalSelectedOption
+
+def createPartitionIteratively(temp_name='', no_of_partitions=0, cpc_uri=''):
+    logging.info('-> createPartitionIteratively for the templatename ' + temp_name + " number of Partitions: " + str(no_of_partitions) + " CPC URI: " + cpc_uri)
+    partionList=dict();
+    for num in range(0, no_of_partitions):
+        print_helper("Creating Partition " + str(num+1), False)
+        try:
+            partition_unique_name,part_uri=createTemplatePartition(temp_name, session, cpc_uri, ''.join(random.choice(string.ascii_uppercase + string.digits) for num in range(4)))
+        except Exception as ex:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(ex))
+        except:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(sys.exc_info()[:2]))
+        #partionList[partition_unique_name] = part_uri
+    logging.info('<- createPartitionIteratively')
+    return partionList
+
+def createPartitionFromTemplate(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromTemplate')
+    partitionStatus=''
+    try:
+        template_dir_name = os.path.join(os.path.dirname(os.path.abspath(__file__)) , 'templates/cpc_' + cpc_name);
+        logging.debug(template_dir_name)
+        if not(os.path.isdir(template_dir_name)):
+            print_helper("No Template File exists")
+            return
+        template_files = os.listdir(template_dir_name)
+        logging.debug('template_files ' + str(template_files))
+        
+        print("\nChoose one of the below Templates:\n")
+        
+        for index in range(0, len(template_files)):
+            print index + 1, '. '.ljust(10), os.path.splitext(template_files[index])[0]
+        selected_template = option_choser("Select a template available to create partition:","TEMPLATE" ,len(template_files))
+        
+        temp_name = template_files[selected_template - 1]
+        logging.debug("Selected Template..." + temp_name)
+        
+        no_of_partitions = option_choser('Enter the number of partitions to be created ',"PARTITIONCOUNT", 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/cpc_' + cpc_name, temp_name)
+        logging.debug('template_name ' + template_name)
+        
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        partitionList=createPartitionIteratively(template_name, no_of_partitions, cpc_uri)
+        partitionStatus = 'Partition Created Successfully from template\n'
+        for part in partitionList.keys():
+        
+            partitionStatus+= 'Partition Name: '+part+'\n'
+            partitionStatus+= 'Partition URI: ' +partitionList[part]+'\n'
+    except:
+        print_helper('Partition Creation failed to create from given Template', True, str(sys.exc_info()[:2]))
+    logging.info('<-createPartitionFromTemplate')    
+    
+    print_helper(partitionStatus, False)
+    
+    print_helper("Process Completed", False)    
+    return
+
+def createPartitionFromPartition(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        for  index in range(0, len(partitions)):
+            print index + 1, '  ', partitions[index]['name']
+        partition_option = option_choser('Select partition by index','PARTITION_INDEX', len(partitions))
+        
+        partition_name = partitions[partition_option - 1]['name']
+        no_of_partitions = option_choser('Enter the number of partitions to be created ','NUMPARTS', 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        
+        
+        
+        temp_name = createTemplate(session,[partitions[partition_option - 1]], cpc_name, partition_name)
+        logging.debug('template_name '+ temp_name)
+        
+        time.sleep(1)
+        p.stop()      
+        
+        time.sleep(2)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("File not found: " + temp_name)
+        
+        createPartitionIteratively(temp_name, no_of_partitions, cpc_uri)
+    except:
+        print_helper('Partition Creation failed to create from chosen partition ' + partition_name, True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-createPartitionFromPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def exportPartition(cpc_name="",cpc_uri=""):
+    logging.info('->exportPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        temp_name = createTemplate(session,partitions, cpc_name)
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        time.sleep(1)
+        p.stop()
+        time.sleep(2)   
+        logging.debug('template_name '+ temp_name)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("Partition Inventory is not exported to the file " + temp_name)
+    except:
+        print_helper('Partition Export failed', True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-exportPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def importPartition(cpc_name='', cpc_uri=''):
+    logging.info('->importPartition')
+    try:
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/base_' + cpc_name, 'base_template.json')
+        logging.debug('template_name '+ template_name)
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        createTemplatePartition(template_name, session, cpc_uri)
+    except:
+        print_helper("Sorry! There is no backup inventory for the CPC selected", True, str(sys.exc_info()[:2]))
+    logging.info('<-importPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def readConfig():
+    config.read('savedsettings.cfg')
+    return config
+
+def updateConfig(params=None):
+    with open('savedsettings.cfg', 'wb') as configfile:
+        config.write(configfile)
+    return
+
+def user_input(inputStr='',section='',parameter='', password=False):
+    config = readConfig()
+    
+    userinput=''
+    
+    try: 
+        value=config.get(section, parameter)
+    except ConfigParser.NoSectionError:
+        if not section == '':
+            config.add_section(section)
+        value = ''
+    except:
+        value = ''    
+    if password:
+        userinput=getpass(inputStr.ljust(15) + ':')        
+    else:
+        userinput=raw_input(inputStr +' ['+ value + ']'.ljust(15) + ':')
+        
+    if not userinput == '':
+        value = userinput
+       
+    if not parameter=='':
+        config.set(section,parameter,value)
+    updateConfig()
+    return value 
+
+
+
+def main():
+    initializeLogging()
+    logging.info('Starting the PartitionManagementTemplating Tool')
+    print "*"*100
+    print "Capture and replay partition creation".center(100)
+    print "*"*100   
+    
+            
+    hmc_ip = user_input('Enter HMC IP', 'BASE_PARAMS', 'HMC_IP')#raw_input('Enter HMC IP ['+ config.get('BASE_PARAMS', 'HMC_IP') + ']'.ljust(30) + ':')
+    hmc_user = user_input('Enter Username', 'BASE_PARAMS', 'HMC_USER')#raw_input('Enter Username ['+ config.get('BASE_PARAMS', 'HMC_USER') + ']'.ljust(30) + ':')
+    hmc_password = user_input('Enter Password','','',True)#('Enter Password'.ljust(30) + ':')
+    
+    #hmc_ip = '9.152.151.49'
+    #hmc_user = 'pedebug'
+    #hmc_password = 'password'
+    # print hmc_password
+    logging.debug('hmc_ip: '+hmc_ip+' hmc_user '+hmc_user+' hmc_password '+hmc_password)
+    cpcs = []
+    global session
+    try:
+        
+        p = progress_bar_loading()
+        p.configure("Establishing session")
+        p.start()     
+        session = session_startup(host=hmc_ip, user=hmc_user, pwd=hmc_password)
+        logging.debug("Printing the session details... /n"+ str(session))
+        time.sleep(2)
+        p.stop()
+        
+        p = progress_bar_loading()
+        p.configure("Fetching CPC List")
+        p.start()
+        cpcs = list_cpcs(session)
+        p.stop()        
+        time.sleep(2)
+        
+        logging.debug("Printing the cpcs... /n"+ str(cpcs))
+    except ApiFatalException as ex:
+        print_helper("Sorry! Session could not be established. Please verify the IP, HMC Username/Password", True)
+        time.sleep(1)
+        p.stop() 
+        return
+    
+    print "****************************************************************************************************"
+    if len(cpcs) > 0:        
+        print "List of CPCs available"
+    else:
+        print_helper("No CPCs managed by the HMC!!!")
+        return
+    
+    
+    for  index in range(0, len(cpcs)):
+        print index + 1, '  ', cpcs[index]['name']
+    
+    try:
+        cpc_option = option_choser("Select cpc by index from the given list",'CPCSEL', len(cpcs))
+    
+        cpc_uri = cpcs[cpc_option - 1]['object-uri']
+        cpc_name = cpcs[cpc_option - 1]['name']
+        print_helper('CPC ' + cpc_name + ' is selected')
+        print("Choose one of the below options:")
+        options = '\n1.  create n partitions from existing templates?\n2.  create a partition based on another partition?\n3.  Export Partition Inventory?\n4.  Import Partition Inventory? '
+        print options
+        selected_option = option_choser('Select an option by index','FLAVOR', 4)
+    
+    
+        if selected_option == 1:
+            createPartitionFromTemplate(cpc_name, cpc_uri)
+            
+        elif selected_option == 2:
+            createPartitionFromPartition(cpc_name, cpc_uri)
+            
+        elif selected_option == 3:
+            exportPartition(cpc_name, cpc_uri)
+            
+        if selected_option == 4:
+            importPartition(cpc_name, cpc_uri)
+    except:
+        print_helper('Process Failed ', True, str(sys.exc_info()[:2]))
+   
+main()
diff --git a/build/lib/partitionengine/CreateTemplate.py b/build/lib/partitionengine/CreateTemplate.py
new file mode 100644
index 0000000..cd9c35e
--- /dev/null
+++ b/build/lib/partitionengine/CreateTemplate.py
@@ -0,0 +1,152 @@
+
+import ast
+import json
+import os
+from utils.wsautils import *
+
+
+roce_nic_writable_properties = ['description','device-number','name','network-adapter-port-uri']
+vfn_writable_properties = ['description','device-number','name','adapter-uri']
+vs_nic_writable_properties = ['description','device-number','name','virtual-switch-uri']
+writable_properties = [u'ifl-processing-weight-capped', u'minimum-cp-processing-weight',  u'maximum-ifl-processing-weight', u'access-problem-state-counter-set', u'ifl-processors',  u'cp-absolute-processor-capping-value',  u'reserve-resources', u'maximum-memory', u'boot-timeout', u'boot-os-specific-parameters',  u'processor-management-enabled', u'boot-device', u'access-basic-sampling', u'cp-absolute-processor-capping',  u'boot-record-lba', u'permit-cross-partition-commands', u'acceptable-status', u'maximum-cp-processing-weight', u'minimum-ifl-processing-weight',   u'access-global-performance-data', u'cp-processing-weight-capped', u'permit-aes-key-import-functions',  u'ifl-absolute-processor-capping-value', u'initial-ifl-processing-weight', u'access-extended-counter-set',  u'initial-cp-processing-weight', u'access-crypto-activity-counter-set', u'initial-memory', u'access-basic-counter-set', u'name', u'boot-configuration-selector', u'description', u'cp-processors',  u'access-diagnostic-sampling',u'permit-des-key-import-functions', u'processor-mode',u'ifl-absolute-processor-capping', u'access-coprocessor-group-set']
+hba_writable_properties = ['description','device-number','name','adapter-port-uri']
+boot_device = {'storage-adapter':['boot-logical-unit-number','boot-world-wide-port-name','boot-storage-device'],'network-adapter':['boot-network-device'],'ftp':['boot-ftp-host','boot-ftp-insfile','boot-ftp-password','boot-ftp-username'],'iso-image':['boot-iso-image-name','boot-iso-ins-file'],'removable-media':['boot-removable-media', 'boot-removable-media-type']}
+global nic_device_uri
+global hba_device_uri
+    
+class Object:
+    def to_JSON(self):
+        return json.dumps(self, default=lambda o: o.__dict__, 
+            sort_keys=True, indent=4)
+class Payload(object):
+    def __init__(self, j):
+        self.__dict__ = json.loads(j)
+        
+        
+def getNicList(session,ob,ob1):
+    logging.info('->getNicList')
+    nic_list = []
+    global nic_device_uri
+    for nic in getattr(ob,'nic-uris'):
+        logging.debug(str(nic))
+        response = session.get(nic)
+        
+        logging.debug(str(response.body))
+        nic_ob1= Payload(json.dumps(response.body))
+        nic_ob = Object()
+        for key in nic_ob1.__dict__.keys():
+            if response.body['type'] == 'roce':
+                if key in roce_nic_writable_properties:
+                    logging.debug(str(getattr(nic_ob1,key)))
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            else:
+                #print key
+                if key in vs_nic_writable_properties:
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'network-adapter' and getattr(nic_ob1, key) == nic_device_uri:
+                    setattr(ob1, 'nic-boot-device-number', getattr(nic_ob1, 'device-number')) 
+        nic_list.append(nic_ob)
+        
+        logging.debug(str(nic_list));
+        logging.info('<-getNicList')
+    return nic_list 
+
+def getHbaList(session,ob,ob1):
+    logging.info('->getHbaList')
+    hba_list = []
+    global hba_device_uri
+    for hba in getattr(ob,'hba-uris'):
+        response = session.get(hba)
+        hba_ob = Object()
+        hba_ob1= Payload(json.dumps(response.body))
+        for key in hba_ob1.__dict__.keys():
+            if key in hba_writable_properties:
+                setattr(hba_ob,key,getattr(hba_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'storage-adapter' and getattr(hba_ob1, key) == hba_device_uri:
+                    setattr(ob1, 'hba-boot-device-number', getattr(hba_ob1, 'device-number')) 
+        hba_list.append(hba_ob)
+    logging.info('<-getHbaList')
+    return hba_list 
+
+def getVfnList(session,ob):
+    logging.info('->getVfnList')
+    vfn_list = []
+    for vfn in getattr(ob,'virtual-function-uris'):
+        response = session.get(vfn)
+        vfn_ob = Object()
+        vfn_ob1= Payload(json.dumps(response.body))
+        for key in vfn_ob1.__dict__.keys():
+            if key in vfn_writable_properties:
+                setattr(vfn_ob,key,getattr(vfn_ob1,key))
+    
+        vfn_list.append(vfn_ob)
+    logging.info('<-getVfnList')
+    return vfn_list 
+
+def setBootDevice(ob,ob1):
+    logging.info('->setBootDevice')
+    global hba_device_uri
+    global nic_device_uri
+    if getattr(ob, 'boot-device') == 'storage-adapter':
+        hba_device_uri = getattr(ob, 'boot-storage-device')
+            
+    if getattr(ob, 'boot-device') == 'network-adapter':
+        nic_device_uri = getattr(ob, 'boot-network-device')
+           
+    if getattr(ob, 'boot-device') in boot_device.keys():
+        for boot_property in boot_device[getattr(ob, 'boot-device')]:
+            setattr(ob1,boot_property,getattr(ob, boot_property))
+    logging.info('<-setBootDevice')
+    return
+                
+def getPartitionTemplate(session,inv_response,partition_list):
+    logging.info('Retriving the partition info and loading into template....')
+    logging.info('->getPartitionTemplate')
+    ob1 = Object()
+    ob = Payload(json.dumps(inv_response))
+    for key in ob.__dict__.keys():
+        if key in writable_properties:
+            setattr(ob1,key,getattr(ob,key))
+        if key == 'crypto-configuration':
+            setattr(ob1,'cryptos',getattr(ob,key))
+    setBootDevice(ob, ob1)
+    nic_list = getNicList(session,ob,ob1)
+    hba_list = getHbaList(session, ob,ob1)
+    vfn_list = getVfnList(session, ob)
+    setattr(ob1,'nics',nic_list)
+    setattr(ob1,'virtual-functions',vfn_list)
+    setattr(ob1,'hbas',hba_list)
+    partition_list.append(ob1)
+    logging.info('<-getPartitionTemplate')
+    return partition_list
+        
+def createTemplate(session,inv_response,cpc_name,partition_name = None):
+    logging.info('->createTemplate')
+    logging.debug(str(inv_response))
+    partition_list = []
+    complete = Object()
+    for partition in inv_response:
+            response = session.get(partition['object-uri'])
+            complete = Object()
+            partition_list = getPartitionTemplate(session, response.body, partition_list) 
+            
+    setattr(complete,'partition',partition_list)  
+    if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates'):
+        os.mkdir(os.path.dirname(os.path.abspath(__file__))+'/templates')
+    if partition_name == None:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/base_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name,'base_template.json')
+    else:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/cpc_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name,partition_name+'_template.json')
+    file = open(file_name,'w+')        
+    file.write(complete.to_JSON())
+    file.close()
+    logging.info('template created successfully...')
+    logging.info('<-createTemplate')
+    
+    return file_name
diff --git a/build/lib/partitionengine/CreateTemplatePartition.py b/build/lib/partitionengine/CreateTemplatePartition.py
new file mode 100644
index 0000000..5e06d02
--- /dev/null
+++ b/build/lib/partitionengine/CreateTemplatePartition.py
@@ -0,0 +1,147 @@
+
+import ast
+import json
+import random
+
+from utils.wsautils import *
+
+import sys
+import time
+import threading
+
+
+
+
+
+def remove(body,keys_list):
+    for key in keys_list:
+        if key in body.keys():
+            del body[key]
+
+def createTemplatePartition(temp_filename,session,cpc,partition_unique_name=None):
+    logging.info('==>>################# createTemplatePartition invoked#################')
+    logging.debug('Template file name: '+ temp_filename)
+    logging.debug('cpc uri: '+ cpc)
+    logging.debug('Partition unique name: '+ str(partition_unique_name))
+    temp_file = open(temp_filename,'r')
+    json_text = temp_file.read()
+    ip = json.loads((json_text))
+    ip_body = ip['partition']
+    p = progress_bar_loading()
+    try:
+        for partition in ip_body:
+            body = {'processor-mode':partition['processor-mode'], 'initial-memory':partition['initial-memory'],'maximum-memory':partition['maximum-memory']}
+            if partition_unique_name != None:
+                body.update({'name':partition['name']+'_'+str(partition_unique_name)})
+            else:
+                body.update({'name':partition['name']})
+            if partition['cp-processors'] != 0:
+                body.update({'cp-processors':partition['cp-processors']})
+            else:
+                body.update({'ifl-processors':partition['ifl-processors']})
+                
+            p = progress_bar_loading()
+            p.configure("Creating Partition")
+            p.start()
+            response = session.post(cpc+'/partitions',json.dumps(body))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Respose from partitions Post request" + str(response)) 
+            
+            
+            part_uri = response.body['object-uri']
+            logging.debug("Partition URI from newly created partition" + part_uri)
+            
+            
+            p = progress_bar_loading()
+            p.configure("Creating VNics")
+            p.start()   
+            for nic in partition['nics']:
+                logging.info("Iterating through nic URIS")            
+                response = session.post(part_uri+'/nics',json.dumps(nic))            
+                logging.debug("Respose from nics Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'network-adapter') and (nic['device-number'] == partition['nic-boot-device-number']) :            
+                    nicRes = response.body['element-uri']
+                    partition['boot-network-device'] = nicRes
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+             
+             
+            p = progress_bar_loading()
+            p.configure("Creating HBAs")
+            p.start()       
+            for hba in partition['hbas']:
+                logging.info("Iterating through hba URIS")
+                
+                response = session.post(part_uri+'/hbas',json.dumps(hba))
+                
+                logging.debug("Respose from hbas Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'storage-adapter') and (hba['device-number'] == partition['hba-boot-device-number']) :            
+                    hbaRes = response.body['element-uri']
+                    partition['boot-storage-device'] = hbaRes
+                 
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            
+            p = progress_bar_loading()
+            p.configure("Creating VirtualFunctions")
+            p.start()       
+            for vfn in partition['virtual-functions']:
+                logging.info("Iterating through virtual-functions URIS")
+                
+                response = session.post(part_uri+'/virtual-functions',json.dumps(vfn))
+                
+                
+                logging.debug("Respose from virtual-functions Post request" + str(response))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            p = progress_bar_loading()
+            p.configure("Configuring Cryptos")
+            p.start()
+            if partition['cryptos'] != None:
+                logging.info("Adding crypto configurations")
+                
+                response = session.post(part_uri+'/operations/increase-crypto-configuration',json.dumps(partition['cryptos']))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            remove(partition,['nics','hbas','virtual-functions','name','hba-boot-device-number','nic-boot-device-number','cryptos'])
+            logging.debug("Removed unwanted attributes")
+            
+            p = progress_bar_loading()
+            p.configure("\nUpdating Partition Properties")        
+            p.start()
+            response = session.post(part_uri,json.dumps(partition))        
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Response from Update Partition request"+ str(response))
+            
+            
+            p = progress_bar_loading()
+            p.configure("Retrieve and Verify Partition Properties")        
+            p.start()
+            response = session.get(part_uri)            
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            if(response.status == 200):
+                sys.stdout.write("Partition: " + response.body['name']+" Created Successfully" )
+            logging.debug("Partition Properties"+ str(response))
+    except:
+        time.sleep(1)
+        p.stop()
+        raise
+        
+    logging.info('<<=########## createTemplatePartition invoked#########')
+    return partition_unique_name,part_uri
\ No newline at end of file
diff --git a/build/lib/partitionengine/__init__.py b/build/lib/partitionengine/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/build/lib/partitionengine/delete_all.py b/build/lib/partitionengine/delete_all.py
new file mode 100644
index 0000000..74fda68
--- /dev/null
+++ b/build/lib/partitionengine/delete_all.py
@@ -0,0 +1,14 @@
+'''
+Created on Apr 13, 2016
+
+@author: sowmya
+'''
+from utils.wsautils import *
+
+session= session_startup(host='9.12.38.77')
+cpc_uri = list_cpcs(session)[0]['object-uri']
+part = session.get(cpc_uri+'/partitions')
+print part
+
+for partition in part.body['partitions']:
+    print session.delete(partition['object-uri'])
diff --git a/build/lib/partitionengine/utils/__init__.py b/build/lib/partitionengine/utils/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/build/lib/partitionengine/utils/wsaconst.py b/build/lib/partitionengine/utils/wsaconst.py
new file mode 100644
index 0000000..b16f4d9
--- /dev/null
+++ b/build/lib/partitionengine/utils/wsaconst.py
@@ -0,0 +1,685 @@
+
+WSA_CONST_VERSION = "1.1"  # Current version of the API constants
+
+# Make a copy of the input array.  This copy contains lowercase versions of each
+# array element that is not already lowercase.
+def make_lowercase_copy(tokens):
+    lower_tokens = []
+    for token in tokens:
+        lower_token = token.lower()
+        #print "token: %s (%s)" % (token, lower_token)
+        if lower_token not in tokens:
+            lower_tokens.append(lower_token)
+        #print "lower_tokens(%s): %s" % (len(lower_tokens), lower_tokens)
+    return lower_tokens
+
+# ??? FVT regression test framework to-do's
+# - Need to add testcase_properties definition to all existing testcases.  Use this template
+#   and replace the items in angle brackets with the appropriate strings:
+#
+#      testcase_properties = {TC_FULL_NAME : get_testcase_full_filename(),
+#                             TC_COMPONENT : TC_COMPONENT_<component>,
+#                             TC_ID : get_testcase_id(),
+#                             TC_TITLE : '<title>',
+#                             TC_URI : '<uri>',
+#                             TC_MINIMUM_API_VERSION : TC_API_VERSION_<minimum_version>,
+#                             TC_SCENARIO_TYPE : TC_SCENARIO_TYPE_<scenario_type>,
+#                             TC_EXECUTION_TYPE : TC_EXECUTION_TYPE_<execution_type>,
+#                             TC_CAPABILITIES : [<appropriate TC_CAPABILITY_<capability> values, OR empty array>]}
+#
+# x Consider reworking skeleton.py to follow the above model, so that future automated updates are easier,
+#   and as many as possible of these properties can come from the FVT Lotus Notes database. [done]
+#   x Consider adding code to the skeleton to fetch the minimum version out of testcase_properties for
+#     use in a testcase environment check. [done]
+#   x Need to fetch the component, id and title from testcase_properties as well, because they are used
+#     in some print statements at the beginning of the testcase execution. [done]
+# x Need a proper implementation of is_api_version_at_least(). [done]
+# - Should probably add an is_api_version_at_most() method for potential use in the future.
+# - Add a check for required testcase properties???  When?  --get-properties?  --check-properties?
+#   - The list of required properties would be defined in a constant in wsaconst.py
+# x Add support for creating a CSV file of testcases that meet specified criteria? ["done".  Not CSV though.  See runregress.py]
+#   - Add --csv-file option to specify the output CSV filename
+#   - If testcase meets requirements, *append* a line to the CSV file
+#     - If file doesn't exist, create it by writing a header line that defines the columns
+#       - column names and order would be defined in a constant in wsaconst.py
+#   - Requires caller to erase any leftover CSV file before beginning this run
+# x Add an option to runregress.py to specify a top directory to search for testcases to run 
+#     and run all it finds that meet the requirements. [done]
+#   x The requirements can be specified as a single complex string option which is passed
+#     as a bunch of arguments to the testcase.  Maybe something like this:
+#        runregress.py --top-dir <dir> --requirements "--component SVM --component VSM --scenario success --execution-type self-checking" [done]
+
+
+# The name of the variable that defines a testcase's properties.  
+# Each testcase must define this variable appropriately.
+TESTCASE_PROPERTIES_VARIABLE_NAME = 'testcase_properties'
+
+#############################################################################
+# These constants define property names and values that are used to describe
+# testcases.  They are intended for use in the definition of the 
+# TESTCASE_PROPERTIES_VARIABLE_NAME dictionary in each testcase's source code.
+# Some of them can be specified on the command line as testcase requirements.
+#############################################################################
+# Testcase filename, with full path information
+TC_FULL_NAME = 'full_name'
+
+# Testcase ID.  The numeric ID, typically found in the testcase filename, which is of the form:
+# comp_id.py, where comp is the component and id is the testcase ID.
+TC_ID = 'id'
+
+# Testcase title
+TC_TITLE = 'title'
+
+# Primary URI being tested by this testcase
+TC_URI = 'uri'
+
+# API versions.  They must be defined in such a way that they can be meaningfully supported by the is_api_version_*() methods.
+# Be sure to add any new ones to TC_API_VERSION_LIST.
+TC_MINIMUM_API_VERSION = 'min_api_version'
+TC_MAXIMUM_API_VERSION = 'max_api_version'
+TC_API_VERSION_ZGRYPHON_GA2  = '1.1'
+TC_API_VERSION_ZGRYPHON_GA2A = '1.2'
+TC_API_VERSION_ZHELIX_GA1    = '1.3'
+TC_API_VERSION_ZHELIX_GA2    = '1.4'
+TC_API_VERSION_ZHELIX_GA2A   = '1.5'    # LI 1065 - Support for Shutdown and Power-off Tasks
+TC_API_VERSION_ZSPHINX_GA1   = '1.6'
+TC_API_VERSION_ZSPHINX_GA2   = '1.7'
+TC_API_VERSION_ZMIDAS_GA1    = '1.8'
+# List of all valid API versions, used for command line validation
+TC_API_VERSION_LIST = [TC_API_VERSION_ZGRYPHON_GA2, TC_API_VERSION_ZGRYPHON_GA2A, TC_API_VERSION_ZHELIX_GA1, TC_API_VERSION_ZHELIX_GA2,
+                       TC_API_VERSION_ZHELIX_GA2A, TC_API_VERSION_ZSPHINX_GA1, TC_API_VERSION_ZSPHINX_GA2,TC_API_VERSION_ZMIDAS_GA1]
+
+# Testcase capabilities.  These define API/HMC/SE "capabilities" that are tested by certain testcases.
+# They can be, for example, MCF bundles, line items, parts of line items, ODTs, MCFs, MCLs, optional facilities, etc...
+# Be sure to add any new ones to TC_CAPABILITY_LIST.
+TC_CAPABILITIES = 'capabilities'
+TESTCASE_CAPABILITIES = TC_CAPABILITIES  # ??? Temp duplicate of TC_CAPABILITIES until FVT API database is updated to use TC_CAPABILITIES
+TC_CAPABILITY_ZVM           = 'ZVM'  # This testcase requires a z/VM system
+TC_CAPABILITY_IEDN          = 'IEDN'
+TC_CAPABILITY_QDIO          = 'QDIO'
+TC_CAPABILITY_VSWITCH       = 'VIRTUAL SWITCH'
+TC_CAPABILITY_PRSM          = 'PRSM'
+TC_CAPABILITY_XHYP          = 'X86'
+TC_CAPABILITY_POWERVM       = 'POWER-VM'
+#TC_CAPABILITY_BLADEXHYP     = 'X86-BLADE'
+#TC_CAPABILITY_BLADEPOWER    = 'POWER-BLADE'
+TC_CAPABILITY_BLADEISAOPT   = 'ISAOPT-BLADE'
+TC_CAPABILITY_BLADEDPXI50Z  = 'DPXI50Z-BLADE'
+TC_CAPABILITY_ZAWARE  = 'ZAWARE'
+TC_CAPABILITY_ZBX  = 'ZBX'
+TC_CAPABILITY_ZFX  = 'ZFX'
+TC_CAPABILITY_ZHYP  = 'ZHYP'
+TC_CAPABILITY_ZXN  = 'ZXN' # For zExtension nodes - zFX Mod 001 & zBX Mod 004 nodes
+TC_CAPABILITY_ZBXMOD004 = 'ZBXMOD004'
+# List of all valid capabilities, used for command line validation
+TC_CAPABILITY_LIST = [TC_CAPABILITY_ZVM, TC_CAPABILITY_IEDN, TC_CAPABILITY_QDIO, TC_CAPABILITY_VSWITCH, TC_CAPABILITY_PRSM, TC_CAPABILITY_XHYP, 
+                      TC_CAPABILITY_POWERVM, TC_CAPABILITY_BLADEISAOPT, TC_CAPABILITY_BLADEDPXI50Z, TC_CAPABILITY_ZAWARE]
+TC_CAPABILITY_LIST.extend(make_lowercase_copy(TC_CAPABILITY_LIST))  # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase components
+# Be sure to add any new ones to TC_COMPONENT_LIST.
+TC_COMPONENT = 'component'
+TC_COMPONENT_CONS = 'CONS'  #CreateTemplate
+TC_COMPONENT_CPC  = 'CPC'   #Central Processor Complex
+TC_COMPONENT_CREC = 'CREC'  #Capacity Records
+TC_COMPONENT_EAM  = 'EAM'   #Enterprise Availability Management
+TC_COMPONENT_EM   = 'EM'    #Energy Management
+TC_COMPONENT_EMM  = 'EMM'   #Ensemble Membership Management
+TC_COMPONENT_EMF  = 'EMF'   #Ensemble Measurement Facility
+TC_COMPONENT_GPRO = 'GPRO'  #Group Profiles
+TC_COMPONENT_GRP  = 'GRP'   #Groups
+TC_COMPONENT_GS   = 'GS'    #General Services
+TC_COMPONENT_HVM  = 'HVM'   #Hypervisor Virtualization Management
+TC_COMPONENT_IOM  = 'IOM'   #I/O Configuration Management
+TC_COMPONENT_IPRO = 'IPRO'  #Image Activation Profiles
+TC_COMPONENT_IS   = 'IS'    #Inventory Service
+TC_COMPONENT_LGR  = 'LGR'   #Live Guest Relocation
+TC_COMPONENT_LPAR = 'LPAR'  #Logical Partition
+TC_COMPONENT_LPRO = 'LPRO'  #Load Activation Profile
+TC_COMPONENT_MDM  = 'MDM'   #Monitors Dashboard Metric Groups
+TC_COMPONENT_MS   = 'MS'    #Metrics Service
+TC_COMPONENT_NVM  = 'NVM'   #Network Virtualization Management
+TC_COMPONENT_PPM  = 'PPM'   #Workloads and Performance Management
+TC_COMPONENT_RPRO = 'RPRO'  #Reset Activation Profiles
+TC_COMPONENT_SEC  = 'SEC'   #Security and User Management
+TC_COMPONENT_SVM  = 'SVM'   #Storage Virtualization Management
+TC_COMPONENT_VSM  = 'VSM'   #Virtual Server Management
+TC_COMPONENT_zBX  = 'zBX'   #zEnterprise Blade Extension
+TC_COMPONENT_ZFX  = 'ZFX'   #zEnterprise Flex System
+TC_COMPONENT_ZXN  = 'ZXN'   #zNode for both zFX and zBX nodes
+TC_COMPONENT_HVM_2 = 'HVM_2'#hvm for prsm2
+TC_COMPONENT_SVM_2 = 'SVM_2'#svm for prsm2
+TC_COMPONENT_VSM_2 = 'VSM_2'#vsm for prsm2
+TC_COMPONENT_CPC_2 = 'CPC_2'#cpc for prsm2
+TC_COMPONENT_NVM_2 = 'NVM_2'#nvm for prsm2
+
+# List of all valid components, used for command line validation
+TC_COMPONENT_LIST = [TC_COMPONENT_CONS, TC_COMPONENT_CPC, TC_COMPONENT_CREC, TC_COMPONENT_EAM, TC_COMPONENT_EM, TC_COMPONENT_EMM,
+                     TC_COMPONENT_GPRO, TC_COMPONENT_GRP, TC_COMPONENT_GS, TC_COMPONENT_HVM, TC_COMPONENT_IPRO, TC_COMPONENT_IS,
+                     TC_COMPONENT_LPAR, TC_COMPONENT_LPRO, TC_COMPONENT_MDM, TC_COMPONENT_MS, TC_COMPONENT_NVM, TC_COMPONENT_PPM,
+                     TC_COMPONENT_RPRO, TC_COMPONENT_SVM, TC_COMPONENT_VSM, TC_COMPONENT_SEC,TC_COMPONENT_zBX, 
+                     TC_COMPONENT_HVM_2, TC_COMPONENT_SVM_2,TC_COMPONENT_NVM_2,TC_COMPONENT_VSM_2,TC_COMPONENT_CPC_2]
+TC_COMPONENT_LIST.extend(make_lowercase_copy(TC_COMPONENT_LIST))    # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase scenario type
+# Be sure to add any new ones to TC_SCENARIO_TYPE_LIST.
+TC_SCENARIO_TYPE = 'scenario_type'
+TC_SCENARIO_TYPE_AUTHORIZATION = 'authorization'
+TC_SCENARIO_TYPE_FAILURE       = 'failure'
+TC_SCENARIO_TYPE_NOTIFICATION  = 'notification'
+TC_SCENARIO_TYPE_SUCCESS       = 'success'
+# List of all valid scenario types, used for command line validation
+TC_SCENARIO_TYPE_LIST = [TC_SCENARIO_TYPE_AUTHORIZATION, TC_SCENARIO_TYPE_FAILURE, TC_SCENARIO_TYPE_NOTIFICATION, TC_SCENARIO_TYPE_SUCCESS]
+TC_SCENARIO_TYPE_LIST.extend(make_lowercase_copy(TC_SCENARIO_TYPE_LIST))    # Add lowercase versions as needed, for command line convenience
+
+# Testcase execution type
+# Be sure to add any new ones to TC_EXECUTION_TYPE_LIST.
+TC_EXECUTION_TYPE = 'execution_type'
+TC_EXECUTION_TYPE_DISRUPTIVE               = 'disruptive'
+TC_EXECUTION_TYPE_MANUAL                   = 'manual'
+TC_EXECUTION_TYPE_SELF_CHECKING            = 'self-checking'
+TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE  = 'self-checking-exclusive'
+TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP = 'self-checking-with-setup'
+TC_EXECUTION_TYPE_SUBTEST                  = 'subtest'
+# List of all valid execution types, used for command line validation
+TC_EXECUTION_TYPE_LIST = [TC_EXECUTION_TYPE_DISRUPTIVE, TC_EXECUTION_TYPE_MANUAL, TC_EXECUTION_TYPE_SELF_CHECKING,
+                          TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE, TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP, TC_EXECUTION_TYPE_SUBTEST]
+TC_EXECUTION_TYPE_LIST.extend(make_lowercase_copy(TC_EXECUTION_TYPE_LIST))  # Add lowercase versions as needed, for command line convenience
+
+# Marker lines for output of --get-properties requests
+GET_PROPERTIES_BEGIN_MARKER = "***%s begin***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+GET_PROPERTIES_END_MARKER = "***%s end***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+
+
+#############################################################################
+# Miscellaneous constants
+#############################################################################
+
+# Flag to indicate whether ODT Z9474 is applied to the target system.  It changes some
+# characteristics of notification messages.  This flag allows the message validation
+# code to react accordingly.
+Z9474_applied = True
+
+
+#############################################################################
+# "Temporary object" support.  These are constants that support the creation
+# (via the various object-specific "create_temporary_<object-type>()" methods)
+# and deletion of "temporary" objects.
+#############################################################################
+
+# System-defined users, used for admin-type operations during testcase scenario setup
+# and cleanup.  These constants are intended for use as values for the KEY_ADMIN_USERID 
+# property in the temporary_object_types_info collection and on calls to get_admin_session(userid).
+ACCESS_ADMINISTRATOR =      'ACSADMIN'
+ADVANCED_OPERATOR =         'ADVANCED'
+ENSEMBLE_ADMINISTRATOR =    'ENSADMIN'
+ENSEMBLE_OPERATOR =         'ENSOPERATOR'
+SYSTEM_OPERATOR =           'OPERATOR'
+SERVICE_REPRESENTATIVE =    'SERVICE'
+SYSTEM_PROGRAMMER =         'SYSPROG'
+PEDEBUG =                   'PEDEBUG'
+
+# These constants identify the kinds of objects that are supported by the
+# "temporary object" support in wsautils.  Each type must be added to the
+# temporary_object_types_deletion_order list in the appropriate position,
+# and it must also be added to the temporary_object_types_info collection
+# so it can be identified and handled properly.
+TEMP_OBJ_TYPE_USER =                'user'
+TEMP_OBJ_TYPE_USER_ROLE =           'role'
+TEMP_OBJ_TYPE_USERID_PATTERN =      'userid-pattern'
+TEMP_OBJ_TYPE_PASSWORD_RULE =       'password-rule'
+TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG =  'ldap'
+TEMP_OBJ_TYPE_CUSTOM_GROUP =        'group'
+TEMP_OBJ_TYPE_VIRTUAL_SERVER =      'virtual-server'
+TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP = 'workload-resource_group'
+TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP = 'workload-element_group'
+
+# An ordered list of object types supported as "temporary objects".  This list defines
+# the order in which the temporary objects are deleted at the end of testcase execution.
+temporary_object_types_deletion_order = [TEMP_OBJ_TYPE_USERID_PATTERN,  # must be before User (specifically, before type=template Users are deleted)
+                                         TEMP_OBJ_TYPE_USER,
+                                         TEMP_OBJ_TYPE_USER_ROLE,       # must be after User
+                                         TEMP_OBJ_TYPE_CUSTOM_GROUP,    # must be after User Role and User
+                                         TEMP_OBJ_TYPE_PASSWORD_RULE,   # must be after User
+                                         TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG,  # must be after patterns
+                                         TEMP_OBJ_TYPE_VIRTUAL_SERVER,
+                                         TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP,
+                                         TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP, # must be after Workload Element Groups
+                                        ]
+
+# Keys for info in the temporary_object_types_info map
+KEY_ADMIN_USERID = 'admin_userid'   # Key for the name of the system-defined user that has administration privileges for this type of object
+KEY_URI_PREFIX =   'uri_prefix'     # Key for the initial constant part of the URI that identifies an object this type
+
+# Map of information about the object types that are supported as "temporary objects"
+temporary_object_types_info = dict({TEMP_OBJ_TYPE_USER :                {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/users/'}, 
+                                    TEMP_OBJ_TYPE_USER_ROLE :           {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/user-roles/'},
+                                    TEMP_OBJ_TYPE_USERID_PATTERN :      {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/user-patterns/'},
+                                    TEMP_OBJ_TYPE_PASSWORD_RULE :       {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/password-rules/'},
+                                    TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG :  {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/ldap-server-definitions/'},
+                                    TEMP_OBJ_TYPE_CUSTOM_GROUP :        {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/groups/'},
+                                    TEMP_OBJ_TYPE_VIRTUAL_SERVER :      {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/virtual-servers/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP   : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-resource-groups/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP    : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-element-groups/'},
+                                  })
+
+
+# Map of URI prefixes to the name of the system-defined user that has administrator permissions for objects with that URI prefix.
+# This map is used to locate/create an API session with administrator permissions for the URI prefix.
+# Note that these prefixes must be listed from most-specific to least-specific, since they are searched in order.
+# It is recommended to include a trailing slash only on URI prefixes that require it in order for it to be a valid URI.
+# (Some URI prefixes can be used in their entirety on List operations, and thus should not include a trailing slash;
+# if needed, two entries can be included: one with a trailing slash and one without).
+# TODO: add support for expressions or wildcards for objects that contain multiple IDs (e.g., element objects often have multiple IDs)
+uri_admin_info = dict({'/api/ensembles' : ENSEMBLE_ADMINISTRATOR,
+                       '/api/console/hardware-messages' : SYSTEM_PROGRAMMER,
+                       '/api/console/users' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-roles' : ACCESS_ADMINISTRATOR,
+                       '/api/console/tasks' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-patterns' : ACCESS_ADMINISTRATOR,
+                       '/api/console/password-rules' : ACCESS_ADMINISTRATOR,
+                       '/api/console/ldap-server-definitions' : ACCESS_ADMINISTRATOR,
+                       '/api/users/' : ACCESS_ADMINISTRATOR,
+                       '/api/user-roles/' : ACCESS_ADMINISTRATOR,
+                     })
+#############################################################################
+# ActiveMQ
+# Note that the HMC must be configured to explicitly use the non-SSL ports.
+#############################################################################
+
+# PyActiveMQ ports
+WSA_ACTIVEMQ_PORT_NON_SSL = 61616
+WSA_ACTIVEMQ_PORT_SSL     = 61617
+
+# STOMP ports
+WSA_STOMP_PORT_NON_SSL = 61613
+WSA_STOMP_PORT_SSL = 61612
+
+# Supported ActiveMQ clients
+# These constants are used as command line option values.
+AMQ_CLIENT_PYACTIVEMQ = 'pyactivemq'
+AMQ_CLIENT_STOMP = 'stomp'
+WSA_DEFAULT_AMQ_CLIENT = AMQ_CLIENT_STOMP
+
+# ActiveMQ socket types.
+# These constants are used as command line option values.
+SOCKET_TYPE_SSL = 'ssl'
+SOCKET_TYPE_NON_SSL = 'non-ssl'
+
+#############################################################################
+# Test systems information
+#############################################################################
+### R32 ensemble
+# The name of the ensemble on the primary FVT test system.  This can be used
+# in testcases with certain prerequisites/restrictions that are known to
+# exist on R32.
+ENSEMBLE_NAME_R32 = 'R32Ensemble'
+DEFAULT_ENSEMBLE_NAME = 'ZBX51'
+DEFAULT_CPC_NAME = 'S32'
+DEFAULT_VIRTUALIZATION_HOST_NAME = 'B.1.12'
+DEFAULT_VIRTUAL_SERVER_NAME = 'APIVM1'
+DEFAULT_LPAR_NAME = 'APIVM1'
+PREFERRED_ZVM_VIRTUALIZATION_HOST_R32 = 'APIVM1'
+IP_ADDRESS_R32_HMC = 'Y.Y.Y.Y'         # (R32 is no longer available for API testing)
+IP_ADDRESS_R32_ALT_HMC = '9.60.14.45'     # (R32 is no longer available for API testing)
+FAMILIAR_NAME_R32_HMC = 'S32'          # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+# Ichabod ensemble
+IP_ADDRESS_ICHABOD_HMC = '9.60.14.63'
+FAMILIAR_NAME_ICHABOD_HMC = 'ICHABOD'  # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+#===============================================================================
+# Constant file to run the Testcase : lpar_5433
+# 
+LPAR_CPC_NAME = 'APIVM1'
+LPAR_NAME     = 'VMALT' # remove the postfix '1' from the lpar name.
+LPAR_NAME_ONE = 'VMALT1'
+LPAR_NAME_TWO = 'VMALT2'
+LPAR_NAME_THREE = 'VMALT3'
+#===============================================================================
+
+#############################################################################
+# API URIs
+#############################################################################
+
+# Log onto an HMC
+WSA_URI_LOGON   = '/api/session'
+
+# Log off of an HMC
+WSA_URI_LOGOFF  = '/api/session/this-session'
+
+# Retrieve the API version
+WSA_URI_VERSION = '/api/version'
+
+# List all ensembles
+WSA_URI_ENSEMBLES      = '/api/ensembles'
+
+# Retrieve properties of a specific ensemble
+WSA_URI_ENSEMBLE       = '/api/ensembles/{0}'
+
+# Retrieve all CPCs
+WSA_URI_CPCS           = '/api/cpcs'
+
+# Retrieve all virtualization hosts of a specific ensemble
+WSA_URI_VIRT_HOSTS_ENS = '/api/ensembles/{0}/virtualization-hosts'
+
+# Retrieve all virtualization hosts of a specific cpc
+WSA_URI_VIRT_HOSTS_CPC = '/api/cpcs/{0}/virtualization-hosts'
+
+# Retrieve all properties of a specific virtualization host
+WSA_URI_VIRT_HOST      = '/api/virtualization-hosts/{0}'
+
+
+#############################################################################
+# Testcase exit return codes
+#############################################################################
+
+# Exit return code for successful testcase execution
+WSA_EXIT_SUCCESS = 0
+
+# Exit return code for an API error
+WSA_EXIT_ERROR_API = 1
+
+# Exit return code for an unexpected error such as a communication failure
+WSA_EXIT_ERROR_UNCAUGHT = 2
+
+# Exit return code for successful --get-properties request
+WSA_EXIT_GET_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for successful --check-properties request
+WSA_EXIT_CHECK_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for an invalid command line (e.g., an invalid combination of options)
+WSA_EXIT_INVALID_COMMAND_LINE = 5
+
+# Exit return code for an error due to missing testcase properties
+WSA_EXIT_MISSING_TESTCASE_PROPERTIES = 6
+
+# Exit return code indicating that a specific testcase property is not defined
+WSA_EXIT_PROPERTY_NOT_DEFINED = 7
+
+# Exit return code indicating that a testcase requirement was not met
+WSA_EXIT_REQUIREMENT_NOT_MET = 8
+
+
+WSA_EXIT_ERROR_CLEANUP = 9
+#############################################################################
+# HTTP Request and Response
+# Note that the HMC must be configured to explicitly use the non-SSL port.
+#############################################################################
+
+# Non-SSL HTTP Port ... need HTTPConnection ...
+WSA_PORT_NON_SSL = 6167
+
+# SSL HTTP Port ... needs HTTPSConnection ...
+WSA_PORT_SSL     = 6794
+
+# HTTP GET command
+WSA_COMMAND_GET    = 'GET'
+
+# HTTP DELETE command
+WSA_COMMAND_DELETE = 'DELETE'
+
+# HTTP POST command
+WSA_COMMAND_POST   = 'POST'
+
+# HTTP PUT command
+WSA_COMMAND_PUT    = 'PUT'
+
+# Header for content type ... both request and response
+WSA_HEADER_CONTENT    = 'content-type'
+WSA_HEADER_CONTENT_TYPE   = WSA_HEADER_CONTENT  # Synonym with better name
+WSA_HEADER_CONTENT_LENGTH = 'content-length'
+
+# Header for API session ... request header only
+WSA_HEADER_RQ_SESSION = 'x-api-session'
+
+# Header for API session ... response header only
+WSA_HEADER_RS_SESSION = 'api-session'
+
+# Response headers (these are published in the examples in the WS API customer book)
+WSA_HEADER_RESP_SERVER = 'server'
+WSA_HEADER_RESP_CACHE_CONTROL = 'cache-control'
+WSA_HEADER_RESP_DATE = 'date'
+WSA_HEADER_RESP_LOCATION = 'location'
+WSA_HEADER_RESP_TRANSFER_ENCODING = 'transfer-encoding'
+
+WSA_CONTENT_JSON = 'application/json'
+WSA_CONTENT_XML  = 'application/xml'
+WSA_CONTENT_ZIP  = 'application/zip'
+
+# Currently supported content types
+WSA_SUPPORTED_CONTENT = [ WSA_CONTENT_JSON, WSA_CONTENT_XML, WSA_CONTENT_ZIP ]
+
+#############################################################################
+# Common property names
+#############################################################################
+PROPERTY_OBJECT_URI   = 'object-uri'
+PROPERTY_NAME         = 'name'
+PROPERTY_DESCRIPTION  = 'description'
+PROPERTY_LPAR_NAME    = 'lpar-name'
+PROPERTY_ID           = 'partition-id'
+PROPERTY_TYPE         = 'type'
+PROPERTY_ADAPTER_ID   = 'adapter-id'
+PROPERTY_ADAPTER_PORT = 'adapter-port'
+PROPERTY_PORT_INDEX   = 'port-index'
+
+
+
+#############################################################################
+# Command line option names
+#############################################################################
+OPTION_ADDR = '--addr'
+OPTION_PORT = '--port'
+OPTION_USER = '--user'
+OPTION_PASS = '--pass'
+OPTION_GET_PROPERTIES = '--get-properties'
+OPTION_CHECK_PROPERTIES = '--check-properties'
+OPTION_RUN_IF_APPLICABLE = '--run-if-applicable'
+OPTION_CAPABILITY = '--capability'
+OPTION_COMPONENT = '--component'
+OPTION_SCENARIO = '--scenario'
+OPTION_EXECUTION_TYPE = '--execution-type'
+#OPTION_MIN_VERSION = '--min-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+#OPTION_MAX_VERSION = '--max-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+OPTION_REQUIRED_VERSION = '--required-version'
+OPTION_API_VERSION = '--api-version'
+
+
+# Command line destination variable names
+OPTION_ADDR_DEST = 'host'
+OPTION_PORT_DEST = 'port'
+OPTION_USER_DEST = 'user'
+OPTION_PASS_DEST = 'pwd'
+
+#############################################################################
+# Command line default values
+#############################################################################
+DEFAULT_ADDR = '9.56.198.64'#'9.152.151.49'# '9.12.38.189' #'9.56.192.214' # '9.60.15.124'# ''9.56.192.214' #  '9.60.31.100'#'9.152.151.49' #'9.56.192.214' #'9.152.151.49' #'9.60.31.168'#'9.60.31.170'#'9.12.38.183'    # A dummy default, to force the user to specify --addr.  (R32 is no longer available)
+#DEFAULT_ADDR = '9.60.15.62'  #p15
+#DEFAULT_ADDR = '9.60.14.63'   #Ichabod
+#DEFAULT_ADDR = '9.56.196.93'
+DEFAULT_PORT = WSA_PORT_SSL
+WSA_DEFAULT_USERID   = 'ensadmin'
+WSA_DEFAULT_PASSWORD = 'password'
+
+#############################################################################
+# API feature strings.  These identify optional WS API features that may be
+# available on the HMC.  A list of available features is included in the 
+# response to the API Version and Logon requests.  The available features
+# are specified in files in the /console/data/webapi/features/ directory on
+# the HMC.
+#############################################################################
+FEATURE_GET_FILES_FROM_SE = 'internal-get-files-from-se' # Internal-use only API to fetch a specified file(s) from an SE
+
+#############################################################################
+# Response Validation
+#############################################################################
+
+STATUS       = 'status'
+CONTENT_TYPE = 'content-type'
+REQUIRED     = 'required'
+OPTIONAL     = 'optional'
+
+
+STATUS_200     = ( STATUS, 200 )
+STATUS_201     = ( STATUS, 201 )
+STATUS_202     = ( STATUS, 202 )
+STATUS_204     = ( STATUS, 204 )
+CONTENT_JSON   = ( CONTENT_TYPE, WSA_CONTENT_JSON )
+REQUIRED_EMPTY = ( REQUIRED, [] )
+OPTIONAL_EMPTY = ( OPTIONAL, [] )
+OPTIONAL_API1DOT4 = ( OPTIONAL, ['acceptable-avail-status','avail-policies','avail-status','element-groups','perf-policies','absolute-ziip-capping','workload-element-groups','shutdown-timeout', 'shutdown-timeout-source','gpmp-network-adapter'] )
+OPTIONAL_PASSWORD_EXPIRES = (OPTIONAL, ['password-expires'])
+
+
+# Logon and Version #########################################################
+
+__ver_required       = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'hmc-name', 'hmc-version' ] )
+__ver_optional       = ( OPTIONAL, [ 'api-features' ] )
+__logon_required     = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic' ] )
+__logon_required_job = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic','job-notification-topic' ] )
+__logon_optional     = ( OPTIONAL, [ 'password-expires', 'api-features' ] )
+
+# Validate response from 'Get Version' operation
+WSA_VERSION_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __ver_required, __ver_optional ] )
+
+# Validate response from 'Logon' operation
+WSA_LOGON_VALIDATE     = dict( [ STATUS_200, CONTENT_JSON, __logon_required, __logon_optional ] )
+WSA_LOGON_VALIDATE_JOB     = dict( [ STATUS_200, CONTENT_JSON, __logon_required_job, __logon_optional ] )
+
+# Ensembles #################################################################
+
+__list_ensembles_required = ( REQUIRED, [ 'ensembles' ] )
+
+__get_ensemble_required   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix' ] )
+
+__get_ensemble_optional   = ( OPTIONAL, [ 'alt-hmc-name',
+                                            'alt-hmc-ipv4-address',
+                                            'alt-hmc-ipv6-address',
+                                          'cpu-perf-mgmt-enabled-x-hyp',
+                                            'cpu-perf-mgmt-enabled-x-hyp',  #temporarily resumed by lv, for zHelixGA2 testing, but notice it is not running on lower version
+
+                                            'load-balancing-enabled',
+                                            'load-balancing-ip-addresses',
+                                            'load-balancing-port',
+                                            'max-nodes',
+                                            'max-cpc-nodes',
+                                            'max-zbx-nodes' ] )
+
+# Validate response from 'List Ensembles' operation
+WSA_LIST_ENSEMBLES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_ensembles_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each ensemble returned by 'List Ensembles' operation
+WSA_LIST_ENSEMBLE_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Validate response from 'Get Ensemble Properties' operation
+WSA_GET_ENSEMBLE_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required,   __get_ensemble_optional ] )
+
+
+# CPCs ######################################################################
+
+__list_cpcs_required = ( REQUIRED, [ 'cpcs' ] )
+
+# Validate response from 'List CPCs' operation
+WSA_LIST_CPCS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_cpcs_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each cpc returned by 'List CPCs' operation
+WSA_LIST_CPC_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Required keys for 'Get CPC Properties' operation
+__get_cpc_properties_required  = ( REQUIRED, [ 'name',
+                                               'object-uri',
+                                               'type',
+                                               'status' ] )
+
+# Validate response from 'Get CPC Properties' operation
+WSA_GET_CPC_PROPERTIES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __get_cpc_properties_required, OPTIONAL_EMPTY ] )
+
+
+# Virtualization Hosts ######################################################
+
+__list_virt_hosts_required = ( REQUIRED, [ 'virtualization-hosts' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOSTS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_hosts_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each virtualization host returned by 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOST_REQUIRED  = [ 'name', 'object-uri', 'status', 'type' ]
+
+# Wait period for all zvm tests
+WAIT_PERIOD_FOR_ZVM_TEST = 30 
+
+# These are the properties of a notification message that are not of type string.
+# When an incoming message is received, it is used to populate a dictionary of
+# key-value pairs.  Most of the properties are strings, but some are not and require
+# special handling.  Identify them here along with their datatype.  The addition of
+# a new type here will require corresponding changes where this list is processed.
+if Z9474_applied:
+    nonstring_message_properties = [
+                                    ('global-sequence-nr', 'long'), 
+                                    ('session-sequence-nr', 'long'),
+                                   ]
+else:
+    nonstring_message_properties = [
+                                   ]
+
+
+#added by lv start
+APA_TESTENV_CPC_UNDER_TEST = 'BLUECORE'
+
+__list_virt_servers_required = ( REQUIRED, [ 'virtual-servers' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_SERVERS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_servers_required, OPTIONAL_EMPTY ] )
+
+__list_virt_server_groups_required = ( REQUIRED, [ 'virtual-server-groups' ] )
+
+WSA_LIST_VIRT_SERVER_GROUPS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_server_groups_required, OPTIONAL_EMPTY ] )
+#added by lv end
+
+#adding the constants need for Ensemble properties for node properties
+__get_ensemble_required_nodes   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix',
+                                            'max-cpc-nodes',
+                                            'max-nodes',
+                                            'max-zbx-nodes' ] )
+
+
+WSA_GET_ENSEMBLE_VALIDATE_NODES   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required_nodes,   __get_ensemble_optional ] )
+WSA_DEFAULT_ZBX_NAME = 'ZBX2'
\ No newline at end of file
diff --git a/build/lib/partitionengine/utils/wsaglobals.py b/build/lib/partitionengine/utils/wsaglobals.py
new file mode 100644
index 0000000..65e6f61
--- /dev/null
+++ b/build/lib/partitionengine/utils/wsaglobals.py
@@ -0,0 +1,33 @@
+# Global variables for use by wsaconst and friends
+# 
+# Change history:
+# - 2014/07/17 L. Brocious      Initial version.  Added for "temporary object" support.
+# - 2015/02/16 L. Brocious      Add "temporary session" support.
+
+# This is the list of additional command line options (those defined in addition
+# to the "standard" options) defined for the current testcase execution.  This is
+# saved when the Session is created and is used only to allow successful re-parsing
+# of the command line when additional sessions are created during testcase execution
+# (typically during scenario setup and cleanup).
+global global_saved_additional_options
+global_saved_additional_options = None
+
+# The list of all registerd "temporary objects".  This list is managed by the 
+# register_temporary_object() and deregister_temporary_object() methods.  All
+# objects in this list are deleted by default during session shutdown.
+global global_temporary_objects_list
+global_temporary_objects_list = []
+
+# The list of all known "admin" sessions.  Such privileged sessions are typically needed
+# during scenario setup and cleanup.  For performance reasons, they are cached here and
+# reused if needed.  This list is managed by get_admin_session() and delete_all_admin_sessions().
+global global_admin_sessions
+global_admin_sessions = dict()
+
+
+# The list of all registerd "temporary sessions".  A temporary session is associated
+# with a temporary user and is intended for testcase scripts that perform authorization
+# testing.  All sessions in this list are deleted by default during shutdown of the
+# testcase's main session (via the standard session_shutdown(session) call before exit).
+global global_temporary_sessions
+global_temporary_sessions = []
diff --git a/build/lib/partitionengine/utils/wsautils.py b/build/lib/partitionengine/utils/wsautils.py
new file mode 100644
index 0000000..78800e3
--- /dev/null
+++ b/build/lib/partitionengine/utils/wsautils.py
@@ -0,0 +1,2905 @@
+#############################################################################
+#
+# Some utility classes and functions that may be useful for API Testing
+#
+# In order to import this module for use in testcases, set the PYTHONPATH
+# environment variable to point to the directory where the modules are
+# located.
+#
+# from wsaconst import *
+# from wsautils import *
+#
+# The call to os.getenv can be used to retrieve any environment variable, so
+# defining a variable that points to the Python common utilities directory
+# could be established in a test environment startup script, then referenced
+# above in the sys.path.append method call ...
+#
+#############################################################################
+
+from wsaconst import *
+import wsaglobals  # True global variables
+
+import httplib
+import pprint
+import json
+import optparse  # use argparse with Python 2.7.x ...
+from optparse import make_option
+from optparse import OptionGroup
+import string
+
+import sys
+import threading
+import time
+import traceback
+import types
+import ssl
+import os
+import re
+import __main__
+
+import logging
+import logging.config
+
+class progress_bar_loading(threading.Thread):
+
+    def run(self):
+            global stop
+            global kill
+            global progress_str
+            print progress_str + '....  ',
+            sys.stdout.flush()
+            i = 0
+            while stop != True:
+                    if (i % 4) == 0: 
+                        sys.stdout.write('\b/')
+                    elif (i % 4) == 1: 
+                        sys.stdout.write('\b-')
+                    elif (i % 4) == 2: 
+                        sys.stdout.write('\b\\')
+                    elif (i % 4) == 3: 
+                        sys.stdout.write('\b|')
+
+                    sys.stdout.flush()
+                    time.sleep(0.2)
+                    i += 1
+
+            if kill == True: 
+                print '\b\b\b\b ABORT!'
+            else: 
+                print '\b\b done!'
+            return
+        
+    def stop(self):
+        global stop
+        stop = True
+        
+    def configure(self,progress_string='Processing'):
+        global progress_str
+        progress_str = progress_string
+        global stop
+        stop = False
+        
+        
+
+progress_str = "Processing"
+kill = False      
+stop = False
+
+def initializeLogging():
+    directory='logs'
+    if not os.path.exists(directory):
+    	os.makedirs(directory)
+    logging.basicConfig(level=logging.DEBUG,
+                        format='%(asctime)s %(levelname)-8s %(message)s',
+                        datefmt='%a, %d %b %Y %H:%M:%S',
+                        filename='logs/console.log',
+                        filemode='w')
+
+
+
+
+
+WSA_UTILS_VERSION = "1.1"  # Current version of the API utilities
+
+#############################################################################
+# Determine which, if any, ActiveMQ clients are installed.  Set global flags
+# for later use.
+#############################################################################
+# Try STOMP
+try:
+    import stomp
+    stomp_present = True
+except ImportError:
+    # print "STOMPPY not installed or not supported"
+    stomp_present = False
+
+# Try PyActiveMQ
+try:
+    import pyactivemq
+    pyactivemq_present = True
+except ImportError:
+    # print "Pyactivemq not installed or not supported"
+    pyactivemq_present = False
+
+#############################################################################
+# Exceptions
+#############################################################################
+
+# General exception raised when api errors occur ...
+class ApiException(Exception) :
+
+    def __init__(self, text, response=None, keys=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text of exception
+        self.response = response  # Response object, if applicable
+        self.keys = keys  # Keys in error, only used by validate_response and
+                                 # validate_dictionary methods
+
+    def __str__(self) :
+
+        text = self.text
+        keys = self.keys
+        resp = self.response
+
+        result = []
+        result.append('ApiException caught ...\n\n')
+        result.append('MESSAGE :\n')
+        result.append(text)
+        result.append('\n')
+
+        if resp is None or not hasattr(resp, 'body'):
+            if keys is not None :
+                result.append(keys)
+        else :
+            body = resp.body
+            message = body[ 'message' ]     if 'message'     in body else None
+            status = body[ 'http-status' ] if 'http-status' in body else None
+            reason = body[ 'reason' ]      if 'reason'      in body else None
+            uri = body[ 'request-uri' ] if 'request-uri' in body else None
+            result.append('\nReturn Code = ')
+            if status is not None and reason is not None :
+                result.append(status)
+                result.append('.')
+                result.append(reason)
+            else :
+                result.append(str(resp.status))
+            result.append(' ')
+            result.append(resp.reason)
+            if message is not None :
+                result.append('\nResponse Message = ')
+                result.append(message)
+            if keys is not None :
+                result.append(' : ')
+                result.append(keys)
+            if uri is not None :
+                result.append('\nRequest URI = ')
+                result.append(uri)
+            result.append('\n\n')
+            result.append(resp)
+
+        result.append('\n\nStack Trace :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+
+        return ''.join([ str(s) for s in result ])
+
+
+#############################################################################
+#
+# Fatal exception ... used for non-API errors ...
+#
+# @parm text      - message text
+# @parm response  - response from HTTP request.  This can be either an
+#                   httplib.HTTPResponse or wsautils.Response object
+# @parm traceback - stack trace, usually taken from a caught exception
+#                   since it will differ from the stack trace created
+#                   when the ApiFatalException is created.
+# @parm request   - a wsautils.Request object representing the information
+#                   sent via an HTTP request.  Since testcase writers do not
+#                   generally have access to the HTTP request, this parameter
+#                   should be considered internal to wsautils only.
+# @parm other     - additional, relevant data provided by the testcase writer
+#                   that may help with diagnostics.
+#
+#############################################################################
+
+class ApiFatalException(Exception) :
+
+    def __init__(self, text, response=None, traceback=None, other=None, request=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text for exception
+        self.response = response
+        self.traceback = traceback
+        self.other = other
+        self.request = request
+
+    def __str__(self) :
+
+        result = []
+        result.append('ApiFatalException caught\n\n')
+        result.append('MESSAGE :\n')
+        result.append(self.text)
+        result.append('\n\n')
+
+        if self.response is None and self.request is not None :
+            result.append('REQUEST :\n')
+            result.append(self.request)
+            result.append('\n\n')
+
+        if self.response is not None :
+            result.append('RESPONSE :\n')
+            if isinstance(self.response, httplib.HTTPResponse) :
+                result.append(Response(self.response.status,
+                                         self.response.reason,
+                                         self.response.getheaders(),
+                                         self.response.read()))
+            else :
+                result.append(self.response)
+
+            result.append('\n\n')
+
+        # Append the stack trace created when raising this exception ...
+        result.append('TRACEBACK (most recent stack) :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+        result.append('\n')
+
+        # If present, this should be the stack trace created by the
+        # 'caught' exception that was wrapped inside the ApiFatalException
+        if self.traceback is not None :
+            result.append('TRACEBACK (from caught exception) :\n')
+            stack = traceback.format_tb(self.traceback)
+            result.append(''.join([ s for s in stack ]))
+            result.append('\n')
+
+        if self.other is not None :
+            result.append('OTHER :\n')
+            result.append(self.other)
+            result.append('\n')
+
+        return ''.join([ str(s) for s in result ]).strip()
+
+
+#############################################################################
+# Request Class
+#############################################################################
+
+class Request :
+
+    """This class encapsulates an HTTP request"""
+
+    def __init__(self, operation, uri, headers, body) :
+        self.operation = operation
+        self.uri = uri
+        self.headers = headers
+        self.body = body
+
+    def __str__(self) :
+        l = []
+        l.append('Request Operation : ')
+        l.append(str(self.operation))
+        l.append('\nRequest URI       : ')
+        l.append(str(self.uri))
+
+        l.append('\nRequest Headers   : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nRequest Body      : ')
+        if self.body == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(json.loads(self.body), sort_keys=True, indent=1, separators=(',', ':')))
+
+        return ''.join([ s for s in l ])
+
+
+#############################################################################
+#
+# Response Class
+#
+# This class models an HTTP response object.  The response headers will be
+# converted to a Python dictionary and the response body will be processed
+# through the JSON parser if the content-type header is 'application/json'.
+#
+# If the 'content-type' indicates the body is a json-formatted string and
+# the subsequent call to json.loads fails to parse the body, an
+# ApiFatalException with be raised.  The response will be added to the
+# exception, but the body will the unparse HTTP response body.
+#
+#############################################################################
+
+class Response :
+
+    """This class encapsulates an HTTP response"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    # Initialize a response
+    def __init__(self, status, reason, headers, body, request=None) :
+
+        # ##print '====================== begin body ====================================================='
+        # ##print body
+        # ##print '====================== end body ======================================================='
+        self.status = status  # HTTP response status
+        self.reason = reason  # HTTP response reason
+        self.headers = dict(headers)  # HTTP response headers
+        self.body = body  # HTTP response body
+        self.request = request  # HTTP request
+        self.bodyIsJSON = False  # Indicates whether the saved response body is a parsed JSON string
+
+        if body is not None and len(body) > 0 :
+            if self.headers[ CONTENT_TYPE ].startswith(WSA_CONTENT_JSON) :
+                try :
+                    # Parse the body and save the parsed version
+                    self.body = json.loads(body)
+                    self.bodyIsJSON = True  # Body is now a parsed JSON string
+                except :
+                    raise ApiFatalException(''.join([ str(s) for s in sys.exc_info()[1].args ]), response=self)
+            else :
+                self.body = body
+        else :
+            self.body = '{}'
+            self.bodyIsJSON = True  # Body is a parsed JSON string (an empty body)
+
+    # Print out a string representation of the response
+    def __str__(self) :
+        l = []
+        if self.request is not None :
+            l.append(self.request)
+            l.append('\n\n')
+        l.append('Response Status  : ')
+        l.append(self.status)
+        l.append('\nResponse Reason  : ')
+        l.append(self.reason)
+
+        l.append('\nResponse Headers : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nResponse Body    : ')
+        if self.bodyIsJSON:
+            l.append(json.dumps(self.body, sort_keys=True, indent=1, separators=(',', ':')))
+            if 'stack' in self.body:
+                l.append('\n\nstack (again, but in a more programmer-friendly format):\n')
+                l.append(self.body[ 'stack' ])
+        else:
+            l.append(str(self.body))
+
+
+        return ''.join([ str(s) for s in l ])
+
+
+#############################################################################
+#
+# Session Class
+#
+# This class represents a persistent HTTP connection to an HMC.  As such,
+# when the test code is finished with the HTTP connection, the close
+# method should be called to ensure resources are cleaned up.
+#
+# Currently, only JSON-formatted request bodies are supported.  Addtional
+# formats can be added in the future, as needed.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted for this Session.  See parse_standard_options()
+# for more details.  The option values may be referenced via the "opts" member
+# of the Session object.  For example, if an option was defined with dest='sr_name':
+#      name = session.opts.sr_name
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  See
+# parse_standard_options() for more details.  The command line arguments can
+# be referenced via the "args" member of the Session object, for example,
+# to access the first testcase-specific positional argument:
+#      property_name = session.args[session.arg_start_index + 0]
+#
+# Note that the __init__ method calls parse_standard_options(), which uses os._exit(rc)
+# in some cases rather than the more common sys.exit(rc).  See the prolog of
+# parse_standard_options for more details.
+#############################################################################
+
+class Session :
+
+    """This class supports connecting to an Ensemble HMC via HTTP"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    def __init__(self, host=None, port=None, user=None, pwd=None, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+        """Initialize an instance of the Session class"""
+        # Save any additional command line option definitions so that they're available
+        # when the command line is re-parsed if another session is established.
+        wsaglobals.global_saved_additional_options = additional_options
+#       print 'in Session init: global_saved_additional_options=%s' % wsaglobals.global_saved_additional_options
+        opts, args = parse_standard_options(additional_options, additional_arguments_usage_info)  # Read in command line arguments and options, if any ...
+        self.opts = opts  # Keep all parsed options for anyone that might need them
+        self.args = args  # Keep all parsed arguments for anyone that might need them
+        self.arg_start_index = 0  # The index of the first test-case specific argument, if any.
+                                    # There are currently no "standard" arguments, so all arguments
+                                    # are, in effect, test-case specific; thus this index is 0.
+
+        # Save values from the command line or our caller, as appropriate
+        self.__host = opts.host if host is None else host
+        self.__port = opts.port if port is None else port
+        self.__user = opts.user if user is None else user
+        self.__pass = opts.pwd  if pwd  is None else pwd
+        self.__amq_client = opts.amq_client if amq_client is None else amq_client
+        self.__amq_socket_type = opts.amq_socket_type if amq_socket_type is None else amq_socket_type
+        self.__api_version_override = opts.api_version_override
+        self.__get_properties = opts.get_properties
+        self.__check_properties = opts.check_properties
+        self.__run_if_applicable = opts.run_if_applicable
+        self.__required_version = opts.required_version
+        self.__required_capabilities = opts.required_capabilities
+        self.__required_components = opts.required_components
+        self.__required_scenario_types = opts.required_scenario_types
+        self.__required_execution_types = opts.required_execution_types
+
+        self.__args = args
+
+        self.__connection = None  # Persistent HTTP connection
+        self.__session = None  # Session id
+        self.__topic = None  # Topic id for ActiveMQ notifications
+                                   #
+        self.__api_version = None  # WSA API version supported by HMC
+        self.__hmc_name = None  # Name of the connected HMC
+        self.__hmc_version = None  # Version of the connected HMC
+        self.__jobtopic = None  # Topic id for ActiveMQ JOB Notifications
+        self.__api_features = None  # List of available WS API features
+                                   #
+        self.__consumer = None  # ActiveMQ notification consumer
+        self.__callback = None  # Callback method for notification messages
+
+
+        #########################################################################
+        # If no ActiveMQ client was specified, choose one based on what's installed
+        # and available if possible.  Then, if no SSL preference was specified,
+        # select a sensible one based on the ActiveMQ client.  Then, set the ActiveMQ
+        # port to the appropriate port number.
+        #########################################################################
+        # Determine the client type
+        if self.__amq_client is None:
+            if stomp_present == True:  # STOMP is installed; use it
+                self.__amq_client = AMQ_CLIENT_STOMP
+            elif pyactivemq_present == True:  # No STOMP, but PyActiveMQ is installed; use it
+                self.__amq_client = AMQ_CLIENT_PYACTIVEMQ
+            else:  # None installed, so just go with the default here; errors will be surfaced later if an AMQ client is actually required.
+                self.__amq_client = WSA_DEFAULT_AMQ_CLIENT
+
+        # Use PyActiveMQ ActiveMQ client
+        if self.__amq_client == AMQ_CLIENT_PYACTIVEMQ:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_NON_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:  # Sensible?  Current versions of pyactivemq don't support SSL
+                self.__amq_port = WSA_ACTIVEMQ_PORT_SSL
+            else:
+                self.__amq_port = WSA_ACTIVEMQ_PORT_NON_SSL
+
+        # Use STOMP ActiveMQ client
+        else:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:
+                self.__amq_port = WSA_STOMP_PORT_SSL
+            else:
+                self.__amq_port = WSA_STOMP_PORT_NON_SSL
+
+#       print "pyactivemq_present = " + str(pyactivemq_present)
+#       print "stomp_present = " + str(stomp_present)
+#       print "leaving parse_standard_options() with"
+#       print "\t self.__amq_client=" + str(self.__amq_client)
+#       print "\t self.__amq_socket_type=" + str(self.__amq_socket_type)
+#       print "\t self.__amq_port=" + str(self.__amq_port)
+#       print "\t self.__get_properties=" + str(self.__get_properties)
+
+
+    #########################################################################
+    # Open connection to HMC
+    #########################################################################
+
+    def open(self) :
+
+        """Create a persistent HTTP connection to an HMC, then logon"""
+
+        body = json.dumps({ 'userid':self.__user, 'password':self.__pass })
+
+        # Issue the Logon request
+        response = self.__executeRequest(WSA_COMMAND_POST, WSA_URI_LOGON, body, WSA_CONTENT_JSON)
+
+        # Check the status code to be sure logon succeeded before trying to validate
+        # the response details.  For example, the response body might not even be a dictionary.
+        if response.status != 200:
+            raise ApiFatalException('Logon failed', response)
+
+
+#       print '****************'
+#       print response.request
+#       print '****************'
+#       print response.request.headers
+#       print '****************'
+#       print response.headers
+#       print '****************'
+
+
+
+        # Parse and validate the response to the Logon request.  Save info for later use.
+
+        if 'job-notification-topic' in response.body.keys():
+            self.__jobtopic = str(response.body[ 'job-notification-topic' ])
+            validate_response(response, WSA_LOGON_VALIDATE_JOB)
+        else :
+            validate_response(response, WSA_LOGON_VALIDATE)
+
+        self.__session = str(response.body[ 'api-session'        ])
+        self.__topic = str(response.body[ 'notification-topic' ])
+
+        if 'api-features' in response.body.keys():
+            self.__api_features = response.body[ 'api-features' ]  # List of strings
+        
+        # Now issue an API Version request and validate the response
+        response = self.get(WSA_URI_VERSION)
+        validate_response(response, WSA_VERSION_VALIDATE)
+
+        # Parse and save this session's version information
+        ver = []
+        ver.append(str(response.body[ 'api-major-version' ]))
+        ver.append('.')
+        ver.append(str(response.body[ 'api-minor-version' ]))
+
+        self.__api_version = "".join(ver)
+        self.__hmc_name = response.body[ 'hmc-name' ]
+        self.__hmc_version = response.body[ 'hmc-version' ]
+
+        # print "Topic ID: \t%s"     % self.__topic
+        # print "Job Topic ID: \t%s" % self.__jobtopic
+        # print "API version: \t%s"  % self.__api_version
+        # print "API features: \t%s" % self.__api_features
+
+        return self.__connection
+
+
+    #########################################################################
+    # Close connection to HMC
+    #########################################################################
+
+    def close(self) :
+        """Logoff from the HMC, then close the HTTP connection"""
+
+# # TODO : Close ActiveMQ consumer, too?
+
+        if self.__connection is not None :
+            try :
+                # Logoff active session, if needed ...
+                if self.__session is not None :
+                    response = self.delete(WSA_URI_LOGOFF)
+                    if response.status != 204 :
+                        raise ApiFatalException('Unexpected response status during logoff', response=response)
+            finally :
+                try :
+                   # Close the HTTP session
+                   self.__connection.close()
+                finally :
+                    if self.__consumer is not None and self.__consumer.isRunning() :
+                        self.__consumer.stop()
+
+
+    #########################################################################
+    # Get
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def get(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP GET operation"""
+        return self.__executeRequest(WSA_COMMAND_GET, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Put
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def put(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP PUT operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_PUT, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Post
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def post(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP POST operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_POST, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Delete
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def delete(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP DELETE operation"""
+        return self.__executeRequest(WSA_COMMAND_DELETE, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Host
+    #########################################################################
+
+    def host(self) :
+        """Return the host"""
+        return self.__host
+
+
+    #########################################################################
+    # Port
+    #########################################################################
+
+    def port(self) :
+        """Return the port"""
+        return self.__port
+
+
+    #########################################################################
+    # Userid
+    #########################################################################
+
+    def userid(self) :
+        """Return the userid"""
+        return self.__user
+
+
+    #########################################################################
+    # Password
+    #########################################################################
+
+    def password(self) :
+        """Return the password"""
+        return self.__pass
+
+
+    #########################################################################
+    # Session
+    #########################################################################
+
+    def session(self) :
+        """Return the active session identifier"""
+        return self.__session
+
+
+    #########################################################################
+    # Topic and job topic
+    #########################################################################
+
+    def topic(self) :
+        """Return the active topic identifier"""
+        return self.__topic
+
+
+    def jobtopic(self) :
+        """Return the active job topic identifier"""
+        return self.__jobtopic
+
+
+    #########################################################################
+    # Values related to the FVT regression tools
+    #########################################################################
+
+    def api_version_override(self) :
+        """Return the API version value from the command line"""
+        return self.__api_version_override
+
+    def get_properties(self) :
+        """Return the OPTION_GET_PROPERTIES setting"""
+        return self.__get_properties
+    def check_properties(self) :
+        """Return the OPTION_CHECK_PROPERTIES setting"""
+        return self.__check_properties
+    def run_if_applicable(self) :
+        """Return the OPTION_RUN_IF_APPLICABLE setting"""
+        return self.__run_if_applicable
+
+    def required_version(self) :
+        """Return the testcase required_version"""
+        return self.__required_version
+
+    def required_capabilities(self) :
+        """Return the testcase required_capabilities"""
+        return self.__required_capabilities
+    def required_components(self) :
+        """Return the testcase required_components"""
+        return self.__required_components
+    def required_scenario_types(self) :
+        """Return the testcase required_scenario_types"""
+        return self.__required_scenario_types
+    def required_execution_types(self) :
+        """Return the testcase required_execution_types"""
+        return self.__required_execution_types
+
+
+    #########################################################################
+    # API Version
+    #########################################################################
+
+    def api_version(self) :
+        """Return the reported API version supported by the HMC"""
+        return self.__api_version
+
+
+    #########################################################################
+    # API Features
+    #########################################################################
+
+    def api_features(self) :
+        """Return the reported API features supported by the HMC"""
+        return self.__api_features
+
+
+    #########################################################################
+    # HMC Name
+    #########################################################################
+
+    def hmc_name(self) :
+        """Return the name of the connected HMC"""
+        return self.__hmc_name
+
+
+    #########################################################################
+    # HMC Version
+    #########################################################################
+
+    def hmc_version(self) :
+        """Return the version of the connected HMC"""
+        return self.__hmc_version
+
+
+    #########################################################################
+    # Register and start receiving general notification messages
+    #########################################################################
+
+    def start_receiving_messages(self, callback=None) :
+        # print "in start_receiving_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__topic, callback)  # Start receiving messages for the general notification topic
+
+
+    #########################################################################
+    # Register and start receiving job notification messages
+    #########################################################################
+
+    def start_receiving_job_messages(self, callback=None) :
+        # print "in start_receiving_job_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__jobtopic, callback)  # Start receiving messages for the job notification topic
+
+
+    #########################################################################
+    # Register and start receiving audit log notification messages
+    #########################################################################
+
+    def start_receiving_audit_messages(self, callback=None) :
+        # print "in start_receiving_audit_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'audit')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the audit notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the audit notification topic
+
+
+    #########################################################################
+    # Register and start receiving security log notification messages
+    #########################################################################
+
+    def start_receiving_security_messages(self, callback=None) :
+        # print "in start_receiving_security_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'security')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the security notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the security notification topic
+
+
+    #########################################################################
+    # Register and start receiving messages for the specified topic
+    #########################################################################
+
+    def start_message_consumer(self, topic, callback=None) :
+        try :
+            # print "in start_message_consumer(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+
+            if (self.__amq_client == AMQ_CLIENT_PYACTIVEMQ):  # Use PyActiveMQ ActiveMQ consumer.  It supports only non-SSL connections
+                if pyactivemq_present == False:
+                    raise ApiFatalException("Cannot use PyActiveMQ ActiveMQ client - pyactivemq module is not installed")
+                self.__consumer = PyActiveMQ_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+            else:  # Use STOMP ActiveMQ consumer.  It supports both SSL and non-SSL connections
+                if stomp_present == False:
+                    raise ApiFatalException("Cannot use STOMP ActiveMQ client - stomp module is not installed")
+                self.__consumer = STOMP_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+
+            # print "About to start() the message consumer"
+            self.__consumer.start()
+        except :
+            raise ApiFatalException(sys.exc_info()[1].args)
+
+
+
+    #########################################################################
+    # Stop receiving notification messages
+    #########################################################################
+
+    def stop_receiving_messages(self) :
+        self.__consumer.stop()
+
+
+    #########################################################################
+    # Determine whether any notification messages have been received
+    #########################################################################
+
+    def has_messages(self) :
+        return self.__consumer.has_messages()
+
+    #########################################################################
+    # Retrieve existing notification messages ... empty message queue
+    #########################################################################
+
+    def get_received_messages(self) :
+        return self.__consumer.get_messages()
+
+
+    #########################################################################
+    # Retrieve raw notification messages ... empty message queue
+    # Should be used for debug only ...
+    #########################################################################
+
+    def get_raw_messages(self) :
+        return self.__consumer.get_raw_messages()
+
+
+    #########################################################################
+    #
+    # __executeRequest (package private method)
+    #
+    # This method is private to the class and NOT called directly.
+    #
+    # Currently, the supported content types are :
+    #
+    #    None and 'application/json'
+    #
+    # Specify return_full_response=False to prevent this method from reading
+    # response body and closing the HTTP(S) connection.  This allows the
+    # caller to read the response as it sees fit, for example, one byte at a
+    # time.  In this case, the caller is responsible for closing the HTTP(S)
+    # connection.  The read_response_streamed method in this class can be used
+    # to read the response body one byte at a time and then close the connection.
+    #
+    #########################################################################
+
+    def __executeRequest(self, operation, uri, body, content, headers=None, return_full_response=True) :
+
+        """Execute an HTTP request"""
+
+        request = None
+        response = None
+
+        try :
+
+            # Build up the default HTTP headers
+            if headers is None :
+                requestHeaders = {}
+                requestHeaders[ 'Accept' ] = '*/*'
+                if content in WSA_SUPPORTED_CONTENT :
+                    requestHeaders[ WSA_HEADER_CONTENT ] = content
+                if body is not None :
+                    requestHeaders[ WSA_HEADER_CONTENT_LENGTH ] = len(body)
+                if self.__session is not None :
+                    requestHeaders[ WSA_HEADER_RQ_SESSION ] = self.__session
+            else :
+                requestHeaders = headers.copy()
+
+            request = Request(operation, uri, requestHeaders, body)
+
+            # **MHB**
+            # Persistent connections, both SSL and non-SSL, are being closed after sitting
+            # idle for 15-30 seconds.  As a workaround, create a new HTTP connection for
+            # each request until a solution can be found ...
+            if self.__port == WSA_PORT_SSL :
+                # Beginning with Python 2.7.9, SSL connections are more secure and require a valid
+                # X509 certificate signed by a trusted CA.  Since the HMC uses a self-signed certificate,
+                # we revert to previous Python behavior by explicitly requesting an unverified context.
+                # This is generally not advisable, for obvious reasons, but it is acceptable in the
+                # development and test environments in which these API test utilities are intended to
+                # be used.
+                if sys.hexversion < 0x020709F0:  # Prior to 2.7.9; use default behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port)
+                else:  # 2.7.9 or later; specifically request prior behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port, context=ssl._create_unverified_context())
+                    print ""
+                    
+            else :
+                self.__connection = httplib.HTTPConnection(self.__host, self.__port)
+
+            try :
+                self.__connection.request(operation, uri, body, requestHeaders)
+                response = self.__connection.getresponse()
+                # If we're returning the full Response object, then read the response body and construct a Response object;
+                # otherwise, we just return the response from the HTTP(S)Connection object.
+                if return_full_response is True :
+                    result = Response(response.status, response.reason, response.getheaders(), response.read(), request)
+                else :
+                    result = response
+            finally :
+                # If we're returning the full Response object, then we've already read the response and can close out HTTP(S) connection.
+                # Otherwise, leave it open for later reading by, for example, read_response_streamed().  Callers that specify
+                # return_full_response=False are responsible for closing this connection.
+                if return_full_response is True :
+                    self.__connection.close()
+
+        except (ApiFatalException, ApiFatalException) :
+            raise
+        except :
+            text = self.buildExceptionMessage()
+            raise ApiFatalException(text, response=response, traceback=sys.exc_info()[2])
+
+        return result
+
+
+    def buildExceptionMessage(self) :
+        name = sys.exc_info()[0]
+        args = []
+        for arg in sys.exc_info()[1].args :
+            if len(str(arg)) > 0 :
+                args.append(arg)
+                args.append(' ')
+        text = ''.join([ str(s) for s in args ]).strip()
+        return str(name) + ' ' + text
+
+
+    #########################################################################
+    #
+    # read_response_streamed method
+    #
+    # Use this method to read the response to a request that was issued via
+    # __executeRequest with return_full_response==False.  This method will
+    # read the response one byte at a time and then close the connection.
+    #
+    # The response argument is the response as returned from
+    # self.__connection.getresponse().
+    #
+    #########################################################################
+
+    def read_response_streamed(self, response):
+        try :
+            print "\nAbout to read the response one byte at a time...\n"
+            responseString = ""
+            chunk = response.read(1)
+            while (chunk != ""):
+                responseString += chunk
+                sys.stdout.write(chunk)
+                chunk = response.read(1)
+
+        finally :
+            self.__connection.close()
+
+        return responseString
+
+
+#############################################################################
+#
+# Class PyActiveMQ_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a PyActiveMQ client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class PyActiveMQ_Consumer() :
+    # Only define the internals of this class if PyActiveMQ is installed, due to references to the pyactivemq module
+    if (pyactivemq_present == True):
+        """Private class ... do not use directly"""
+
+        class __MessageListener(pyactivemq.MessageListener):
+
+            def __init__(self, topic, callback):
+                pyactivemq.MessageListener.__init__(self)
+                self.topic = topic
+                self.callback = callback
+
+            def onMessage(self, message):
+                try :
+                    self.callback(self.topic, message)
+                except :
+                    print traceback.print_exc()
+
+
+        def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+            """This is the constructor ... all parameters required, exception callback"""
+
+            self.messageLock = threading.Lock()  # Control access to message queue
+
+            self.running = False
+
+            self.host = host
+            self.port = port
+            self.username = username
+            self.password = password
+            self.topic = topic
+            self.use_ssl = use_ssl
+
+            if callback is None :
+                self.callback = self.__callback
+                self.messages = []
+                self.raw_messages = []
+            else :
+                self.callback = callback
+
+            self.url = 'tcp://' + str(self.host) + ':' + str(self.port)
+
+            self.factory = pyactivemq.ActiveMQConnectionFactory(self.url)
+            self.factory.username = self.username;
+            self.factory.password = self.password;
+            print("Creating PyActiveMQ consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+            self.connection = self.factory.createConnection()
+            self.session = self.connection.createSession()
+            self.consumer = self.session.createConsumer(self.session.createTopic(self.topic), "")
+            self.listener = self.__MessageListener(self.topic, self.callback)
+            self.consumer.messageListener = self.listener
+
+
+        def start(self) :
+            """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+            self.connection.start()
+
+
+            self.running = True
+
+        def stop(self) :
+            """Stop consuming messages from the ActiveMQ server"""
+            time.sleep(2)
+
+            self.connection.close()
+            self.running = False
+
+        def isRunning(self) :
+            """Connection still active?"""
+            return self.running
+
+        def has_messages(self) :
+            """Test whether any messages have been received"""
+            self.messageLock.acquire()
+            try :
+                return len(self.messages) > 0
+            finally :
+                self.messageLock.release()
+
+        def get_messages(self) :
+            """Get the current list of received messages ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.messages)
+                self.messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def get_raw_messages(self) :
+            """Get the list of raw messges received so far ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.raw_messages)
+                self.raw_messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def __toDictionary(self, message) :
+            """Convert a raw message to a dictionary"""
+            if message is None : return None
+
+            result = {}
+            result[ 'expiration' ] = message.expiration
+            result[ 'timestamp'  ] = message.timestamp
+            result[ 'text'       ] = message.text if len(message.text) > 0 else None
+
+            # Fetch each property in the message and put it into the dictionary.  Treat each
+            # property as a string, unless specifically identified otherwise.  Use the 
+            # appropriate getXXXProperty() method to fetch the value from the raw message.
+            for property in message.propertyNames :
+                string_type = True  # Assume a standard string type, not handled yet
+                # See if this is one of the non-string properties
+                for property_name, property_type in nonstring_message_properties:
+                    if not string_type:  # Known not to be a string; already handled
+                        break
+                    if property == property_name:  # Some non-string type; handle specially
+                        # ##print "Fetching " + property_name + " as type " + property_type
+                        if property_type == 'long':
+                            try:
+                                result[ property ] = message.getLongProperty(property)
+                                string_type = False  # Non-string type; handled
+                            except :  # Failed conversion; ignore and leave it as a string...
+                                print "\n********** error fetching '" + property + "' property as type " + property_type + " from incoming notification message! ***********"
+                                print "Treating it as type string\n"
+                                traceback.print_exc()
+                                # (Allow this code path to continue and attempt to fetch it as a string...)
+                if string_type:
+                    try :
+                        # ##print "Fetching " + property_name + " as type string"
+                        result[ property ] = message.getStringProperty(property)
+                    except :
+                        print "\n********** error fetching '" + property + "' property as type string from incoming notification message! ***********\n"
+                        traceback.print_exc()
+                        result[ property ] = None
+
+                # ##print "property name: " + property + "; value=" + str(result[property]) + "; type=" + str(type(result[property]))
+
+            return result
+
+        def __callback(self, topic, message) :
+            """The default callback method to receive incoming messages"""
+            self.messageLock.acquire()
+            try :
+                if message is not None :
+                    self.messages.append(self.__toDictionary(message))
+                    self.raw_messages.append(message)
+            finally :
+                self.messageLock.release()
+
+        def __execute(self, connection) :
+            """Start listening for messages - deprecated"""
+            try :
+                self.running = True
+                connection.start()
+                while self.running :
+                    time.sleep(1)
+            finally :
+                self.running = False
+                connection.close()
+
+
+#############################################################################
+#
+# Class STOMP_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a STOMP client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class STOMP_Consumer() :
+    """Private class ... do not use directly"""
+
+    class __STOMPInternalListener():
+
+            def __init__(self, topic, callback):
+                self.callback = callback
+                self.topic = topic
+
+            def on_connecting(self, host_and_port):
+
+                print "Started connecting to broker..."
+
+            def on_connected(self, headers, message):
+
+                print "Now connected to broker: %s" % message
+
+            def on_disconnected(self, headers, message):
+
+                print "No longer connected to broker: %s" % message
+
+            def on_error(self, headers, message):
+
+                print "Received an error: %s" % message
+
+            def on_message(self, headers, message):
+                # This method processes an HMC APi notificaiton message which
+                # always have header fields, and may optionally contain a body
+                # that is a string containing a JSON object.
+
+                try :
+                    # print "inside on_message block"
+                    # print "H is", headers
+                    # print "M is",message
+                    
+                    # If this is a Property Change notification or a Status Change notification, put the body into
+                    # a header named 'text'.  That's where PyActiveMQ puts it, and this hides that difference from
+                    # other places in our Test utilities and the testcase programs themselves.
+                    if (headers['notification-type'] == 'property-change' or headers['notification-type'] == 'status-change' or headers['notification-type'] == 'log-entry'):
+                        headers['text'] = message
+
+                    self.callback(self.topic, headers)
+                except :
+                    print traceback.print_exc()
+
+
+
+
+    def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+        """This is the constructor ... all parameters required, exception callback"""
+
+        self.messageLock = threading.Lock()  # Control access to message queue
+
+        self.running = False
+
+        self.host = host
+        self.port = port
+        self.username = username
+        self.password = password
+        self.topic = topic
+        self.use_ssl = use_ssl
+
+        if callback is None :
+            self.callback = self.__callback
+            self.messages = []
+            self.raw_messages = []
+        else :
+            self.callback = callback
+
+        self._dest = "/topic/" + self.topic
+        print("Creating STOMP consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+        self.connection = stomp.Connection([(self.host, self.port)], self.username,
+                                            self.password, use_ssl=self.use_ssl,
+                                            ssl_version=ssl.PROTOCOL_SSLv23)
+
+        self._internal_listener = self.__STOMPInternalListener(self.topic, self.callback)
+        self.connection.set_listener('', self._internal_listener)
+
+
+    def start(self) :
+        """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+        self.connection.start()
+        self.connection.connect(wait=True)
+        time.sleep(10)
+        self.connection.subscribe(destination=self._dest, ack="auto")
+
+        self.running = True
+
+    def stop(self) :
+        """Stop consuming messages from the ActiveMQ server"""
+        time.sleep(2)
+
+        self.connection.stop()
+        self.running = False
+
+    def isRunning(self) :
+        """Connection still active?"""
+        return self.running
+
+    def has_messages(self) :
+        """Test whether any messages have been received"""
+        self.messageLock.acquire()
+        try :
+            return len(self.messages) > 0
+        finally :
+            self.messageLock.release()
+
+    def get_messages(self) :
+        """Get the current list of received messages ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.messages)
+            self.messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def get_raw_messages(self) :
+        """Get the list of raw messges received so far ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.raw_messages)
+            self.raw_messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def __toDictionary(self, message) :
+        """Convert a raw message to a dictionary"""
+        if message is None : return None
+        result = message
+        return result
+
+    def __callback(self, topic, message) :
+        """The default callback method to receive incoming messages"""
+        self.messageLock.acquire()
+        try :
+            if message is not None :
+
+                # Regardless of the type specified by the HMC code that builds the JMS message, 
+                # the properties always seem to arrive as strings.  Convert the non-string
+                # properties to their proper type here.
+                for property_name, property_type in nonstring_message_properties:
+                    try:
+                        if property_type == 'long':
+                            # ##print "Converting " + property_name + " to " + property_type
+                            message[property_name] = long(message[property_name])
+                    except ValueError:  # Failed conversion; ignore and leave it as a string...
+                        print "\n********** error converting '" + property_name + "' property to type " + property_type + " from incoming notification message! ***********"
+                        print "Leaving it as type " + str(type(message[property_name])) + "\n"
+
+                self.messages.append(self.__toDictionary(message))
+                self.raw_messages.append(message)
+        finally :
+            self.messageLock.release()
+
+    def __execute(self, connection) :
+        """Start listening for messages - deprecated"""
+        try :
+            self.running = True
+            connection.start()
+            while self.running :
+                time.sleep(1)
+        finally :
+            self.running = False
+            connection.close()
+
+#############################################################################
+# Miscellaneous Functions
+#############################################################################
+
+#############################################################################
+#
+# Function parse_standard_options
+#
+# Parses command line options
+#
+# Standard options available to all testcases are :
+#
+#    --addr = IP address of the target HMC
+#    --port = Port number to connect to on the target HMC
+#    --user = Logon userid to use on the target HMC
+#    --pass = Logon password to use on the target HMC
+#    --amq-client = ActiveMQ client to use for notification messages
+#    --amq-socket-type = Type of socket to use for ActiveMQ messages; either ssl or non-ssl
+#    --api-version = Version of the API being tested.  Use this to override the version 
+#                    information reported by the API framework.
+#    
+#    These options are provided primarily to support the FVT regression testing tools.  They are
+#    available to all testcases:
+#    --get-properties = a request to return the testcase's properties
+#    --check-properties = a request to check the testcase's properties against the specified required properties
+#    --run-if-applicable = a request to check the testcase's properties and then run the testcase if all requirements are met
+#    --min-version = required minimum version
+#    --max-version = required maximum version
+#    --capability = required capability; may be specified multiple times
+#    --component = required component; may be specified multiple times
+#    --scenario  = required scenario type; may be specified multiple times
+#    --execution-type = required execution type; may be specified multiple times
+#
+# NOTE : Currently, if ommitted, these values will default to :
+#
+#    Logon to R32 HMC ( 9.60.15.48 ) on the default WSA SSL port with user ensadmin
+#    An ActiveMQ client is chosen based on what is installed; STOMP over SSL is preferred.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted.  It is a list of Option objects created via
+# the make_option() function in the optparse library.  For example:
+#     additional_opts = [
+#         make_option("--srname", dest="storage_resource_name", type="string", default="tempSR", help='The name of the storage resource to be created.  Default is %default.'),
+#         make_option("--count", dest="iteration_count", metavar="COUNT", type="int", help='The number of iterations to run'),
+#         make_option("--treat", dest="dessert", type="choice", choices=["candy", "soda", "fudge"], help='Your dessert choice')
+#         make_option("--verbose", "-v", dest="verbose", action="store_true", default=False, help="Specify this option to get lots of output.  Default is %default."),
+#         ]
+#         
+# Those option definitions are then passed to session_startup():
+#       # Create a session and parse the command line, including our additional options
+#       session = session_startup(additional_options=additional_opts)
+#
+# Note that it is permissible to override any of the standard options by specifying them in additional_options.
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  For example,
+#      my_args_usage_info = "property_name timeout_seconds"
+#
+# To see the usage and help information on the command line, issue:
+#         "<script_name> -h" or "<script_name> --help"
+#               
+# Note that this method uses os._exit(rc) in some cases rather than the more
+# common sys.exit(rc).  os._exit(rc) makes a quick exit from the testcase
+# script without raising any exception, including SystemExit.  This makes
+# for a cleaner exit sequence in these special situations.  Note, however,
+# that it also bypasses any finally block; this should be OK, since no
+# session has been created yet and there is most likely no resource cleanup
+# necessary at this point in testcase execution.
+#
+#############################################################################
+
+def parse_standard_options(additional_options=None, additional_arguments_usage_info=None) :
+    # Define the standard options
+    option_list = [
+       make_option(OPTION_ADDR, dest='host', type='string', default=DEFAULT_ADDR,
+           help='The IP address or hostname of the target HMC.  Default=%default'),
+       make_option(OPTION_PORT, dest='port', type='int', default=DEFAULT_PORT,
+           help='The TCP/IP port number on which to connect to the target HMC for Web Services API requests.  Default=%default'),
+       make_option(OPTION_USER, dest=OPTION_USER_DEST, type='string', default=WSA_DEFAULT_USERID,
+           help='The HMC userid to use for the API request.  Default=%default'),
+       make_option(OPTION_PASS, dest=OPTION_PASS_DEST, type='string', default=WSA_DEFAULT_PASSWORD,
+           help='The login password for the HMC userid to use for the API request.  Default is the default user\'s standard password.'),
+       make_option('--amq-client', dest='amq_client', type='choice', choices=[AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP],
+           help='ActiveMQ client: %s or %s.  Default is %s unless it is not installed and %s is installed.'
+               % (AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP, AMQ_CLIENT_STOMP, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option('--amq-socket-type', dest='amq_socket_type', type='choice', choices=[SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL],
+           help='ActiveMQ socket type: %s or %s.  Default depends on the ActiveMQ client: %s for %s; %s for %s.'
+               % (SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL, SOCKET_TYPE_SSL, AMQ_CLIENT_STOMP, SOCKET_TYPE_NON_SSL, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option(OPTION_API_VERSION, dest='api_version_override', metavar='API_VERSION', type='string',
+           help='The version information for the API implementation being tested.  Specify this to override the version level reported by the API framework on the target HMC.'),
+       # for force tags
+       make_option("--include", type='string', default=""),
+       make_option("--exclude", type='string', default=""),
+       make_option("--variablefile", type='string', default=""),
+       make_option("--outputdir", type='string', default=""),
+        
+       ]
+
+    # Define our usage statement
+    usage_info = "%prog [options]"  # There are no standard command line arguments, only options
+
+    # Add any additional testcase-specific options
+    if additional_options is not None:
+        option_list.extend(additional_options)
+    
+
+    # Add any additional testcase-specific usage information
+    if additional_arguments_usage_info is not None:
+        usage_info += " " + additional_arguments_usage_info
+    # Create a parser with the options
+    parser = optparse.OptionParser(option_list=option_list, usage=usage_info, conflict_handler="resolve")
+
+    # Define a group of options intended for use by the FVT regression bucket and then add the specific option definitions to the group.
+    # This group will appear separate from the other command line options in the usage and help information.
+    FVT_option_group = OptionGroup(parser, 'Function Verification Test (FVT) regression test options', 'These options are intended primarily for use by the FVT regression tools.'
+        + '  Only one of %s, %s or %s may be specified.' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        + '  Some options may each be specified more than once.  If so, a testcase need only support one of the specified values in order to satisfy that requirement.'
+        + '  These options are: %s, %s, %s and %s' % (OPTION_CAPABILITY, OPTION_COMPONENT, OPTION_SCENARIO, OPTION_EXECUTION_TYPE))
+    
+    # The type of operation to perform.  Only 1 of these should be specified.
+    FVT_option_group.add_option(make_option(OPTION_GET_PROPERTIES, dest='get_properties', action='store_true', default=False,
+        help='Denotes a request to return the testcase properties.  These are defined by the %s variable in the testcase source code.' % TESTCASE_PROPERTIES_VARIABLE_NAME))
+    FVT_option_group.add_option(make_option(OPTION_CHECK_PROPERTIES, dest='check_properties', action='store_true', default=False,
+        help='Denotes a request to check testcase properties against the required testcase properties specified on the command line.'))
+    FVT_option_group.add_option(make_option(OPTION_RUN_IF_APPLICABLE, dest='run_if_applicable', metavar='APPLICABLE', action='store_true', default=False,
+        help='Denotes a request to check properties as if %s were specified and then, if the testcase meets the specified requirements, actually execute the testcase.' % OPTION_CHECK_PROPERTIES))
+    # Required API version
+    FVT_option_group.add_option(make_option(OPTION_REQUIRED_VERSION, dest='required_version', metavar='VERSION', type='choice', choices=TC_API_VERSION_LIST,
+        help='A required testcase property: the required API version.  The testcase must support this API level.'
+             '  That is, this level must be between the testcase\'s supported minimum and maximum levels, inclusive.  Valid values are: %s' % TC_API_VERSION_LIST))
+    # Testcase properties that can have multiple values.  If a property is specified more than once on the command line, a testcase is
+    # considered to meet that criterion if it includes at least one of the specified values.  That is, they are logically OR'd together.
+    # Then the different properties are AND'd together.
+    FVT_option_group.add_option(make_option(OPTION_CAPABILITY, dest='required_capabilities', metavar='CAPABILITY', action='append', choices=TC_CAPABILITY_LIST,
+        help='A required testcase property: a capability.  May be specified multiple times.  Valid values are: %s' % TC_CAPABILITY_LIST))
+    FVT_option_group.add_option(make_option(OPTION_COMPONENT, dest='required_components', metavar='COMPONENT', action='append', choices=TC_COMPONENT_LIST,
+        help='A required testcase property: a component.  May be specified multiple times.  Valid values are: %s' % TC_COMPONENT_LIST))
+    FVT_option_group.add_option(make_option(OPTION_SCENARIO, dest='required_scenario_types', metavar='SCENARIO_TYPE', action='append', choices=TC_SCENARIO_TYPE_LIST,
+        help='A required testcase property: a scenario.  May be specified multiple times.  Valid values are: %s' % TC_SCENARIO_TYPE_LIST))
+    FVT_option_group.add_option(make_option(OPTION_EXECUTION_TYPE, dest='required_execution_types', metavar='EXECUTION_TYPE', action='append', choices=TC_EXECUTION_TYPE_LIST,
+        help='A required testcase property: an execution type.  May be specified multiple times.  Valid values are: %s' % TC_EXECUTION_TYPE_LIST))
+
+    # Add the group of FVT regression bucket options
+    parser.add_option_group(FVT_option_group)
+
+    (opts, args) = parser.parse_args()
+
+    #
+    # The command line options have been parsed and validated.  Some of them will be handled
+    # here.  These are the FVT regression run options.  Individual testcases don't even need
+    # to know that these options exist.  Handle them and then exit the testcase directly (not
+    # even "finally:" blocks are executed).  If none of these special options was specified,
+    # return the option and argument collections to the caller for handling of the other
+    # options and arguments, if any.
+    #
+
+    # Determine and validate the type of request specified on the command line, if any
+    get_properties_request = opts.get_properties
+    check_properties_request = opts.check_properties
+    run_if_applicable_request = opts.run_if_applicable
+    option_count = ((1 if get_properties_request else 0)
+                  + (1 if check_properties_request else 0)
+                  + (1 if run_if_applicable_request else 0))
+
+    if (option_count > 1):  # Only 0 (they're all optional) or 1 of these options may be specified at a time
+        print 'At most 1 of the following options may be specified: %s, %s, %s' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        os._exit(WSA_EXIT_INVALID_COMMAND_LINE)  # Make a direct exit
+
+    # Fetch the testcase properties from the testcase source code itself
+    testcase_props = getattr(__main__, TESTCASE_PROPERTIES_VARIABLE_NAME, None)
+
+    # Certain requests need the testcase properties.  Make sure they are defined.
+    if get_properties_request or check_properties_request or run_if_applicable_request:
+        if testcase_props is None:
+            print "The testcase source code does not define the %s variable" % TESTCASE_PROPERTIES_VARIABLE_NAME
+            os._exit(WSA_EXIT_MISSING_TESTCASE_PROPERTIES)  # Make a direct exit
+
+    # Handle a request to display the testcase properties
+    if get_properties_request:
+        print GET_PROPERTIES_BEGIN_MARKER
+        print "%s=\n%s" % (TESTCASE_PROPERTIES_VARIABLE_NAME, pprint.pformat(testcase_props))
+        print GET_PROPERTIES_END_MARKER
+        os._exit(WSA_EXIT_GET_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    # Handle requests that need to check the testcase properties against the required properties.
+    if check_properties_request or run_if_applicable_request:
+        # Check all simple string properties.  Some may have been specified multiple times on the command line.
+        properties_to_check = [(testcase_props, TC_CAPABILITIES, opts.required_capabilities),
+                               (testcase_props, TC_COMPONENT, opts.required_components),
+                               (testcase_props, TC_SCENARIO_TYPE, opts.required_scenario_types),
+                               (testcase_props, TC_EXECUTION_TYPE, opts.required_execution_types),
+                              ]
+
+        for property in properties_to_check:
+            # print 'checking %s' % property[1]
+            if check_testcase_requirement(property[0], property[1], property[2]) is False:
+                print "The testcase does not support any required value for the '%s' property, supplied values are " % (property[1]), (property[2])
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Doesn't meet this requirement, so exit.  Make a direct exit.
+    
+        # If a required API version was specified, check it now by making sure it is within the
+        # range defined by the testcase's minimum supported version and its maximum supported version
+        # (if defined).  First make sure its minimum supported version is <= the requirement.
+        required_version = opts.required_version
+        if required_version is not None:
+            if TC_MINIMUM_API_VERSION not in testcase_props.keys():
+                print "The testcase properties do not define the %s property" % (TC_MINIMUM_API_VERSION)
+                os._exit(WSA_EXIT_PROPERTY_NOT_DEFINED)  # Make a direct exit
+
+            available_minimum_version = testcase_props[TC_MINIMUM_API_VERSION]  # Get the value of this testcase property
+            # print "required & supported min versions: %s, %s" % (required_version, available_minimum_version)
+            # if required_minimum_version < available_minimum_version:
+            if not is_version_at_most(required_version, available_minimum_version):  # required < supported min
+                print "The testcase does not support the %s required API version; the testcase supports a minimum version of %s" % (required_version, available_minimum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If a required maximum version was specified and the testcase provides it, check it now.  This is
+        # an optional property that is not expected to be used very often.  It is intended to denote a
+        # testcase that has become obsolete at a certain API level.  Make sure the testcase's maximum
+        # supported version is >= the requirement.
+        if required_version is not None and TC_MAXIMUM_API_VERSION in testcase_props.keys():
+            available_maximum_version = testcase_props[TC_MAXIMUM_API_VERSION]  # Get the value if this testcase property
+            # print "required & supported max versions: %s, %s" % (required_maximum_version, available_maximum_version)
+            # if required_version > available_maximum_version:
+            if not is_version_at_most(available_maximum_version, required_version):  # required > supported max
+                print "The testcase does not support the %s required API version; the testcase supports a maximum version of %s" % (required_version, available_maximum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If we're only checking testcase requirements, all requirements are met and we're done!
+        # If this is a run-if-applicable request, all requirements have been met, so continue and
+        # actually execute the testcase.
+        if check_properties_request:   
+            print "The testcase meets the specified requirements"
+            os._exit(WSA_EXIT_CHECK_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    return (opts, args)
+
+
+#############################################################################
+#
+# This method provides a simple method to validate the response from an HTTP
+# request.
+#
+# @param rs - the Response object returned by one of the Session methods,
+#             such as Session.get, for example.
+# @param vm - validation map that can contain on or more of the following:
+#             status       : the expected status code from the operation
+#             content-type : the expected content type in the response
+#             required     : a list of required properties in the
+#                            response body
+#             optional     : a list of optional properties in the
+#                            response body
+#
+# An example validation map :
+#  { 'status':200,
+#    'content-type':'application/json',
+#    'required':[],
+#    'optional':[] }
+#
+# All validation map parameters are optional.  Parameters that are not
+# present in the map will not be used as part of the validation test.
+#
+# @return True is validation is successful, False otherwise
+#
+#############################################################################
+
+def validate_response(rs, vm) :
+
+    if vm is None : return True  # Nothing to validate in this case ...
+
+    if rs is None or not isinstance(rs, Response) :
+        raise ApiFatalException('Response missing or invalid', response=rs)
+
+    # Validate the status
+    if 'status' in vm and rs.status != vm[ 'status' ] :
+        raise ApiException('Invalid status ' + str(rs.status) + ' ' + str(rs.reason), response=rs)
+
+    # Validate the content type
+    content = rs.headers[ WSA_HEADER_CONTENT ] if WSA_HEADER_CONTENT in rs.headers else None
+    if WSA_HEADER_CONTENT in vm :
+        if content is None or not content.startswith(vm[ WSA_HEADER_CONTENT ]) :
+            raise ApiException('Invalid content type ' + str(content), response=rs)
+
+    if content is not None and content.startswith(WSA_CONTENT_JSON) :
+        req = vm[ 'required' ] if 'required' in vm else None
+        opt = vm[ 'optional' ] if 'optional' in vm else None
+        try :
+            validate_dictionary(rs.body, req, opt)
+        except ApiException as exception :
+            exception.response = rs
+            raise exception
+
+    return True
+
+
+
+
+# Verify the response is consistent with No Content (204)
+# @param response Response object
+def validate_no_content_response (response) :
+    print
+    print 'Validating that Response is a proper No Content (204) response'
+    if response.status != 204 :
+        print_response(response)
+        raise Exception('Failed: Expected No Content status 204, got ' + str(response.status))
+    if response.headers.get(WSA_HEADER_CONTENT) != None :
+        print_response(response)
+        raise Exception('Failed: Expected no content-type header for 204 response, got ' + str(response.headers.at(WSA_HEADER_CONTENT)))
+    if (response.body != None) and (response.body != '') and (response.body != '{}') :  # Response object returns {} for no content?
+        print_response(response)
+        raise Exception('Failed: Expected no content in body, got ' + str(response.body))
+# end validate_no_content_response
+
+#############################################################################
+#
+#############################################################################
+
+def validate_dictionary(dict, req, opt) :
+
+    if dict is None or type(dict) is not types.DictType :
+        raise ApiFatalException('Dictionary missing or invalid type')
+
+    if req is None : req = []
+    if opt is None : opt = []
+
+    if req == [] and opt == [] : return True
+
+    allKeys = set(dict.keys())
+    reqKeys = set(req)
+    result = reqKeys.difference(allKeys)
+    if len(result) > 0 :
+        raise ApiException('Missing required keys', keys=sorted(list(result)))
+
+    optKeys = set(opt)
+    result = allKeys.difference(reqKeys).difference(optKeys)
+    if len(result) > 0 :
+        raise ApiException('Extraneous keys found', keys=sorted(list(result)))
+
+    return True
+
+
+#############################################################################
+# Return a list of all ensembles, after first validating the response
+#############################################################################
+
+def list_ensembles(session) :
+    ensembles = None
+    response = session.get(WSA_URI_ENSEMBLES)
+    validate_response(response, WSA_LIST_ENSEMBLES_VALIDATE)
+    for ensemble in response.body[ 'ensembles' ] :
+        validate_dictionary(ensemble, WSA_LIST_ENSEMBLE_REQUIRED, [])
+    return response.body[ 'ensembles' ]
+
+
+#############################################################################
+# Update the ensemble properties 
+# ensemble_uri : the uri of the ensemble to be updated (str)
+# request_body : request body containing the fields to update (dict)
+#############################################################################
+
+def update_ensemble(session, ensemble_uri, request_body):
+    response = None
+    print 'ensemble update body: ' + json.dumps(request_body)
+    response = session.post(ensemble_uri, json.dumps(request_body))
+    print 'Ensemble update response status: ' + str(response.status)
+    return response
+
+
+#############################################################################
+# Return information about the ensemble on the system
+#############################################################################
+
+def get_ensemble_info(session) :
+    print '\nGet the ensemble information'
+    ensembles = list_ensembles(session)
+    if len(ensembles) == 0 :
+        raise Exception('No ensemble defined on system')
+    ensemble_info = ensembles[0]
+    ensemble_uri = ensemble_info['object-uri']
+    print 'Ensemble uri is [' + ensemble_uri + ']'
+    return ensemble_uri, ensemble_info
+
+
+#############################################################################
+# Return all the properties of the specified ensemble
+#############################################################################
+
+def get_ensemble_properties(session, ensemble) :
+    response = session.get(ensemble[ 'object-uri' ])
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return all the properties of the ensemble identified by its URI
+#############################################################################
+
+def get_ensemble_properties_by_uri(session, ensemble_uri) :
+    response = session.get(ensemble_uri)
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return a list of all cpcs, afer first validating the response
+#############################################################################
+
+def list_cpcs(session) :
+    cpcs = None
+    response = session.get(WSA_URI_CPCS)
+    if response.status != 200:
+        raise ApiException("ERROR: status=" + response.status + ", uri=" + WSA_URI_CPCS)
+    strCPCs = str(response)
+    cpcCount = strCPCs.count('object-uri')
+    if cpcCount == 0 :
+        raise ApiException('No cpcs defined on system')
+    validate_response(response, WSA_LIST_CPCS_VALIDATE)
+    for cpc in response.body[ 'cpcs' ] :
+        validate_dictionary(cpc, WSA_LIST_CPC_REQUIRED, [])
+    cpcs = response.body['cpcs']
+    return cpcs
+    
+
+#############################################################################
+# Return either the default CPC or the first cpc found in the operating state
+#############################################################################
+
+def get_operating_cpc(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    # # See how many cpcs we have
+    strCPCs = str(cpcs)
+    n = strCPCs.count('object-uri')
+    cpc_name = ''
+    # # See if we have a default CPC name to find
+    if DEFAULT_CPC_NAME != '' :
+        # # Find the default cpc
+            for i in range(0, n):
+                if (cpcs[i]['name'] == DEFAULT_CPC_NAME) & (cpcs[i]['status'] == 'operating') :
+                    cpc_uri = cpcs[i]['object-uri']
+                    cpc_name = cpcs[i]['name']
+                    print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                    break
+    # # If default CPC is not found and operating, look for the first operating CPC
+    if cpc_name == '' :
+        # # Find an operating cpc
+        for i in range(0, n):
+            if (cpcs[i]['status'] == 'operating') :
+                cpc_uri = cpcs[i]['object-uri']
+                cpc_name = cpcs[i]['name']
+                print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                break
+    # # Make sure we found an operating cpc
+    if cpc_name == '' :
+        raise Exception('No operating cpcs defined on system')
+    else :
+        # cpc_uri = cpcs[0]['object-uri']
+        return cpc_uri
+    
+    
+#############################################################################
+# Return either the default CPC or the first cpc found
+#############################################################################
+
+def get_cpc_new(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    targetCpc = None
+    for cpc in cpcs :
+        if cpc['name'] == APA_TESTENV_CPC_UNDER_TEST :
+            targetCpc = cpc
+            break
+    if targetCpc is None :
+        raise ApiFatalException("Unable to find a required CPC, exiting")    
+    cpc_uri = targetCpc['object-uri']
+    return cpc_uri
+
+
+##########################################################################################
+# Return either the default virtualization host or the first found in the operating state
+##########################################################################################
+
+def get_operating_virtualization_host(session, virtualization_hosts) :
+    print '\nGet the operating virtualization host'
+    virtualization_host_name = None
+    for virtualization_host in virtualization_hosts :
+        if virtualization_host[ 'name' ] == DEFAULT_VIRTUALIZATION_HOST_NAME :
+            if  virtualization_host[ 'status' ] == 'operating' :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    if virtualization_host_name is None :
+        for virtualization_host in virtualization_hosts :
+            if (virtualization_host[ 'status' ] == 'operating') & (virtualization_host[ 'type' ] == 'zvm')  :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    # # Make sure we found an operating virtualization host
+    if virtualization_host_name is None :
+        raise ApiFatalException('No zvm virtualization host present in the Ensemble or is not in the right state to perform this test')
+    else :
+        return virtualization_host
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble(session, ensemble_info, query=None) :
+    return list_virtualization_hosts_by_ensemble_uri(session, ensemble_info['object-uri'], query)
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=None) :
+    response = None
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    if query is None :
+        response = session.get(node_uri + '/virtualization-hosts')
+    else :
+        response = session.get(node_uri + '/virtualization-hosts?' + query)
+    validate_response(response, WSA_LIST_VIRT_HOSTS_VALIDATE)
+    for host in response.body[ 'virtualization-hosts' ] :
+        validate_dictionary(host, WSA_LIST_VIRT_HOST_REQUIRED, [])
+    return response.body[ 'virtualization-hosts' ]
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for an arbitrary
+# (or specific, if virtualization_host_name is specified) virtualization
+# host of the specified type, managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host(session, virtualization_host_type, ensemble_uri=None, virtualization_host_name=None):
+    print '\nSearching the ensemble for a virtualization_host of type ' + virtualization_host_type
+    typefilter = 'type=%s' % (virtualization_host_type)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+    
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, 'name=ZBX51.*&'+typefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    if len(nodes) == 0 :
+        raise Exception('No suitable node (name=' + WSA_DEFAULT_ZBX_NAME + ') is defined in ensemble ' + ensemble_name)
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + typefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_type + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    # Set the virtualization host name to search for, if any
+    vh_name = None
+    if virtualization_host_name is None:
+        # If we're looking for a zvm virtualization host on the R32 ensemble, restrict Test usage to a specific virtualization host
+        if virtualization_host_type == 'zvm':
+            if ensemble_name == ENSEMBLE_NAME_R32:
+                vh_name = PREFERRED_ZVM_VIRTUALIZATION_HOST_R32
+    else:
+        vh_name = virtualization_host_name
+
+    virtualization_host_info = None  # Assume no appropriate virtualization host will be found
+    if vh_name is None:
+        virtualization_host_info = virtualization_hosts[0]  # Use the first one (arbitrary choice)
+    else:
+        for virtualization_host in virtualization_hosts:  # Iterate over all vh info objects that match the desired vh type
+            if virtualization_host['name'] == vh_name:  # Found it
+                virtualization_host_info = virtualization_host
+        if virtualization_host_info is None:
+            raise Exception('No ' + virtualization_host_type + ' virtualization host with name ' + vh_name + ' is defined in ensemble ' + ensemble_name)
+
+    virtualization_host_uri = virtualization_host_info['object-uri']
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for a specified
+# virtualization host managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host_by_name(session, virtualization_host_name, ensemble_uri=None):
+    print '\nSearching the ensemble for a virtualization_host of name ' + virtualization_host_name
+    namefilter = 'name=%s' % (virtualization_host_name)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=namefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + namefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_name + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    virtualization_host_info = virtualization_hosts[0]
+    virtualization_host_uri = virtualization_host_info['object-uri']
+
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI of a virtual server object with the specified name owned
+# by the specified virtualization host.  If return_response is True, then
+# the response object is always returned; otherwise, the URI is returned
+# or an exception is raised.
+#############################################################################
+
+def find_virtual_server_in_virtualization_host(session, virtualization_host_uri, virtual_server_name, return_response=False) :
+    # Find the VS within the specified VH
+    response = session.get(virtualization_host_uri + "/virtual-servers?name=" + virtual_server_name)
+    if response.status != 200:
+        msg = "An error occurred fetching virtual server information for the virtualization host"
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    virtual_servers = response.body["virtual-servers"]
+    if len(virtual_servers) == 0 :
+        msg = "The virtualization host has no virtual server with name " + virtual_server_name
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    if return_response :
+        return response
+    else :
+        return virtual_servers[0]["object-uri"]
+
+
+#############################################################################
+# Startup method to create session and logon ...
+# Connection parameters (host, port, user, and pwd) should not be overridden
+# by test scripts unless there is an explicit need (eg log in under different
+# users to verify access permission)
+# @param host - IP address of the target HMC (str)
+# @param port - Port number to connection on the target HMC (int)
+# @param user - Logon userid to use on the target HMC (str)
+# @param pwd  - Logon password to use on the target HMC(str)
+# @param additional_options - any additional command line option definitions.
+#               See parse_standard_options() and the Session class for more details.
+#               (list of Option objects created via make_option())
+# @param additional_arguments_usage_info - Usage information for any additional
+#               command line arguments.  See parse_standard_options() and the
+#               Session class for more details. (str)
+# @param amq-client - ActiveMQ client to use for notification messages
+# @param amq-socket-type - Type of socket to use for ActiveMQ messages;
+#               either ssl or non-ssl
+#
+# Note that the Session __init__ method calls parse_standard_options(), which 
+# uses os._exit(rc) in some cases rather than the more common sys.exit(rc).
+# See the prolog of parse_standard_options for more details.
+#############################################################################
+
+#############################################################################
+# Find the object with a given name from a list of objects
+#############################################################################
+def find_object_by_name(session, object_list, object_name) :
+    result = None
+    for obj in object_list :
+        if type(obj['name']) is unicode :
+            obj_name = obj['name'].encode('utf-8')
+        if (obj_name == object_name) :
+            result = obj
+    return result
+
+
+def session_startup(host=None, port=None, user=None, pwd=None, verbose=False, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+    session = Session(host, port, user, pwd, additional_options, additional_arguments_usage_info, amq_client, amq_socket_type)
+
+    # Now open the session by establishing an HTTP connection to the target HMC
+    if verbose :
+        print 'Connecting to', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+    session.open()
+    if verbose :
+        print 'Session ID: \t%s' % session.session()
+
+    return session
+
+
+#############################################################################
+# Determine if the API version being tested is at least as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# added or changed in an incompatible fashion after the initial API release.
+# The testcase can use this function in order to know what behavior to expect
+# from the API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_least(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    # return (api_version >= version_to_check)  #??? Need to do a real implementation of this that can handle all valid version formats!  (For example, need to be able to compare "1.2" and "1.12")
+    return is_version_at_least(version_to_check, api_version)
+
+
+# See is_api_version_at_least() above for description
+def is_version_at_least(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_least: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version >= version_to_check)
+
+    # Iterate over the numeric parts of the input version number and compare them to the
+    # corresponding parts of the session's API version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(version_to_check_parts)):
+        version_to_check_part = int(version_to_check_parts[i])
+        if len(api_version_parts) >= i + 1:
+            api_version_part = int(api_version_parts[i])
+        else:  # Not enough parts in api_version; supply a 0
+            api_version_part = 0
+        if version_to_check_part < api_version_part:
+            return True
+        elif version_to_check_part > api_version_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the input version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # version_to_check has fewer parts, which means that it cannot be greater than
+    # api_version.  Thus it must be <=, so we return True.
+    return True
+
+
+#############################################################################
+# Determine if the API version being tested is exactly the same as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.
+# 
+# Returns:
+#    True if it is; otherwise, False.
+#############################################################################
+
+def is_api_version_exactly(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    return (api_version == version_to_check)
+
+
+#############################################################################
+# Determine if the API version being tested is at most as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# removed or changed in an incompatible fashion at some point.  The testcase
+# can use this function in order to know what behavior to expect from the
+# API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_most(session, version_to_check):
+    api_version = api_effective_version(session)
+    return is_version_at_most(version_to_check, api_version)
+
+
+# See is_api_version_at_most() above for description
+def is_version_at_most(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_most: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version <= version_to_check)
+
+    # Iterate over the numeric parts of the session's API version number and compare them to the
+    # corresponding parts of the input version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(api_version_parts)):
+        api_version_part = int(api_version_parts[i])
+        if len(version_to_check_parts) >= i + 1:
+            version_to_check_part = int(version_to_check_parts[i])
+        else:  # Not enough parts in version_to_check; supply a 0
+            version_to_check_part = 0
+        if api_version_part < version_to_check_part:
+            return True
+        elif api_version_part > version_to_check_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the API version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # api_version has fewer parts, which means that it cannot be greater than
+    # version_to_check.  Thus it must be <=, so we return True.
+    return True
+
+# Return the "effective" version (the version reported by the HMC itself, or the override
+# value from the command line (if specified).
+def api_effective_version(session):
+    return session.api_version() if session.api_version_override() is None else session.api_version_override()
+
+#############################################################################
+# Determine if the specified WS API feature is available to the current session.
+# 
+# Returns:
+#    True if the feature is available; otherwise, False.
+#############################################################################
+
+def is_feature_available(session, feature):
+    features = session.api_features()
+    return (features is not None and feature in features)
+
+
+#############################################################################
+# Check the supplied testcase properties to see if they meet at least one of
+# the required values for the specified property.  This is effectively a
+# logical OR of the required property values.
+# 
+# Returns:
+#    True if the testcase supports at least one of the required property
+#    values; otherwise, False.
+#############################################################################
+
+def check_testcase_requirement(testcase_properties, property_name, required_properties):
+    if required_properties is None:
+        required_found = True
+    else:
+        # Check required property; these are OR'd together
+        required_found = False  # Something is required; assume we don't have it
+
+        if property_name in testcase_properties.keys():
+            available = testcase_properties[property_name]
+            for r in required_properties :
+                # Many requirement values are accepted in upper or lower case, so 
+                # convert everything to lowercase before looking for a match.
+                # We currently support testcase properties whose values are of
+                # type string or list.
+                # if r.upper() in available:
+                if type(available) is types.StringType:  # A string
+                    if r.lower() == available.lower():
+                        required_found = True
+                        break
+                else:  # Assume a list
+                    if r.lower() in make_lowercase_copy(available):
+                        required_found = True
+                        break
+        else:
+            print "The testcase properties do not define the %s property" % (property_name)
+
+    return required_found
+
+
+#############################################################################
+# Exit test code cleanly ...
+# By default, all "temporary" objects are deleted, and any "admin sessions"
+# and "temporary sessions" are shutdown after the specified session is shutdown.
+#############################################################################
+
+def session_shutdown(session, verbose=True, delete_temporary_objects=True, delete_admin_sessions=True, delete_temporary_sessions=True) :
+    if session is not None :
+        if verbose :
+            print 'Disconnecting from', session.hmc_name(), 'at', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+        try :
+            session.close()
+        except (ApiException, ApiFatalException) as exception :
+            print
+            print 'Exception raised during shutdown ...'
+            print exception
+            print
+
+
+    # Delete temporary sessions first, in case one is for a temporary user that we're
+    # about to delete in delete_all_temporary_objects().
+    if delete_temporary_sessions:
+        delete_all_temporary_sessions()
+
+    if delete_temporary_objects:
+        delete_all_temporary_objects()
+
+    if delete_admin_sessions:
+        delete_all_admin_sessions()
+
+
+#############################################################################
+# This function returns True if value is a number, False otherwise.
+#############################################################################
+
+def isNumeric(value) :
+    try :
+        float(value)
+    except (ValueError) :
+        return False
+    return True
+
+
+#############################################################################
+#
+# This function prints out data as formatted columns.
+#
+# Formatting is simple : Strings will be left-justified
+#                        Numbers will be right-justified
+#
+# Input :
+#
+#   The keys parameter is a list of keys whose values should be printed
+#   The data parameter is a list of dictionaries
+#
+# No error checking is done currently ...
+#
+# Example :
+#
+#    keys = [ 'name', 'status', 'type' ]
+#    data = [ { 'name':'abc',     'type':'foo',    'status':'operating',     'count':1    },
+#             { 'name':'abcde',   'type':'bar',    'status':'not_operating', 'count':10   },
+#             { 'name':'ab',      'type':'foobar', 'status':'status_check',  'count':100  },
+#             { 'name':'abcdefg', 'type':'fubar',  'status':'starting',      'count':1000 } ]
+#
+#    prettyPrint( data, keys ) will print ...
+#
+#       abc     operating     foo
+#       abcde   not_operating bar
+#       ab      status_check  foobar
+#       abcdefg starting      fubar
+#
+#############################################################################
+
+def prettyPrint(data, keys) :
+    if data is None or len(data) == 0 : return
+    if keys is None or len(keys) == 0 : return
+    width = {}
+    for key in keys :
+        width[ key ] = max([ len(str(row[ key ])) for row in data ])
+    for row in data :
+        for key in keys :
+            if isNumeric(row[ key ]) :
+                print str(row[ key ]).rjust(width[ key ]),
+            else :
+                print str(row[ key ]).ljust(width[ key ]),
+        print
+
+
+# Print a Response object with formatted headers and body
+# @param response - API response (Response)
+def print_response(response, sort_body=True) :
+    if response is None or response.__class__ is not Response :
+        raise ApiFatalException('response is missing or invalid type')
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(response.headers, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    print json.dumps(response.body, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    if 'stack' in response.body:
+        print 'stack (again, but in a more programmer-friendly format):'
+        print response.body['stack']
+    return
+# end print_response
+
+
+# Print information in a formatted fashion from a response object and an optional response body.
+# This is useful for streamed responses; see return_full_response in wsautils.py and the 
+# read_response_streamed() function.
+def print_response_info(response, response_body=None) :
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(dict (response.getheaders()), indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    if response_body is None:
+        print json.dumps(response.read(), indent=1, separators=(',', ':'))
+    else:
+        body = json.loads(response_body)
+        print json.dumps(body, indent=1, separators=(',', ':'))
+    return
+   # end print_response_info
+
+
+# Print a line(s) between separator lines so that they stand out among the testcase output.
+# Optional text can be included in the separator line that precedes the lines and the one 
+# that follows the lines.  The length and composition of the separator line can by customized
+# with input parameters.
+def print_between_separator_lines(lines, header_text=None, footer_text=None, length=90, box_char="=", blank_lines=1):
+    if header_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(header_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, header_text)  # Leading box chars and header text
+
+    header_line = "%s%s%s" % ("\n"*blank_lines, line, box_char * (length - len(line)))  # Add the blank lines and trailing box chars
+    print header_line
+
+    # Write all of the input lines
+    for line in lines:
+        print line
+    
+    if footer_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(footer_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, footer_text)  # Leading box chars and footer text
+
+    footer_line = "%s%s%s" % (line, box_char * (length - len(line)), "\n"*blank_lines)  # Add the trailing box chars and blank lines
+    print footer_line
+
+
+#############################################################################
+#
+# Filter a list of dictionaries based on keys and values
+#
+# This function is a "generator", meaning its output should be wrapped
+# in a list in order to iterate over the results.
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'foo'.
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'foo'
+# print list( filter_dictionary( data, func ) )
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'bar' with the value of 'bar2'
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'bar' and v == 'bar2'
+# print list( filter_dictionary( data, func ) )
+#
+#############################################################################
+
+def filter_list(data, predicate=lambda k, v: True) :
+    for d in data:
+         for k, v in d.items():
+               if predicate(k, v):
+                    yield d
+
+#########################################################################
+# Determine the Output body, response, and reason code
+#
+# NOTE : The Response object has been updated to raise an
+# ApiFatalException if the HTTP headers indicate a content type of json,
+# but the response body fails to parse with json.loads.
+# This negates the need for 'determine' to check for a malformed body
+# with a subsequent return code of '2'.
+#########################################################################
+
+def determine(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code and reason == reason_code :
+        return(0)
+    else :
+        return(1)
+    
+# added by lv start
+def determine_with_raise_exception(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code :
+        if reason == reason_code :
+            return (0)
+        else: 
+            raise ApiException('expected reason code' + str(reason_code) + ' not seen')
+    else :
+        raise ApiException('expected status code' + str(status_code) + ' not seen')
+# added by lv end
+
+
+#########################################################################
+# Get the current time, formatted
+#########################################################################
+def get_time_stamp() :
+    return time.strftime("%Y%m%d %H:%M:%S %z", time.localtime())
+# end get_time_stamp
+
+
+#########################################################################
+# Get the fully-qualified filename of the current testcase
+#########################################################################
+
+def get_testcase_full_filename ():
+    return sys.argv[0]
+
+
+#########################################################################
+# Get the testcase ID for the current testcase, based on its filename,
+# or for a specified filename.
+# The expected format for testcase filenames is
+#           <comp>_<id>.py
+# where <comp> is the component (e.g., svm, vsm, lpar) and <id> is the
+# testcase ID number.  For example, vsm_3588.py
+#########################################################################
+
+def get_testcase_id (filename=None):
+    name = get_testcase_full_filename() if filename == None else filename
+    basename = os.path.basename(name)  # Just the filename, no path
+    (name, ext) = os.path.splitext(basename)  # Separate name from extension (e..g, svm_3588)
+    parts = string.split(name, '_')  # Split at underscore (e.g., 'svm', '3588')
+    id = parts[len(parts) - 1]  # ID is the last one of the parts
+    return id
+
+
+
+
+def get_files_from_se(remote_files, local_zip_file):
+    return
+# Get the name of the user's notification topic for a specified topic type
+#
+# Inputs:
+# - requested_topic_type: the type of topic to find.  Must be a valid topic type as
+#                         returned by the Get Notification Topics operation:
+#                         'object', 'job', 'audit' or 'security'.
+#
+# Returns: the name of the topic, or None if there is no such topic for the user (e.g.,
+#          the user is not authorized to connect to it).
+#
+# Any failure is reported via an exception
+def get_notification_topic(session, requested_topic_type):
+    """Get the name of the user's notification topic for the specified topic type"""
+
+    # Make sure the targetted HMC supports the request required to fetch the notification topics
+    if not is_api_version_at_least(session, TC_API_VERSION_ZSPHINX_GA1):
+        raise ApiFatalException('The targetted HMC (effective version %s) does not support audit or security notifications; must be version %s or later' % (api_effective_version(session), TC_API_VERSION_ZSPHINX_GA1))
+
+    valid_topic_types = ['object', 'job', 'audit', 'security']
+    if requested_topic_type not in valid_topic_types:
+        raise ApiException("get_notification_topic(): Invalid topic type: " + requested_topic_type)
+    true_topic_type = requested_topic_type + "-notification"  # The name returned by Get Notification Topics
+
+    # Issue a Get Notification Topics request to get all of the user's authorized topics
+    uri = "/api/sessions/operations/get-notification-topics"
+    response = session.get(uri)
+    if response.status != 200:
+        raise ApiException("Get Notification Topics operation failed", response)
+    topics = response.body['topics']
+
+    if len(topics) == 0:  # No topics!  Should never happen, per the doc
+        print 'User is not authorized for any notification topics - this should never happen!'
+        return None
+
+    # Iterate over the user's authorized topics looking for the specified one
+    for topic in topics:
+        topic_type = topic['topic-type']
+        topic_name = topic['topic-name']
+#       print 'Topic type: %s, topic_name: %s' % (topic_type, topic_name)
+        if topic_type == true_topic_type:  # Found it
+            return topic_name
+
+    # Not found
+    return None
+
+
+# Issue the provided request and return the response along with a string containing 
+# the formatted request and response.  This formatted version is suitable for inclusion
+# in the HMC Web Services API external customer publication.  It contains:
+# - the caption text for the request example
+# - the HTTP method and full request URI
+# - certain request headers
+# - the request body, if any, alphabetized, nicely formatted and indented
+# - the caption text for the response example
+# - the HTTP status code and its meaning (e.g., "201 (Created)")
+# - certain response headers
+# - the response body, if any, alphabetized, nicely formatted and indented
+#
+# The operation_name should be the full name by which the operation is known in the external book
+# The URI may contain query parms.  This is handy for limiting the size of the response body
+# for List <class> operations.  It is OK to publish these, but not necessary.
+# The request_body is a dictionary (and is optional).
+def capture_example_for_book(session, operation_name, uri, method="get", request_body=None):
+    indent_amount = 3
+    request_headers_to_publish_get = [WSA_HEADER_RQ_SESSION]
+    request_headers_to_publish_post = [WSA_HEADER_RQ_SESSION,
+                                       WSA_HEADER_CONTENT_TYPE,
+                                       WSA_HEADER_CONTENT_LENGTH]
+    request_headers_to_publish_delete = [WSA_HEADER_RQ_SESSION]
+    response_headers_to_publish = [WSA_HEADER_RESP_SERVER,
+                                   WSA_HEADER_RESP_TRANSFER_ENCODING,  # "chunked" is of interest
+                                   WSA_HEADER_RESP_LOCATION,
+                                   WSA_HEADER_RESP_CACHE_CONTROL,
+                                   WSA_HEADER_RESP_DATE,
+                                   WSA_HEADER_CONTENT_TYPE,
+                                   WSA_HEADER_CONTENT_LENGTH]
+
+    if method == 'get':
+        request_headers_to_publish = request_headers_to_publish_get
+        response = session.get(uri)
+    elif method == 'post':
+        request_headers_to_publish = request_headers_to_publish_post
+        response = session.post(uri, json.dumps(request_body))
+    elif method == 'delete':
+        request_headers_to_publish = request_headers_to_publish_delete
+        response = session.delete(uri)
+
+    request_headers = response.request.headers
+    response_headers = response.headers
+
+    # First format the request URI, filtered headers and body
+    formatted_request_response = "\n\n%s: Request\n\n" % operation_name
+    formatted_request_response += "\n%s %s %s" % (method.upper(), uri, "HTTP/1.1")
+
+    for header_name in request_headers_to_publish:
+        formatted_request_response += "\n%s: %s" % (header_name, request_headers[header_name])
+
+    if request_body != None:
+        formatted_request_body = json.dumps(request_body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+        formatted_request_response += "\n" + formatted_request_body
+
+    #------- end request, begin response --------
+    # Noe format the filtered response headers and the response body
+    formatted_request_response += "\n\n%s\n\n%s: Response\n\n" % (20 * '-', operation_name)
+    formatted_request_response += "\n%s %s" % (response.status, response.reason)
+
+    for header_name in response_headers_to_publish:
+        if header_name in response_headers.keys():
+            formatted_request_response += "\n%s: %s" % (header_name, response_headers[header_name])
+
+    if response.status == 204 or response.body == None:
+        formatted_response_body = "\n<No response body>"
+    else:  # There is a response body; make it look pretty
+        formatted_response_body = json.dumps(response.body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+    formatted_request_response += "\n" + formatted_response_body
+
+    # Formatting is complete
+
+#   # Make sure the request succeeded; assume any 2xx indicates success
+#   if response.status < 200 or response.status > 299:
+#       print_response(response)
+#       raise ApiException("The request appears to have failed.  URI '%s' returned HTTP status code %d (%s)" % (uri, response.status, response.reason))
+
+    # Return the complete Response object and the formatted request/response string
+    return response, formatted_request_response
+
+
+#########################################################################
+#                  "Temporary object" support
+#########################################################################
+
+# Add a temporary object to the registry.  All objects in the registry will
+# be deleted by default when the session is shutdown.  The object must be
+# of a type that is supported by the "temporary object" support.
+# See the temporary_object_types_deletion_order and temporary_object_types_info
+# constants in wsaconst.py.
+def register_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        if is_supported_temporary_object_type(temporary_object_uri):
+            wsaglobals.global_temporary_objects_list.append(temporary_object_uri)
+        else:
+            raise ApiFatalException('URI "%s" does not designate an object of a type that is supported by the "temporary object" support in wsautils' % temporary_object_uri)
+
+
+# Remove a temporary object from the registry
+def deregister_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        wsaglobals.global_temporary_objects_list.remove(temporary_object_uri)
+
+
+# Gets a copy of the list of all registered temporary objects.
+# Use register_temporary_object() and deregister_temporary_object()
+# to update this list if needed.
+def get_temporary_objects_list():
+    return list(wsaglobals.global_temporary_objects_list)  # Return a copy
+
+
+# Determine if the specified URI designates an object of a type that is supported
+# by the "temporary object" support.
+def is_supported_temporary_object_type(uri):
+    if uri is None or not isinstance(uri, types.StringTypes):  # Not a string (likely to be a Response object from a failed request...)
+        return False
+    
+    for info_entry in temporary_object_types_info.values():
+        uri_prefix = info_entry[KEY_URI_PREFIX]
+        if uri.startswith(uri_prefix):  # It's a supported type
+            return True
+    return False
+
+
+# Delete all temporary objects in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_objects():
+    temporary_objects_list = get_temporary_objects_list()  # Get a copy to iterate over; the real list gets updated
+    if temporary_objects_list is not None and len(temporary_objects_list) > 0:  # There are temporary objects to be deleted
+        print '\nTemporary objects to delete: %d' % len(temporary_objects_list)
+
+        # Iterate over all supported object types and delete all instances of each type,
+        # then move on to the next type
+        for object_type in temporary_object_types_deletion_order:  # Go in a certain order, since it sometimes matters
+            info_entry = temporary_object_types_info[object_type]  # Get handling info about the current object type
+            uri_prefix = info_entry[KEY_URI_PREFIX]
+#           print 'Looking for temporary objects with a URI prefix of "%s"' % uri_prefix
+            
+            # Iterate over all temporary objects in the registry, searching for those
+            # of the type we're currently handling.  Delete each as it is found and 
+            # remove it from the registry.
+            for uri in temporary_objects_list:
+                if uri is not None and uri.startswith(uri_prefix):  # Its type matches the type we're handling now
+                    try:
+                        admin_user = info_entry[KEY_ADMIN_USERID]
+
+                        admin_session = get_admin_session(admin_user)
+
+                        print 'Using %s to delete temporary object: %s' % (admin_user, uri)
+                        response = admin_session.delete(uri)
+                        if response.status != 204:
+                            print '\nError deleting temporary object: %s\n%s' % (uri, response)
+
+                        deregister_temporary_object(uri)  # Remove it from the list of temporary objects, since we've deleted it
+#                       print 'There are %d temporary objects left to delete' % len(wsaglobals.global_temporary_objects_list)
+                    except:
+                        print 'Caught exception!!'
+                        traceback.print_exc()
+                        print 'Continuing with any remaining temporary objects...'
+        print
+
+    # Get a current copy of the list; check to see if it's empty (it should be)
+    temporary_objects_list = get_temporary_objects_list()
+    if len(temporary_objects_list) > 0:  # Hmmmm, must have had an error trying to delete something; tell the user
+        print '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
+        print 'Not all temporary objects were deleted.  There are still %d temporary objects in the registry.' % len(temporary_objects_list)
+        print '\n%s\n' % temporary_objects_list
+        print '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n'
+
+
+# Get a Session authenticated as the specified userid.  This method is intended for use when
+# a priviledged (admin-type) user is required for performing scenario setup in the beginning
+# of a testcase (e.g., creating objects, setting properties)and at the end when that setup is
+# being undone (e.g., deleting temporary objects, resetting properties back to original values).
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase
+# exit.  There are constants for the standard system-defined  userids (e.g., 
+# ACCCES_ADMINISTRATOR, ENSEMBLE_ADMINISTRATOR) in wsaconst.py.
+def get_admin_session(admin_userid):
+    if admin_userid in wsaglobals.global_admin_sessions:
+        admin_session = wsaglobals.global_admin_sessions[admin_userid]
+#       print 'fetched cached session: %s' % admin_session
+    else:
+        admin_session = session_startup(user=admin_userid, additional_options=wsaglobals.global_saved_additional_options)
+        wsaglobals.global_admin_sessions.update({admin_userid : admin_session})
+#       print 'created and cached new session: %s' % admin_session
+
+#   print 'There are %d admin sessions' % len(wsaglobals.global_admin_sessions)
+#   print 'Returning admin session for admin user %s: %s' % (admin_userid, admin_session)
+    return admin_session
+
+
+# Get a Session object authenticated as the system-defined user that is appropriate for performing
+# administrative operations relative to the specified URI.  If no specific administrator has been
+# identified in the uri_admin_info map, then a session authenticated as PEDEBUG is returned.
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase exit.
+def get_admin_session_for_uri(uri):
+    admin_session = None
+    # See if the specified URI has an associated administrator userid
+    for uri_prefix in uri_admin_info:
+        if uri.startswith(uri_prefix):
+            admin_session = get_admin_session(uri_admin_info[uri_prefix])
+    if admin_session == None:
+        admin_session = get_admin_session(PEDEBUG)
+    return admin_session
+
+
+# Delete all (cached) admin sessions created by get_admin_session().
+# This method is intended to be called during session shutdown immediately before testcase exit.
+def delete_all_admin_sessions():
+    admin_sessions = dict(wsaglobals.global_admin_sessions)  # Make a copy to iterate over; the real list gets updated
+    if admin_sessions is not None and len(admin_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nAdmin sessions to shutdown: %d' % len(admin_sessions)
+        for admin_user_name in admin_sessions.keys():
+            try:
+                admin_session = admin_sessions[admin_user_name]
+                print 'Shutting down session for admin user: %s' % admin_user_name
+                # Shutdown this admin session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(admin_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)  # Delete just the session, and nothing else
+                del wsaglobals.global_admin_sessions[admin_user_name]  # Remove it from the list of admin sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining admin sessions...'
+
+#   print 'There are now %d admin sessions' % len(wsaglobals.global_admin_sessions)
+
+
+# Delete all temporary sessions in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_sessions():
+    temporary_sessions = get_temporary_sessions()  # Make a copy to iterate over; the real list gets updated
+    if temporary_sessions is not None and len(temporary_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nTemporary sessions to shutdown: %d' % len(temporary_sessions)
+        for temporary_session in temporary_sessions:
+            try:
+                print 'Shutting down temporary session for user: %s' % temporary_session.userid()
+                # Shutdown this temporary session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(temporary_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)
+                wsaglobals.global_temporary_sessions.remove(temporary_session)  # Remove it from the list of temporary sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining temporary sessions...'
+
+
+
+# Gets a copy of the list of all registered temporary sessions.
+def get_temporary_sessions():
+    return list(wsaglobals.global_temporary_sessions)  # Return a copy
+
+def start_receiving_messages(session):
+    session.start_receiving_messages()
+    
+def stop_receiving_messages(session):
+    session.stop_receiving_messages()
+    msgs = session.get_received_messages()
+    print msgs
+    return msgs
+
+def create_python_list(item):
+    return [item]
+
+def create_python_dict(prop, value):
+    return {prop:value}
+
+"""
+Generic function that finds an object of type ObjectType by its attribute.    
+The function looks for a objectToFind which is a string type by it's attribute.
+Params: Field Name refers to properties like name, status etc
+        objectType refers to objects like cpcs, groups, members etc
+        FielddNameValue is the string that is searched for in the listOfDictionaries 
+"""
+def verify_object_in_list_by_attribute(listOfDictionaries, fieldNameValue, objectType, fieldName):
+    verifyIn = False
+    for myObject in listOfDictionaries.body[objectType]:
+        if myObject[fieldName] == fieldNameValue:
+            verifyIn = True
+            break
+    return verifyIn
+
+def get_partition_list(session, cpc):
+    response = session.get(cpc, '/partitions')
+    for partition in response.body['partitions']:
+        print partition['name']
+    return response.body['partitions']
+    
diff --git a/dist/Partition_Export_Import_Template_Engine-0.0.1-py2.7.egg b/dist/Partition_Export_Import_Template_Engine-0.0.1-py2.7.egg
new file mode 100644
index 0000000..2bf3426
Binary files /dev/null and b/dist/Partition_Export_Import_Template_Engine-0.0.1-py2.7.egg differ
diff --git a/dist/partitionengine-0.0.1-py2.7.egg b/dist/partitionengine-0.0.1-py2.7.egg
new file mode 100644
index 0000000..a9510ba
Binary files /dev/null and b/dist/partitionengine-0.0.1-py2.7.egg differ
diff --git a/logs/console.log b/logs/console.log
new file mode 100644
index 0000000..79a3e64
--- /dev/null
+++ b/logs/console.log
@@ -0,0 +1 @@
+Wed, 14 Sep 2016 15:49:09 INFO     Starting the PartitionManagementTemplating Tool
diff --git a/partitionengine.egg-info/PKG-INFO b/partitionengine.egg-info/PKG-INFO
new file mode 100644
index 0000000..552257e
--- /dev/null
+++ b/partitionengine.egg-info/PKG-INFO
@@ -0,0 +1,285 @@
+Metadata-Version: 1.0
+Name: partitionengine
+Version: 0.0.1
+Summary: Package for Export Import Template Engine
+Home-page: UNKNOWN
+Author: Preethi PY
+Author-email: preethi.py@gmail.com
+License: UNKNOWN
+Description: ##Description: 
+        The Partition Export/Import Template Engine helps in exporting and importing the complete Partition inventory on the same machine. The tool can also be used to create partition template from any given partition on the system and the template can be reused to create 'n' number of partitions on the same system
+        
+        ##Developers of the Tool: Preethi PY,Sowmya R, Anil k Paspuleti, Devagun
+        
+        
+        Note: The tool was implemented as part of Shrishti hackathon and this has also been the Idea from HVM-India team. This tool is not official and is also not tested in all scenarios. Hence the tool should be used at your own risk :)
+        ********************************************************************************************************************************************************************************************************
+        The tool when used for importing partitions or creating partition from template, will have new WWPNs generated. So note that the SAN administrator has to reconfigure the WWPN to make the Luns visible on Partitions
+        ********************************************************************************************************************************************************************************************************
+        
+        How to Use the Tool:
+        
+        => Git clone the code from the repository to your local system "git clone https://github.com/preethipy/Partition_Export_Import_TemplateEngine.git"
+        => The main script that has be run is export_import_template_engine/Console.py. The tool is quite interactive and hence very easy to use. 
+        
+        Prerequisites:
+        => The tool should can be run from any system which has access to HMC webservices API
+        => Webservices API has to be enabled on HMC before starting to use the tool.
+        
+        ##1) Export Partition Inventory:
+        
+        This feature helps you dump all the partition configuration on to your local system from where the tool is run. The sample execution output is shown below.
+        
+        [preethi@localhost src]$ python Console.py 
+        ****************************************************************************************************
+                                       Capture and replay partition creation                                
+        ****************************************************************************************************
+        Enter HMC IP [9.152.151.49]              :9.152.151.49
+        Enter Username [pedebug]              :pedebug
+        Enter Password :
+        Establishing session.... /
+        
+        |Fetching CPC List.... /
+         done!
+         done!
+        ****************************************************************************************************
+        List of CPCs available
+        1    P000S67B
+        
+        Select cpc by index from the given list [1]              :1
+        ****************************************************************************************************
+        CPC P000S67B is selected
+        ****************************************************************************************************
+        Choose one of the below options:
+        
+        1.  create n partitions from existing templates?
+        2.  create a partition based on another partition?
+        3.  Export Partition Inventory?
+        4.  Import Partition Inventory? 
+        
+        Select an option by index [4]              :3
+        
+        
+        Fetching Partition Inventory....... done!
+        
+        ****************************************************************************************************
+        Successfully Completed
+        ****************************************************************************************************
+        
+        ##2) Import Partition Inventory:
+        
+        
+        This feature helps in importing the partition configuration of the same machine back to the system again
+        
+        [preethi@localhost src]$ python Console.py 
+        ****************************************************************************************************
+                                       Capture and replay partition creation                                
+        ****************************************************************************************************
+        Enter HMC IP [9.152.151.49]              :9.152.151.49
+        Enter Username [pedebug]              :pedebug
+        Enter Password :
+        Establishing session.... /
+        
+        |Fetching CPC List....   
+         done!
+         done!
+        ****************************************************************************************************
+        List of CPCs available
+        1    P000S67B
+        
+        Select cpc by index from the given list [1]              :1
+        
+        ****************************************************************************************************
+        CPC P000S67B is selected
+        ****************************************************************************************************
+        Choose one of the below options:
+        
+        1.  create n partitions from existing templates?
+        2.  create a partition based on another partition?
+        3.  Export Partition Inventory?
+        4.  Import Partition Inventory? 
+        
+        Select an option by index [3]              :4
+        Creating Partition.... /
+         done!
+        Creating VNics.... done!
+        Creating HBAs.... done!
+        Creating VirtualFunctions.... done!
+        Configuring Cryptos.... done!
+        
+        
+        Updating Partition Properties.... done!
+        Retrieve and Verify Partition Properties.... /
+         done!
+        Partition: test Created Successfully
+        ****************************************************************************************************
+        Successfully Completed
+        ****************************************************************************************************
+        
+        ##3) Create a template from existing partition
+        
+        This will help you create a template from any preferred partition and also lets you create n partitions based on the template.. Once template is created it is stored in the system locally.
+        
+        [preethi@localhost src]$ python Console.py 
+        ****************************************************************************************************
+                                       Capture and replay partition creation                                
+        ****************************************************************************************************
+        Enter HMC IP [9.152.151.49]              :
+        Enter Username [pedebug]              :
+        Enter Password :
+        Establishing session.... /
+        -
+        -Fetching CPC List.... /
+         done!
+         done!
+        ****************************************************************************************************
+        List of CPCs available
+        1    P000S67B
+        
+        Select cpc by index from the given list [1]              :1
+        
+        ****************************************************************************************************
+        CPC P000S67B is selected
+        ****************************************************************************************************
+        Choose one of the below options:
+        
+        1.  create n partitions from existing templates?
+        2.  create a partition based on another partition?
+        3.  Export Partition Inventory?
+        4.  Import Partition Inventory? 
+        
+        Select an option by index [4]              :2
+        
+        1    test
+        
+        Select partition by index [1]              :1
+        
+        Enter the number of partitions to be created  [1]              :1
+        Fetching Partition Inventory....... /
+         done!
+        
+        ****************************************************************************************************
+        Creating Partition 1
+        ****************************************************************************************************
+        Creating Partition.... /
+         done!
+        Creating VNics.... done!
+        Creating HBAs.... done!
+        Creating VirtualFunctions.... done!
+        Configuring Cryptos.... done!
+        
+        Updating Partition Properties.... /
+         done!
+        
+        Retrieve and Verify Partition Properties.... done!
+        Partition: test_90DK Created Successfully
+        ****************************************************************************************************
+        Successfully Completed
+        ****************************************************************************************************
+        
+        ##4) Create n partitions from existing templates on your local system
+        If you have already created templates, you can create n number of partitions based on that template
+        
+        [preethi@localhost src]$ python Console.py 
+        ****************************************************************************************************
+                                       Capture and replay partition creation                                
+        ****************************************************************************************************
+        Enter HMC IP [9.152.151.49]              :
+        Enter Username [pedebug]              :
+        Enter Password :
+        Establishing session.... /
+        \
+        -Fetching CPC List.... /
+         done!
+         done!
+        ****************************************************************************************************
+        List of CPCs available
+        1    P000S67B
+        
+        Select cpc by index from the given list [1]              :1
+        
+        ****************************************************************************************************
+        CPC P000S67B is selected
+        ****************************************************************************************************
+        Choose one of the below options:
+        
+        1.  create n partitions from existing templates?
+        2.  create a partition based on another partition?
+        3.  Export Partition Inventory?
+        4.  Import Partition Inventory? 
+        
+        Select an option by index [2]              :1
+        
+        Choose one of the below Templates:
+        
+        1 .          test_template
+        2 .          HariTest1_template
+        
+        Select a template available to create partition: []              :1
+        
+        Enter the number of partitions to be created  []              :3
+        
+        ****************************************************************************************************
+        Creating Partition 1
+        ****************************************************************************************************
+        Creating Partition.... /
+         done!
+        Creating VNics.... done!
+        Creating HBAs.... done!
+        Creating VirtualFunctions.... done!
+        Configuring Cryptos.... done!
+        
+        Updating Partition Properties.... /
+         done!
+        Retrieve and Verify Partition Properties.... /
+         done!
+        Partition: test_902R Created Successfully
+        ****************************************************************************************************
+        Creating Partition 2
+        ****************************************************************************************************
+        Creating Partition.... /
+         done!
+        Creating VNics.... done!
+        Creating HBAs.... done!
+        Creating VirtualFunctions.... done!
+        Configuring Cryptos.... done!
+        
+        Updating Partition Properties.... /
+         done!
+        Retrieve and Verify Partition Properties.... /
+         done!
+        Partition: test_A0WM Created Successfully
+        ****************************************************************************************************
+        Creating Partition 3
+        ****************************************************************************************************
+        Creating Partition.... /
+         done!
+        Creating VNics.... done!
+        Creating HBAs.... done!
+        Creating VirtualFunctions.... done!
+        Configuring Cryptos.... done!
+        
+        Updating Partition Properties.... /
+         done!
+        Retrieve and Verify Partition Properties.... /
+         done!
+        Partition: test_34L6 Created Successfully
+        ****************************************************************************************************
+        Partition Created Successfully from template
+        
+        ****************************************************************************************************
+        
+        ****************************************************************************************************
+        Process Completed
+        ****************************************************************************************************
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+Platform: any
diff --git a/partitionengine.egg-info/SOURCES.txt b/partitionengine.egg-info/SOURCES.txt
new file mode 100644
index 0000000..1034493
--- /dev/null
+++ b/partitionengine.egg-info/SOURCES.txt
@@ -0,0 +1,16 @@
+setup.py
+partitionengine/Console.py
+partitionengine/CreateTemplate.py
+partitionengine/CreateTemplatePartition.py
+partitionengine/__init__.py
+partitionengine/delete_all.py
+partitionengine.egg-info/PKG-INFO
+partitionengine.egg-info/SOURCES.txt
+partitionengine.egg-info/dependency_links.txt
+partitionengine.egg-info/entry_points.txt
+partitionengine.egg-info/top_level.txt
+partitionengine/logs/console.log
+partitionengine/utils/__init__.py
+partitionengine/utils/wsaconst.py
+partitionengine/utils/wsaglobals.py
+partitionengine/utils/wsautils.py
\ No newline at end of file
diff --git a/partitionengine.egg-info/dependency_links.txt b/partitionengine.egg-info/dependency_links.txt
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/partitionengine.egg-info/dependency_links.txt
@@ -0,0 +1 @@
+
diff --git a/partitionengine.egg-info/entry_points.txt b/partitionengine.egg-info/entry_points.txt
new file mode 100644
index 0000000..a75c2e9
--- /dev/null
+++ b/partitionengine.egg-info/entry_points.txt
@@ -0,0 +1,3 @@
+[console_scripts]
+partitionengine = partitionengine.Console:main
+
diff --git a/partitionengine.egg-info/top_level.txt b/partitionengine.egg-info/top_level.txt
new file mode 100644
index 0000000..7ac5c95
--- /dev/null
+++ b/partitionengine.egg-info/top_level.txt
@@ -0,0 +1 @@
+partitionengine
diff --git a/partitionengine/Console.py b/partitionengine/Console.py
new file mode 100755
index 0000000..912aeca
--- /dev/null
+++ b/partitionengine/Console.py
@@ -0,0 +1,322 @@
+from getpass import *
+
+#from babel.messages.catalog import Catalog
+
+from CreateTemplate import *
+from CreateTemplatePartition import *
+from utils.wsautils import *
+import ConfigParser
+
+
+session = None
+
+
+CONFIG_FILE=".saved-settings"
+config = ConfigParser.RawConfigParser()
+
+
+def print_helper(print_string=None, operationFailed=False, exception=None):
+    string_out = ''
+    if (operationFailed):
+        string_out += ("\n" + "*"*100)
+        string_out += ("\n**********************************Operation Failed**************************************************")
+        
+    else:
+        string_out += ("\n" + "*"*100)
+    string_out += ("\n" + print_string)
+    string_out += ("\n" + "*"*100)
+    print string_out
+    logging.debug(string_out)
+    if not (exception == None):
+        logging.debug("Failure Reason:")
+        logging.debug(exception)
+        exc_type, exc_value, exc_traceback = sys.exc_info()
+        traceback_details = {
+                         'filename': exc_traceback.tb_frame.f_code.co_filename,
+                         'lineno'  : exc_traceback.tb_lineno,
+                         'name'    : exc_traceback.tb_frame.f_code.co_name,
+                         'type'    : exc_type.__name__,
+                         'message' : exc_value.message, # or see traceback._some_str()
+                        }
+        del(exc_type, exc_value, exc_traceback)
+        logging.debug(traceback.format_exc())
+        
+    return
+        
+
+
+
+
+
+finalSelectedOption = 0
+def option_choser(queryString='Choose from Index',option_title='', indexLength=0,chosenOption = 0):
+    logging.info('option_choser method invoked') 
+    if chosenOption < 1 or chosenOption > indexLength:
+        try:
+            chosenOption = int(user_input('\n'+queryString, 'OPTIONS', option_title))#raw_input('\n' + queryString.ljust(30) + ':'))         
+        except:
+            print("Invalid Value!!! ")
+        option_choser(queryString,option_title,indexLength,chosenOption)
+    else:
+        global finalSelectedOption
+        finalSelectedOption = chosenOption   
+    logging.debug("chosen option: " + str(chosenOption))
+    return finalSelectedOption
+
+def createPartitionIteratively(temp_name='', no_of_partitions=0, cpc_uri=''):
+    logging.info('-> createPartitionIteratively for the templatename ' + temp_name + " number of Partitions: " + str(no_of_partitions) + " CPC URI: " + cpc_uri)
+    partionList=dict();
+    for num in range(0, no_of_partitions):
+        print_helper("Creating Partition " + str(num+1), False)
+        try:
+            partition_unique_name,part_uri=createTemplatePartition(temp_name, session, cpc_uri, ''.join(random.choice(string.ascii_uppercase + string.digits) for num in range(4)))
+        except Exception as ex:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(ex))
+        except:
+            print_helper('Partition Creation failed while creating partition number' + num , True, str(sys.exc_info()[:2]))
+        #partionList[partition_unique_name] = part_uri
+    logging.info('<- createPartitionIteratively')
+    return partionList
+
+def createPartitionFromTemplate(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromTemplate')
+    partitionStatus=''
+    try:
+        template_dir_name = os.path.join(os.path.dirname(os.path.abspath(__file__)) , 'templates/cpc_' + cpc_name);
+        logging.debug(template_dir_name)
+        if not(os.path.isdir(template_dir_name)):
+            print_helper("No Template File exists")
+            return
+        template_files = os.listdir(template_dir_name)
+        logging.debug('template_files ' + str(template_files))
+        
+        print("\nChoose one of the below Templates:\n")
+        
+        for index in range(0, len(template_files)):
+            print index + 1, '. '.ljust(10), os.path.splitext(template_files[index])[0]
+        selected_template = option_choser("Select a template available to create partition:","TEMPLATE" ,len(template_files))
+        
+        temp_name = template_files[selected_template - 1]
+        logging.debug("Selected Template..." + temp_name)
+        
+        no_of_partitions = option_choser('Enter the number of partitions to be created ',"PARTITIONCOUNT", 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/cpc_' + cpc_name, temp_name)
+        logging.debug('template_name ' + template_name)
+        
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        partitionList=createPartitionIteratively(template_name, no_of_partitions, cpc_uri)
+        partitionStatus = 'Partition Created Successfully from template\n'
+        for part in partitionList.keys():
+        
+            partitionStatus+= 'Partition Name: '+part+'\n'
+            partitionStatus+= 'Partition URI: ' +partitionList[part]+'\n'
+    except:
+        print_helper('Partition Creation failed to create from given Template', True, str(sys.exc_info()[:2]))
+    logging.info('<-createPartitionFromTemplate')    
+    
+    print_helper(partitionStatus, False)
+    
+    print_helper("Process Completed", False)    
+    return
+
+def createPartitionFromPartition(cpc_name='', cpc_uri=''):
+    logging.info('->createPartitionFromPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        for  index in range(0, len(partitions)):
+            print index + 1, '  ', partitions[index]['name']
+        partition_option = option_choser('Select partition by index','PARTITION_INDEX', len(partitions))
+        
+        partition_name = partitions[partition_option - 1]['name']
+        no_of_partitions = option_choser('Enter the number of partitions to be created ','NUMPARTS', 100)
+        logging.debug('no_of_partitions' + str(no_of_partitions))
+        
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        
+        
+        
+        temp_name = createTemplate(session,[partitions[partition_option - 1]], cpc_name, partition_name)
+        logging.debug('template_name '+ temp_name)
+        
+        time.sleep(1)
+        p.stop()      
+        
+        time.sleep(2)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("File not found: " + temp_name)
+        
+        createPartitionIteratively(temp_name, no_of_partitions, cpc_uri)
+    except:
+        print_helper('Partition Creation failed to create from chosen partition ' + partition_name, True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-createPartitionFromPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def exportPartition(cpc_name="",cpc_uri=""):
+    logging.info('->exportPartition')
+    try:
+        part = session.get(cpc_uri + '/partitions')
+        partitions = part.body['partitions']
+        temp_name = createTemplate(session,partitions, cpc_name)
+        p = progress_bar_loading()
+        p.configure("Fetching Partition Inventory...")
+        p.start() 
+        time.sleep(1)
+        p.stop()
+        time.sleep(2)   
+        logging.debug('template_name '+ temp_name)
+        
+        if not(os.path.isfile(temp_name)):
+            raise IOError("Partition Inventory is not exported to the file " + temp_name)
+    except:
+        print_helper('Partition Export failed', True, str(sys.exc_info()[:2]))
+        time.sleep(1)
+        p.stop() 
+    logging.info('<-exportPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def importPartition(cpc_name='', cpc_uri=''):
+    logging.info('->importPartition')
+    try:
+        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/base_' + cpc_name, 'base_template.json')
+        logging.debug('template_name '+ template_name)
+        if not(os.path.isfile(template_name)):
+            raise IOError("File not found: " + template_name)
+        createTemplatePartition(template_name, session, cpc_uri)
+    except:
+        print_helper("Sorry! There is no backup inventory for the CPC selected", True, str(sys.exc_info()[:2]))
+    logging.info('<-importPartition')
+    
+    print_helper("Successfully Completed", False)    
+    return
+
+def readConfig():
+    config.read('savedsettings.cfg')
+    return config
+
+def updateConfig(params=None):
+    with open('savedsettings.cfg', 'wb') as configfile:
+        config.write(configfile)
+    return
+
+def user_input(inputStr='',section='',parameter='', password=False):
+    config = readConfig()
+    
+    userinput=''
+    
+    try: 
+        value=config.get(section, parameter)
+    except ConfigParser.NoSectionError:
+        if not section == '':
+            config.add_section(section)
+        value = ''
+    except:
+        value = ''    
+    if password:
+        userinput=getpass(inputStr.ljust(15) + ':')        
+    else:
+        userinput=raw_input(inputStr +' ['+ value + ']'.ljust(15) + ':')
+        
+    if not userinput == '':
+        value = userinput
+       
+    if not parameter=='':
+        config.set(section,parameter,value)
+    updateConfig()
+    return value 
+
+
+
+def main():
+    initializeLogging()
+    logging.info('Starting the PartitionManagementTemplating Tool')
+    print "*"*100
+    print "Capture and replay partition creation".center(100)
+    print "*"*100   
+    
+            
+    hmc_ip = user_input('Enter HMC IP', 'BASE_PARAMS', 'HMC_IP')#raw_input('Enter HMC IP ['+ config.get('BASE_PARAMS', 'HMC_IP') + ']'.ljust(30) + ':')
+    hmc_user = user_input('Enter Username', 'BASE_PARAMS', 'HMC_USER')#raw_input('Enter Username ['+ config.get('BASE_PARAMS', 'HMC_USER') + ']'.ljust(30) + ':')
+    hmc_password = user_input('Enter Password','','',True)#('Enter Password'.ljust(30) + ':')
+    
+    #hmc_ip = '9.152.151.49'
+    #hmc_user = 'pedebug'
+    #hmc_password = 'password'
+    # print hmc_password
+    logging.debug('hmc_ip: '+hmc_ip+' hmc_user '+hmc_user+' hmc_password '+hmc_password)
+    cpcs = []
+    global session
+    try:
+        
+        p = progress_bar_loading()
+        p.configure("Establishing session")
+        p.start()     
+        session = session_startup(host=hmc_ip, user=hmc_user, pwd=hmc_password)
+        logging.debug("Printing the session details... /n"+ str(session))
+        time.sleep(2)
+        p.stop()
+        
+        p = progress_bar_loading()
+        p.configure("Fetching CPC List")
+        p.start()
+        cpcs = list_cpcs(session)
+        p.stop()        
+        time.sleep(2)
+        
+        logging.debug("Printing the cpcs... /n"+ str(cpcs))
+    except ApiFatalException as ex:
+        print_helper("Sorry! Session could not be established. Please verify the IP, HMC Username/Password", True)
+        time.sleep(1)
+        p.stop() 
+        return
+    
+    print "****************************************************************************************************"
+    if len(cpcs) > 0:        
+        print "List of CPCs available"
+    else:
+        print_helper("No CPCs managed by the HMC!!!")
+        return
+    
+    
+    for  index in range(0, len(cpcs)):
+        print index + 1, '  ', cpcs[index]['name']
+    
+    try:
+        cpc_option = option_choser("Select cpc by index from the given list",'CPCSEL', len(cpcs))
+    
+        cpc_uri = cpcs[cpc_option - 1]['object-uri']
+        cpc_name = cpcs[cpc_option - 1]['name']
+        print_helper('CPC ' + cpc_name + ' is selected')
+        print("Choose one of the below options:")
+        options = '\n1.  create n partitions from existing templates?\n2.  create a partition based on another partition?\n3.  Export Partition Inventory?\n4.  Import Partition Inventory? '
+        print options
+        selected_option = option_choser('Select an option by index','FLAVOR', 4)
+    
+    
+        if selected_option == 1:
+            createPartitionFromTemplate(cpc_name, cpc_uri)
+            
+        elif selected_option == 2:
+            createPartitionFromPartition(cpc_name, cpc_uri)
+            
+        elif selected_option == 3:
+            exportPartition(cpc_name, cpc_uri)
+            
+        if selected_option == 4:
+            importPartition(cpc_name, cpc_uri)
+    except:
+        print_helper('Process Failed ', True, str(sys.exc_info()[:2]))
+   
+main()
diff --git a/partitionengine/CreateTemplate.py b/partitionengine/CreateTemplate.py
new file mode 100755
index 0000000..cd9c35e
--- /dev/null
+++ b/partitionengine/CreateTemplate.py
@@ -0,0 +1,152 @@
+
+import ast
+import json
+import os
+from utils.wsautils import *
+
+
+roce_nic_writable_properties = ['description','device-number','name','network-adapter-port-uri']
+vfn_writable_properties = ['description','device-number','name','adapter-uri']
+vs_nic_writable_properties = ['description','device-number','name','virtual-switch-uri']
+writable_properties = [u'ifl-processing-weight-capped', u'minimum-cp-processing-weight',  u'maximum-ifl-processing-weight', u'access-problem-state-counter-set', u'ifl-processors',  u'cp-absolute-processor-capping-value',  u'reserve-resources', u'maximum-memory', u'boot-timeout', u'boot-os-specific-parameters',  u'processor-management-enabled', u'boot-device', u'access-basic-sampling', u'cp-absolute-processor-capping',  u'boot-record-lba', u'permit-cross-partition-commands', u'acceptable-status', u'maximum-cp-processing-weight', u'minimum-ifl-processing-weight',   u'access-global-performance-data', u'cp-processing-weight-capped', u'permit-aes-key-import-functions',  u'ifl-absolute-processor-capping-value', u'initial-ifl-processing-weight', u'access-extended-counter-set',  u'initial-cp-processing-weight', u'access-crypto-activity-counter-set', u'initial-memory', u'access-basic-counter-set', u'name', u'boot-configuration-selector', u'description', u'cp-processors',  u'access-diagnostic-sampling',u'permit-des-key-import-functions', u'processor-mode',u'ifl-absolute-processor-capping', u'access-coprocessor-group-set']
+hba_writable_properties = ['description','device-number','name','adapter-port-uri']
+boot_device = {'storage-adapter':['boot-logical-unit-number','boot-world-wide-port-name','boot-storage-device'],'network-adapter':['boot-network-device'],'ftp':['boot-ftp-host','boot-ftp-insfile','boot-ftp-password','boot-ftp-username'],'iso-image':['boot-iso-image-name','boot-iso-ins-file'],'removable-media':['boot-removable-media', 'boot-removable-media-type']}
+global nic_device_uri
+global hba_device_uri
+    
+class Object:
+    def to_JSON(self):
+        return json.dumps(self, default=lambda o: o.__dict__, 
+            sort_keys=True, indent=4)
+class Payload(object):
+    def __init__(self, j):
+        self.__dict__ = json.loads(j)
+        
+        
+def getNicList(session,ob,ob1):
+    logging.info('->getNicList')
+    nic_list = []
+    global nic_device_uri
+    for nic in getattr(ob,'nic-uris'):
+        logging.debug(str(nic))
+        response = session.get(nic)
+        
+        logging.debug(str(response.body))
+        nic_ob1= Payload(json.dumps(response.body))
+        nic_ob = Object()
+        for key in nic_ob1.__dict__.keys():
+            if response.body['type'] == 'roce':
+                if key in roce_nic_writable_properties:
+                    logging.debug(str(getattr(nic_ob1,key)))
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            else:
+                #print key
+                if key in vs_nic_writable_properties:
+                    setattr(nic_ob,key,getattr(nic_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'network-adapter' and getattr(nic_ob1, key) == nic_device_uri:
+                    setattr(ob1, 'nic-boot-device-number', getattr(nic_ob1, 'device-number')) 
+        nic_list.append(nic_ob)
+        
+        logging.debug(str(nic_list));
+        logging.info('<-getNicList')
+    return nic_list 
+
+def getHbaList(session,ob,ob1):
+    logging.info('->getHbaList')
+    hba_list = []
+    global hba_device_uri
+    for hba in getattr(ob,'hba-uris'):
+        response = session.get(hba)
+        hba_ob = Object()
+        hba_ob1= Payload(json.dumps(response.body))
+        for key in hba_ob1.__dict__.keys():
+            if key in hba_writable_properties:
+                setattr(hba_ob,key,getattr(hba_ob1,key))
+            if key == 'element-uri':
+                if getattr(ob, 'boot-device') == 'storage-adapter' and getattr(hba_ob1, key) == hba_device_uri:
+                    setattr(ob1, 'hba-boot-device-number', getattr(hba_ob1, 'device-number')) 
+        hba_list.append(hba_ob)
+    logging.info('<-getHbaList')
+    return hba_list 
+
+def getVfnList(session,ob):
+    logging.info('->getVfnList')
+    vfn_list = []
+    for vfn in getattr(ob,'virtual-function-uris'):
+        response = session.get(vfn)
+        vfn_ob = Object()
+        vfn_ob1= Payload(json.dumps(response.body))
+        for key in vfn_ob1.__dict__.keys():
+            if key in vfn_writable_properties:
+                setattr(vfn_ob,key,getattr(vfn_ob1,key))
+    
+        vfn_list.append(vfn_ob)
+    logging.info('<-getVfnList')
+    return vfn_list 
+
+def setBootDevice(ob,ob1):
+    logging.info('->setBootDevice')
+    global hba_device_uri
+    global nic_device_uri
+    if getattr(ob, 'boot-device') == 'storage-adapter':
+        hba_device_uri = getattr(ob, 'boot-storage-device')
+            
+    if getattr(ob, 'boot-device') == 'network-adapter':
+        nic_device_uri = getattr(ob, 'boot-network-device')
+           
+    if getattr(ob, 'boot-device') in boot_device.keys():
+        for boot_property in boot_device[getattr(ob, 'boot-device')]:
+            setattr(ob1,boot_property,getattr(ob, boot_property))
+    logging.info('<-setBootDevice')
+    return
+                
+def getPartitionTemplate(session,inv_response,partition_list):
+    logging.info('Retriving the partition info and loading into template....')
+    logging.info('->getPartitionTemplate')
+    ob1 = Object()
+    ob = Payload(json.dumps(inv_response))
+    for key in ob.__dict__.keys():
+        if key in writable_properties:
+            setattr(ob1,key,getattr(ob,key))
+        if key == 'crypto-configuration':
+            setattr(ob1,'cryptos',getattr(ob,key))
+    setBootDevice(ob, ob1)
+    nic_list = getNicList(session,ob,ob1)
+    hba_list = getHbaList(session, ob,ob1)
+    vfn_list = getVfnList(session, ob)
+    setattr(ob1,'nics',nic_list)
+    setattr(ob1,'virtual-functions',vfn_list)
+    setattr(ob1,'hbas',hba_list)
+    partition_list.append(ob1)
+    logging.info('<-getPartitionTemplate')
+    return partition_list
+        
+def createTemplate(session,inv_response,cpc_name,partition_name = None):
+    logging.info('->createTemplate')
+    logging.debug(str(inv_response))
+    partition_list = []
+    complete = Object()
+    for partition in inv_response:
+            response = session.get(partition['object-uri'])
+            complete = Object()
+            partition_list = getPartitionTemplate(session, response.body, partition_list) 
+            
+    setattr(complete,'partition',partition_list)  
+    if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates'):
+        os.mkdir(os.path.dirname(os.path.abspath(__file__))+'/templates')
+    if partition_name == None:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/base_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name,'base_template.json')
+    else:
+        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/cpc_'+cpc_name):
+            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name))
+        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name,partition_name+'_template.json')
+    file = open(file_name,'w+')        
+    file.write(complete.to_JSON())
+    file.close()
+    logging.info('template created successfully...')
+    logging.info('<-createTemplate')
+    
+    return file_name
diff --git a/partitionengine/CreateTemplatePartition.py b/partitionengine/CreateTemplatePartition.py
new file mode 100755
index 0000000..5e06d02
--- /dev/null
+++ b/partitionengine/CreateTemplatePartition.py
@@ -0,0 +1,147 @@
+
+import ast
+import json
+import random
+
+from utils.wsautils import *
+
+import sys
+import time
+import threading
+
+
+
+
+
+def remove(body,keys_list):
+    for key in keys_list:
+        if key in body.keys():
+            del body[key]
+
+def createTemplatePartition(temp_filename,session,cpc,partition_unique_name=None):
+    logging.info('==>>################# createTemplatePartition invoked#################')
+    logging.debug('Template file name: '+ temp_filename)
+    logging.debug('cpc uri: '+ cpc)
+    logging.debug('Partition unique name: '+ str(partition_unique_name))
+    temp_file = open(temp_filename,'r')
+    json_text = temp_file.read()
+    ip = json.loads((json_text))
+    ip_body = ip['partition']
+    p = progress_bar_loading()
+    try:
+        for partition in ip_body:
+            body = {'processor-mode':partition['processor-mode'], 'initial-memory':partition['initial-memory'],'maximum-memory':partition['maximum-memory']}
+            if partition_unique_name != None:
+                body.update({'name':partition['name']+'_'+str(partition_unique_name)})
+            else:
+                body.update({'name':partition['name']})
+            if partition['cp-processors'] != 0:
+                body.update({'cp-processors':partition['cp-processors']})
+            else:
+                body.update({'ifl-processors':partition['ifl-processors']})
+                
+            p = progress_bar_loading()
+            p.configure("Creating Partition")
+            p.start()
+            response = session.post(cpc+'/partitions',json.dumps(body))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Respose from partitions Post request" + str(response)) 
+            
+            
+            part_uri = response.body['object-uri']
+            logging.debug("Partition URI from newly created partition" + part_uri)
+            
+            
+            p = progress_bar_loading()
+            p.configure("Creating VNics")
+            p.start()   
+            for nic in partition['nics']:
+                logging.info("Iterating through nic URIS")            
+                response = session.post(part_uri+'/nics',json.dumps(nic))            
+                logging.debug("Respose from nics Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'network-adapter') and (nic['device-number'] == partition['nic-boot-device-number']) :            
+                    nicRes = response.body['element-uri']
+                    partition['boot-network-device'] = nicRes
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+             
+             
+            p = progress_bar_loading()
+            p.configure("Creating HBAs")
+            p.start()       
+            for hba in partition['hbas']:
+                logging.info("Iterating through hba URIS")
+                
+                response = session.post(part_uri+'/hbas',json.dumps(hba))
+                
+                logging.debug("Respose from hbas Post request" + str(response)) 
+                
+                if (partition['boot-device'] == 'storage-adapter') and (hba['device-number'] == partition['hba-boot-device-number']) :            
+                    hbaRes = response.body['element-uri']
+                    partition['boot-storage-device'] = hbaRes
+                 
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            
+            p = progress_bar_loading()
+            p.configure("Creating VirtualFunctions")
+            p.start()       
+            for vfn in partition['virtual-functions']:
+                logging.info("Iterating through virtual-functions URIS")
+                
+                response = session.post(part_uri+'/virtual-functions',json.dumps(vfn))
+                
+                
+                logging.debug("Respose from virtual-functions Post request" + str(response))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            p = progress_bar_loading()
+            p.configure("Configuring Cryptos")
+            p.start()
+            if partition['cryptos'] != None:
+                logging.info("Adding crypto configurations")
+                
+                response = session.post(part_uri+'/operations/increase-crypto-configuration',json.dumps(partition['cryptos']))
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+                
+            remove(partition,['nics','hbas','virtual-functions','name','hba-boot-device-number','nic-boot-device-number','cryptos'])
+            logging.debug("Removed unwanted attributes")
+            
+            p = progress_bar_loading()
+            p.configure("\nUpdating Partition Properties")        
+            p.start()
+            response = session.post(part_uri,json.dumps(partition))        
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            logging.debug("Response from Update Partition request"+ str(response))
+            
+            
+            p = progress_bar_loading()
+            p.configure("Retrieve and Verify Partition Properties")        
+            p.start()
+            response = session.get(part_uri)            
+            time.sleep(1)
+            p.stop()
+            time.sleep(2)
+            
+            if(response.status == 200):
+                sys.stdout.write("Partition: " + response.body['name']+" Created Successfully" )
+            logging.debug("Partition Properties"+ str(response))
+    except:
+        time.sleep(1)
+        p.stop()
+        raise
+        
+    logging.info('<<=########## createTemplatePartition invoked#########')
+    return partition_unique_name,part_uri
\ No newline at end of file
diff --git a/partitionengine/__init__.py b/partitionengine/__init__.py
new file mode 100755
index 0000000..e69de29
diff --git a/partitionengine/delete_all.py b/partitionengine/delete_all.py
new file mode 100755
index 0000000..74fda68
--- /dev/null
+++ b/partitionengine/delete_all.py
@@ -0,0 +1,14 @@
+'''
+Created on Apr 13, 2016
+
+@author: sowmya
+'''
+from utils.wsautils import *
+
+session= session_startup(host='9.12.38.77')
+cpc_uri = list_cpcs(session)[0]['object-uri']
+part = session.get(cpc_uri+'/partitions')
+print part
+
+for partition in part.body['partitions']:
+    print session.delete(partition['object-uri'])
diff --git a/partitionengine/logs/console.log b/partitionengine/logs/console.log
new file mode 100644
index 0000000..78b5c33
--- /dev/null
+++ b/partitionengine/logs/console.log
@@ -0,0 +1 @@
+Wed, 14 Sep 2016 15:48:29 INFO     Starting the PartitionManagementTemplating Tool
diff --git a/partitionengine/savedsettings.cfg b/partitionengine/savedsettings.cfg
new file mode 100755
index 0000000..27c0748
--- /dev/null
+++ b/partitionengine/savedsettings.cfg
@@ -0,0 +1,12 @@
+[BASE_PARAMS]
+hmc_ip = 9.152.151.49
+hmc_user = pedebug
+
+[OPTIONS]
+cpcsel = 1
+flavor = 1
+partition_index = 1
+numparts = 1
+template = 1
+partitioncount = 3
+
diff --git a/partitionengine/templates/base_ANIL2SE/base_template.json b/partitionengine/templates/base_ANIL2SE/base_template.json
new file mode 100755
index 0000000..a735671
--- /dev/null
+++ b/partitionengine/templates/base_ANIL2SE/base_template.json
@@ -0,0 +1,178 @@
+{
+    "partition": [        
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_BAWC", 
+            "nics": [
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }, 
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF", 
+            "nics": [
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
diff --git a/partitionengine/templates/base_P000S67B/base_template.json b/partitionengine/templates/base_P000S67B/base_template.json
new file mode 100755
index 0000000..908db2f
--- /dev/null
+++ b/partitionengine/templates/base_P000S67B/base_template.json
@@ -0,0 +1,50 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "test-operating-system", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": 1.0, 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 1, 
+            "cryptos": null, 
+            "description": "", 
+            "hbas": [], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": 1.0, 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "test", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template.json b/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template.json
new file mode 100755
index 0000000..221f17f
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template.json
@@ -0,0 +1,50 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": null, 
+            "description": "", 
+            "hbas": [], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 1024, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 1024, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "CPC_2_20423", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json b/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json
new file mode 100755
index 0000000..fcb0939
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json
@@ -0,0 +1,50 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": null, 
+            "description": "", 
+            "hbas": [], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 1024, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 1024, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "CPC_2_20423_template_LXSD", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template.json
new file mode 100755
index 0000000..cd2aed4
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template.json
@@ -0,0 +1,91 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition", 
+            "nics": [
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json
new file mode 100755
index 0000000..4c0a25d
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json
@@ -0,0 +1,93 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "network-adapter", 
+            "boot-network-device": "/api/partitions/e47b85a8-0205-11e6-9e8f-02c20001b57e/nics/e7d94c76-0205-11e6-9e8f-02c20001b57e", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF_AMUO", 
+            "nic-boot-device-number": "0004", 
+            "nics": [
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json
new file mode 100755
index 0000000..22ebf1f
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json
@@ -0,0 +1,93 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "network-adapter", 
+            "boot-network-device": "/api/partitions/1121c1e2-0203-11e6-ac1a-02c20001b57e/nics/1463ace4-0203-11e6-9e8f-02c20001b57e", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF_RWB9", 
+            "nic-boot-device-number": "0004", 
+            "nics": [
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json
new file mode 100755
index 0000000..41ce228
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json
@@ -0,0 +1,93 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "network-adapter", 
+            "boot-network-device": "/api/partitions/6ea4993e-019f-11e6-84a8-02c20001b57e/nics/730be194-019f-11e6-84a8-02c20001b57e", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF", 
+            "nic-boot-device-number": "0004", 
+            "nics": [
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json
new file mode 100755
index 0000000..102c2fe
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json
@@ -0,0 +1,95 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "storage-adapter", 
+            "boot-logical-unit-number": "1111122331232324", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "", 
+            "boot-storage-device": "/api/partitions/c5146d8a-01f4-11e6-9e8f-02c20001b57e/hbas/cf1b1aa4-01f4-11e6-b9cd-02c20001b57e", 
+            "boot-timeout": 60, 
+            "boot-world-wide-port-name": "1111111111123422", 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hba-boot-device-number": "0007", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF_template_C99M", 
+            "nics": [
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json
new file mode 100755
index 0000000..ce2533e
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json
@@ -0,0 +1,95 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "storage-adapter", 
+            "boot-logical-unit-number": "1111122331232324", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "", 
+            "boot-storage-device": "/api/partitions/4aeb3330-01f5-11e6-ac1a-02c20001b57e/hbas/54a1fcba-01f5-11e6-ac1a-02c20001b57e", 
+            "boot-timeout": 60, 
+            "boot-world-wide-port-name": "1111111111123422", 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 3, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 0
+                    }, 
+                    {
+                        "access-mode": "control", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hba-boot-device-number": "0007", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
+                    "description": "for testing storage adapter", 
+                    "device-number": "0007", 
+                    "name": "TestHBA"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "TestPartition_template_FPUF_template_C99M_template_NAVY", 
+            "nics": [
+                {
+                    "description": "for testing nic", 
+                    "device-number": "0001", 
+                    "name": "TestNIC", 
+                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
+                }, 
+                {
+                    "description": "", 
+                    "device-number": "0004", 
+                    "name": "TestNIC3", 
+                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
+                }
+            ], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": [
+                {
+                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
+                    "description": "for testing virtual function", 
+                    "device-number": "0002", 
+                    "name": "TestVirtualFunction"
+                }
+            ]
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json b/partitionengine/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json
new file mode 100755
index 0000000..9044ba9
--- /dev/null
+++ b/partitionengine/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json
@@ -0,0 +1,60 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "none", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 1, 
+            "cryptos": {
+                "crypto-adapter-uris": [
+                    "/api/adapters/df3a888a-f893-11e5-84a2-02c20001b57e"
+                ], 
+                "crypto-domain-configurations": [
+                    {
+                        "access-mode": "control-usage", 
+                        "domain-index": 1
+                    }
+                ]
+            }, 
+            "description": "", 
+            "hbas": [], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 1024, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 2048, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "VSM_2_20478_1", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_P000S67B/HariTest1_template.json b/partitionengine/templates/cpc_P000S67B/HariTest1_template.json
new file mode 100755
index 0000000..7cbf550
--- /dev/null
+++ b/partitionengine/templates/cpc_P000S67B/HariTest1_template.json
@@ -0,0 +1,61 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 1, 
+            "boot-device": "storage-adapter", 
+            "boot-logical-unit-number": "1111111111111111", 
+            "boot-os-specific-parameters": "blah", 
+            "boot-record-lba": "456", 
+            "boot-storage-device": "/api/partitions/1b472a76-fb38-11e5-8417-40f2e9ef1644/hbas/1c12715e-fb38-11e5-9217-40f2e9ef1644", 
+            "boot-timeout": 60, 
+            "boot-world-wide-port-name": "0001000000000000", 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": "1.0", 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 1, 
+            "cryptos": null, 
+            "description": "", 
+            "hba-boot-device-number": "0001", 
+            "hbas": [
+                {
+                    "adapter-port-uri": "/api/adapters/bd9cfba0-f040-11e5-a770-42f2e9ef1641/storage-ports/0", 
+                    "description": "", 
+                    "device-number": "0001", 
+                    "name": "HariTest1"
+                }
+            ], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": "1.0", 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "HariTest1", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/templates/cpc_P000S67B/test_template.json b/partitionengine/templates/cpc_P000S67B/test_template.json
new file mode 100644
index 0000000..908db2f
--- /dev/null
+++ b/partitionengine/templates/cpc_P000S67B/test_template.json
@@ -0,0 +1,50 @@
+{
+    "partition": [
+        {
+            "acceptable-status": [
+                "active"
+            ], 
+            "access-basic-counter-set": false, 
+            "access-basic-sampling": false, 
+            "access-coprocessor-group-set": false, 
+            "access-crypto-activity-counter-set": false, 
+            "access-diagnostic-sampling": false, 
+            "access-extended-counter-set": false, 
+            "access-global-performance-data": false, 
+            "access-problem-state-counter-set": false, 
+            "boot-configuration-selector": 0, 
+            "boot-device": "test-operating-system", 
+            "boot-os-specific-parameters": "", 
+            "boot-record-lba": "0", 
+            "boot-timeout": 60, 
+            "cp-absolute-processor-capping": false, 
+            "cp-absolute-processor-capping-value": 1.0, 
+            "cp-processing-weight-capped": false, 
+            "cp-processors": 1, 
+            "cryptos": null, 
+            "description": "", 
+            "hbas": [], 
+            "ifl-absolute-processor-capping": false, 
+            "ifl-absolute-processor-capping-value": 1.0, 
+            "ifl-processing-weight-capped": false, 
+            "ifl-processors": 0, 
+            "initial-cp-processing-weight": 100, 
+            "initial-ifl-processing-weight": 100, 
+            "initial-memory": 4096, 
+            "maximum-cp-processing-weight": 999, 
+            "maximum-ifl-processing-weight": 999, 
+            "maximum-memory": 4096, 
+            "minimum-cp-processing-weight": 1, 
+            "minimum-ifl-processing-weight": 1, 
+            "name": "test", 
+            "nics": [], 
+            "permit-aes-key-import-functions": true, 
+            "permit-cross-partition-commands": false, 
+            "permit-des-key-import-functions": true, 
+            "processor-management-enabled": false, 
+            "processor-mode": "shared", 
+            "reserve-resources": false, 
+            "virtual-functions": []
+        }
+    ]
+}
\ No newline at end of file
diff --git a/partitionengine/utils/__init__.py b/partitionengine/utils/__init__.py
new file mode 100755
index 0000000..e69de29
diff --git a/partitionengine/utils/__init__.pyc b/partitionengine/utils/__init__.pyc
new file mode 100644
index 0000000..4367e53
Binary files /dev/null and b/partitionengine/utils/__init__.pyc differ
diff --git a/partitionengine/utils/wsaconst.py b/partitionengine/utils/wsaconst.py
new file mode 100755
index 0000000..b16f4d9
--- /dev/null
+++ b/partitionengine/utils/wsaconst.py
@@ -0,0 +1,685 @@
+
+WSA_CONST_VERSION = "1.1"  # Current version of the API constants
+
+# Make a copy of the input array.  This copy contains lowercase versions of each
+# array element that is not already lowercase.
+def make_lowercase_copy(tokens):
+    lower_tokens = []
+    for token in tokens:
+        lower_token = token.lower()
+        #print "token: %s (%s)" % (token, lower_token)
+        if lower_token not in tokens:
+            lower_tokens.append(lower_token)
+        #print "lower_tokens(%s): %s" % (len(lower_tokens), lower_tokens)
+    return lower_tokens
+
+# ??? FVT regression test framework to-do's
+# - Need to add testcase_properties definition to all existing testcases.  Use this template
+#   and replace the items in angle brackets with the appropriate strings:
+#
+#      testcase_properties = {TC_FULL_NAME : get_testcase_full_filename(),
+#                             TC_COMPONENT : TC_COMPONENT_<component>,
+#                             TC_ID : get_testcase_id(),
+#                             TC_TITLE : '<title>',
+#                             TC_URI : '<uri>',
+#                             TC_MINIMUM_API_VERSION : TC_API_VERSION_<minimum_version>,
+#                             TC_SCENARIO_TYPE : TC_SCENARIO_TYPE_<scenario_type>,
+#                             TC_EXECUTION_TYPE : TC_EXECUTION_TYPE_<execution_type>,
+#                             TC_CAPABILITIES : [<appropriate TC_CAPABILITY_<capability> values, OR empty array>]}
+#
+# x Consider reworking skeleton.py to follow the above model, so that future automated updates are easier,
+#   and as many as possible of these properties can come from the FVT Lotus Notes database. [done]
+#   x Consider adding code to the skeleton to fetch the minimum version out of testcase_properties for
+#     use in a testcase environment check. [done]
+#   x Need to fetch the component, id and title from testcase_properties as well, because they are used
+#     in some print statements at the beginning of the testcase execution. [done]
+# x Need a proper implementation of is_api_version_at_least(). [done]
+# - Should probably add an is_api_version_at_most() method for potential use in the future.
+# - Add a check for required testcase properties???  When?  --get-properties?  --check-properties?
+#   - The list of required properties would be defined in a constant in wsaconst.py
+# x Add support for creating a CSV file of testcases that meet specified criteria? ["done".  Not CSV though.  See runregress.py]
+#   - Add --csv-file option to specify the output CSV filename
+#   - If testcase meets requirements, *append* a line to the CSV file
+#     - If file doesn't exist, create it by writing a header line that defines the columns
+#       - column names and order would be defined in a constant in wsaconst.py
+#   - Requires caller to erase any leftover CSV file before beginning this run
+# x Add an option to runregress.py to specify a top directory to search for testcases to run 
+#     and run all it finds that meet the requirements. [done]
+#   x The requirements can be specified as a single complex string option which is passed
+#     as a bunch of arguments to the testcase.  Maybe something like this:
+#        runregress.py --top-dir <dir> --requirements "--component SVM --component VSM --scenario success --execution-type self-checking" [done]
+
+
+# The name of the variable that defines a testcase's properties.  
+# Each testcase must define this variable appropriately.
+TESTCASE_PROPERTIES_VARIABLE_NAME = 'testcase_properties'
+
+#############################################################################
+# These constants define property names and values that are used to describe
+# testcases.  They are intended for use in the definition of the 
+# TESTCASE_PROPERTIES_VARIABLE_NAME dictionary in each testcase's source code.
+# Some of them can be specified on the command line as testcase requirements.
+#############################################################################
+# Testcase filename, with full path information
+TC_FULL_NAME = 'full_name'
+
+# Testcase ID.  The numeric ID, typically found in the testcase filename, which is of the form:
+# comp_id.py, where comp is the component and id is the testcase ID.
+TC_ID = 'id'
+
+# Testcase title
+TC_TITLE = 'title'
+
+# Primary URI being tested by this testcase
+TC_URI = 'uri'
+
+# API versions.  They must be defined in such a way that they can be meaningfully supported by the is_api_version_*() methods.
+# Be sure to add any new ones to TC_API_VERSION_LIST.
+TC_MINIMUM_API_VERSION = 'min_api_version'
+TC_MAXIMUM_API_VERSION = 'max_api_version'
+TC_API_VERSION_ZGRYPHON_GA2  = '1.1'
+TC_API_VERSION_ZGRYPHON_GA2A = '1.2'
+TC_API_VERSION_ZHELIX_GA1    = '1.3'
+TC_API_VERSION_ZHELIX_GA2    = '1.4'
+TC_API_VERSION_ZHELIX_GA2A   = '1.5'    # LI 1065 - Support for Shutdown and Power-off Tasks
+TC_API_VERSION_ZSPHINX_GA1   = '1.6'
+TC_API_VERSION_ZSPHINX_GA2   = '1.7'
+TC_API_VERSION_ZMIDAS_GA1    = '1.8'
+# List of all valid API versions, used for command line validation
+TC_API_VERSION_LIST = [TC_API_VERSION_ZGRYPHON_GA2, TC_API_VERSION_ZGRYPHON_GA2A, TC_API_VERSION_ZHELIX_GA1, TC_API_VERSION_ZHELIX_GA2,
+                       TC_API_VERSION_ZHELIX_GA2A, TC_API_VERSION_ZSPHINX_GA1, TC_API_VERSION_ZSPHINX_GA2,TC_API_VERSION_ZMIDAS_GA1]
+
+# Testcase capabilities.  These define API/HMC/SE "capabilities" that are tested by certain testcases.
+# They can be, for example, MCF bundles, line items, parts of line items, ODTs, MCFs, MCLs, optional facilities, etc...
+# Be sure to add any new ones to TC_CAPABILITY_LIST.
+TC_CAPABILITIES = 'capabilities'
+TESTCASE_CAPABILITIES = TC_CAPABILITIES  # ??? Temp duplicate of TC_CAPABILITIES until FVT API database is updated to use TC_CAPABILITIES
+TC_CAPABILITY_ZVM           = 'ZVM'  # This testcase requires a z/VM system
+TC_CAPABILITY_IEDN          = 'IEDN'
+TC_CAPABILITY_QDIO          = 'QDIO'
+TC_CAPABILITY_VSWITCH       = 'VIRTUAL SWITCH'
+TC_CAPABILITY_PRSM          = 'PRSM'
+TC_CAPABILITY_XHYP          = 'X86'
+TC_CAPABILITY_POWERVM       = 'POWER-VM'
+#TC_CAPABILITY_BLADEXHYP     = 'X86-BLADE'
+#TC_CAPABILITY_BLADEPOWER    = 'POWER-BLADE'
+TC_CAPABILITY_BLADEISAOPT   = 'ISAOPT-BLADE'
+TC_CAPABILITY_BLADEDPXI50Z  = 'DPXI50Z-BLADE'
+TC_CAPABILITY_ZAWARE  = 'ZAWARE'
+TC_CAPABILITY_ZBX  = 'ZBX'
+TC_CAPABILITY_ZFX  = 'ZFX'
+TC_CAPABILITY_ZHYP  = 'ZHYP'
+TC_CAPABILITY_ZXN  = 'ZXN' # For zExtension nodes - zFX Mod 001 & zBX Mod 004 nodes
+TC_CAPABILITY_ZBXMOD004 = 'ZBXMOD004'
+# List of all valid capabilities, used for command line validation
+TC_CAPABILITY_LIST = [TC_CAPABILITY_ZVM, TC_CAPABILITY_IEDN, TC_CAPABILITY_QDIO, TC_CAPABILITY_VSWITCH, TC_CAPABILITY_PRSM, TC_CAPABILITY_XHYP, 
+                      TC_CAPABILITY_POWERVM, TC_CAPABILITY_BLADEISAOPT, TC_CAPABILITY_BLADEDPXI50Z, TC_CAPABILITY_ZAWARE]
+TC_CAPABILITY_LIST.extend(make_lowercase_copy(TC_CAPABILITY_LIST))  # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase components
+# Be sure to add any new ones to TC_COMPONENT_LIST.
+TC_COMPONENT = 'component'
+TC_COMPONENT_CONS = 'CONS'  #CreateTemplate
+TC_COMPONENT_CPC  = 'CPC'   #Central Processor Complex
+TC_COMPONENT_CREC = 'CREC'  #Capacity Records
+TC_COMPONENT_EAM  = 'EAM'   #Enterprise Availability Management
+TC_COMPONENT_EM   = 'EM'    #Energy Management
+TC_COMPONENT_EMM  = 'EMM'   #Ensemble Membership Management
+TC_COMPONENT_EMF  = 'EMF'   #Ensemble Measurement Facility
+TC_COMPONENT_GPRO = 'GPRO'  #Group Profiles
+TC_COMPONENT_GRP  = 'GRP'   #Groups
+TC_COMPONENT_GS   = 'GS'    #General Services
+TC_COMPONENT_HVM  = 'HVM'   #Hypervisor Virtualization Management
+TC_COMPONENT_IOM  = 'IOM'   #I/O Configuration Management
+TC_COMPONENT_IPRO = 'IPRO'  #Image Activation Profiles
+TC_COMPONENT_IS   = 'IS'    #Inventory Service
+TC_COMPONENT_LGR  = 'LGR'   #Live Guest Relocation
+TC_COMPONENT_LPAR = 'LPAR'  #Logical Partition
+TC_COMPONENT_LPRO = 'LPRO'  #Load Activation Profile
+TC_COMPONENT_MDM  = 'MDM'   #Monitors Dashboard Metric Groups
+TC_COMPONENT_MS   = 'MS'    #Metrics Service
+TC_COMPONENT_NVM  = 'NVM'   #Network Virtualization Management
+TC_COMPONENT_PPM  = 'PPM'   #Workloads and Performance Management
+TC_COMPONENT_RPRO = 'RPRO'  #Reset Activation Profiles
+TC_COMPONENT_SEC  = 'SEC'   #Security and User Management
+TC_COMPONENT_SVM  = 'SVM'   #Storage Virtualization Management
+TC_COMPONENT_VSM  = 'VSM'   #Virtual Server Management
+TC_COMPONENT_zBX  = 'zBX'   #zEnterprise Blade Extension
+TC_COMPONENT_ZFX  = 'ZFX'   #zEnterprise Flex System
+TC_COMPONENT_ZXN  = 'ZXN'   #zNode for both zFX and zBX nodes
+TC_COMPONENT_HVM_2 = 'HVM_2'#hvm for prsm2
+TC_COMPONENT_SVM_2 = 'SVM_2'#svm for prsm2
+TC_COMPONENT_VSM_2 = 'VSM_2'#vsm for prsm2
+TC_COMPONENT_CPC_2 = 'CPC_2'#cpc for prsm2
+TC_COMPONENT_NVM_2 = 'NVM_2'#nvm for prsm2
+
+# List of all valid components, used for command line validation
+TC_COMPONENT_LIST = [TC_COMPONENT_CONS, TC_COMPONENT_CPC, TC_COMPONENT_CREC, TC_COMPONENT_EAM, TC_COMPONENT_EM, TC_COMPONENT_EMM,
+                     TC_COMPONENT_GPRO, TC_COMPONENT_GRP, TC_COMPONENT_GS, TC_COMPONENT_HVM, TC_COMPONENT_IPRO, TC_COMPONENT_IS,
+                     TC_COMPONENT_LPAR, TC_COMPONENT_LPRO, TC_COMPONENT_MDM, TC_COMPONENT_MS, TC_COMPONENT_NVM, TC_COMPONENT_PPM,
+                     TC_COMPONENT_RPRO, TC_COMPONENT_SVM, TC_COMPONENT_VSM, TC_COMPONENT_SEC,TC_COMPONENT_zBX, 
+                     TC_COMPONENT_HVM_2, TC_COMPONENT_SVM_2,TC_COMPONENT_NVM_2,TC_COMPONENT_VSM_2,TC_COMPONENT_CPC_2]
+TC_COMPONENT_LIST.extend(make_lowercase_copy(TC_COMPONENT_LIST))    # Add lowercase versions as needed, for command line convenience
+
+
+# Testcase scenario type
+# Be sure to add any new ones to TC_SCENARIO_TYPE_LIST.
+TC_SCENARIO_TYPE = 'scenario_type'
+TC_SCENARIO_TYPE_AUTHORIZATION = 'authorization'
+TC_SCENARIO_TYPE_FAILURE       = 'failure'
+TC_SCENARIO_TYPE_NOTIFICATION  = 'notification'
+TC_SCENARIO_TYPE_SUCCESS       = 'success'
+# List of all valid scenario types, used for command line validation
+TC_SCENARIO_TYPE_LIST = [TC_SCENARIO_TYPE_AUTHORIZATION, TC_SCENARIO_TYPE_FAILURE, TC_SCENARIO_TYPE_NOTIFICATION, TC_SCENARIO_TYPE_SUCCESS]
+TC_SCENARIO_TYPE_LIST.extend(make_lowercase_copy(TC_SCENARIO_TYPE_LIST))    # Add lowercase versions as needed, for command line convenience
+
+# Testcase execution type
+# Be sure to add any new ones to TC_EXECUTION_TYPE_LIST.
+TC_EXECUTION_TYPE = 'execution_type'
+TC_EXECUTION_TYPE_DISRUPTIVE               = 'disruptive'
+TC_EXECUTION_TYPE_MANUAL                   = 'manual'
+TC_EXECUTION_TYPE_SELF_CHECKING            = 'self-checking'
+TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE  = 'self-checking-exclusive'
+TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP = 'self-checking-with-setup'
+TC_EXECUTION_TYPE_SUBTEST                  = 'subtest'
+# List of all valid execution types, used for command line validation
+TC_EXECUTION_TYPE_LIST = [TC_EXECUTION_TYPE_DISRUPTIVE, TC_EXECUTION_TYPE_MANUAL, TC_EXECUTION_TYPE_SELF_CHECKING,
+                          TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE, TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP, TC_EXECUTION_TYPE_SUBTEST]
+TC_EXECUTION_TYPE_LIST.extend(make_lowercase_copy(TC_EXECUTION_TYPE_LIST))  # Add lowercase versions as needed, for command line convenience
+
+# Marker lines for output of --get-properties requests
+GET_PROPERTIES_BEGIN_MARKER = "***%s begin***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+GET_PROPERTIES_END_MARKER = "***%s end***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
+
+
+#############################################################################
+# Miscellaneous constants
+#############################################################################
+
+# Flag to indicate whether ODT Z9474 is applied to the target system.  It changes some
+# characteristics of notification messages.  This flag allows the message validation
+# code to react accordingly.
+Z9474_applied = True
+
+
+#############################################################################
+# "Temporary object" support.  These are constants that support the creation
+# (via the various object-specific "create_temporary_<object-type>()" methods)
+# and deletion of "temporary" objects.
+#############################################################################
+
+# System-defined users, used for admin-type operations during testcase scenario setup
+# and cleanup.  These constants are intended for use as values for the KEY_ADMIN_USERID 
+# property in the temporary_object_types_info collection and on calls to get_admin_session(userid).
+ACCESS_ADMINISTRATOR =      'ACSADMIN'
+ADVANCED_OPERATOR =         'ADVANCED'
+ENSEMBLE_ADMINISTRATOR =    'ENSADMIN'
+ENSEMBLE_OPERATOR =         'ENSOPERATOR'
+SYSTEM_OPERATOR =           'OPERATOR'
+SERVICE_REPRESENTATIVE =    'SERVICE'
+SYSTEM_PROGRAMMER =         'SYSPROG'
+PEDEBUG =                   'PEDEBUG'
+
+# These constants identify the kinds of objects that are supported by the
+# "temporary object" support in wsautils.  Each type must be added to the
+# temporary_object_types_deletion_order list in the appropriate position,
+# and it must also be added to the temporary_object_types_info collection
+# so it can be identified and handled properly.
+TEMP_OBJ_TYPE_USER =                'user'
+TEMP_OBJ_TYPE_USER_ROLE =           'role'
+TEMP_OBJ_TYPE_USERID_PATTERN =      'userid-pattern'
+TEMP_OBJ_TYPE_PASSWORD_RULE =       'password-rule'
+TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG =  'ldap'
+TEMP_OBJ_TYPE_CUSTOM_GROUP =        'group'
+TEMP_OBJ_TYPE_VIRTUAL_SERVER =      'virtual-server'
+TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP = 'workload-resource_group'
+TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP = 'workload-element_group'
+
+# An ordered list of object types supported as "temporary objects".  This list defines
+# the order in which the temporary objects are deleted at the end of testcase execution.
+temporary_object_types_deletion_order = [TEMP_OBJ_TYPE_USERID_PATTERN,  # must be before User (specifically, before type=template Users are deleted)
+                                         TEMP_OBJ_TYPE_USER,
+                                         TEMP_OBJ_TYPE_USER_ROLE,       # must be after User
+                                         TEMP_OBJ_TYPE_CUSTOM_GROUP,    # must be after User Role and User
+                                         TEMP_OBJ_TYPE_PASSWORD_RULE,   # must be after User
+                                         TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG,  # must be after patterns
+                                         TEMP_OBJ_TYPE_VIRTUAL_SERVER,
+                                         TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP,
+                                         TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP, # must be after Workload Element Groups
+                                        ]
+
+# Keys for info in the temporary_object_types_info map
+KEY_ADMIN_USERID = 'admin_userid'   # Key for the name of the system-defined user that has administration privileges for this type of object
+KEY_URI_PREFIX =   'uri_prefix'     # Key for the initial constant part of the URI that identifies an object this type
+
+# Map of information about the object types that are supported as "temporary objects"
+temporary_object_types_info = dict({TEMP_OBJ_TYPE_USER :                {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/users/'}, 
+                                    TEMP_OBJ_TYPE_USER_ROLE :           {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/user-roles/'},
+                                    TEMP_OBJ_TYPE_USERID_PATTERN :      {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/user-patterns/'},
+                                    TEMP_OBJ_TYPE_PASSWORD_RULE :       {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/password-rules/'},
+                                    TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG :  {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/ldap-server-definitions/'},
+                                    TEMP_OBJ_TYPE_CUSTOM_GROUP :        {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/groups/'},
+                                    TEMP_OBJ_TYPE_VIRTUAL_SERVER :      {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/virtual-servers/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP   : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-resource-groups/'},
+                                    TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP    : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-element-groups/'},
+                                  })
+
+
+# Map of URI prefixes to the name of the system-defined user that has administrator permissions for objects with that URI prefix.
+# This map is used to locate/create an API session with administrator permissions for the URI prefix.
+# Note that these prefixes must be listed from most-specific to least-specific, since they are searched in order.
+# It is recommended to include a trailing slash only on URI prefixes that require it in order for it to be a valid URI.
+# (Some URI prefixes can be used in their entirety on List operations, and thus should not include a trailing slash;
+# if needed, two entries can be included: one with a trailing slash and one without).
+# TODO: add support for expressions or wildcards for objects that contain multiple IDs (e.g., element objects often have multiple IDs)
+uri_admin_info = dict({'/api/ensembles' : ENSEMBLE_ADMINISTRATOR,
+                       '/api/console/hardware-messages' : SYSTEM_PROGRAMMER,
+                       '/api/console/users' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-roles' : ACCESS_ADMINISTRATOR,
+                       '/api/console/tasks' : ACCESS_ADMINISTRATOR,
+                       '/api/console/user-patterns' : ACCESS_ADMINISTRATOR,
+                       '/api/console/password-rules' : ACCESS_ADMINISTRATOR,
+                       '/api/console/ldap-server-definitions' : ACCESS_ADMINISTRATOR,
+                       '/api/users/' : ACCESS_ADMINISTRATOR,
+                       '/api/user-roles/' : ACCESS_ADMINISTRATOR,
+                     })
+#############################################################################
+# ActiveMQ
+# Note that the HMC must be configured to explicitly use the non-SSL ports.
+#############################################################################
+
+# PyActiveMQ ports
+WSA_ACTIVEMQ_PORT_NON_SSL = 61616
+WSA_ACTIVEMQ_PORT_SSL     = 61617
+
+# STOMP ports
+WSA_STOMP_PORT_NON_SSL = 61613
+WSA_STOMP_PORT_SSL = 61612
+
+# Supported ActiveMQ clients
+# These constants are used as command line option values.
+AMQ_CLIENT_PYACTIVEMQ = 'pyactivemq'
+AMQ_CLIENT_STOMP = 'stomp'
+WSA_DEFAULT_AMQ_CLIENT = AMQ_CLIENT_STOMP
+
+# ActiveMQ socket types.
+# These constants are used as command line option values.
+SOCKET_TYPE_SSL = 'ssl'
+SOCKET_TYPE_NON_SSL = 'non-ssl'
+
+#############################################################################
+# Test systems information
+#############################################################################
+### R32 ensemble
+# The name of the ensemble on the primary FVT test system.  This can be used
+# in testcases with certain prerequisites/restrictions that are known to
+# exist on R32.
+ENSEMBLE_NAME_R32 = 'R32Ensemble'
+DEFAULT_ENSEMBLE_NAME = 'ZBX51'
+DEFAULT_CPC_NAME = 'S32'
+DEFAULT_VIRTUALIZATION_HOST_NAME = 'B.1.12'
+DEFAULT_VIRTUAL_SERVER_NAME = 'APIVM1'
+DEFAULT_LPAR_NAME = 'APIVM1'
+PREFERRED_ZVM_VIRTUALIZATION_HOST_R32 = 'APIVM1'
+IP_ADDRESS_R32_HMC = 'Y.Y.Y.Y'         # (R32 is no longer available for API testing)
+IP_ADDRESS_R32_ALT_HMC = '9.60.14.45'     # (R32 is no longer available for API testing)
+FAMILIAR_NAME_R32_HMC = 'S32'          # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+# Ichabod ensemble
+IP_ADDRESS_ICHABOD_HMC = '9.60.14.63'
+FAMILIAR_NAME_ICHABOD_HMC = 'ICHABOD'  # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
+
+#===============================================================================
+# Constant file to run the Testcase : lpar_5433
+# 
+LPAR_CPC_NAME = 'APIVM1'
+LPAR_NAME     = 'VMALT' # remove the postfix '1' from the lpar name.
+LPAR_NAME_ONE = 'VMALT1'
+LPAR_NAME_TWO = 'VMALT2'
+LPAR_NAME_THREE = 'VMALT3'
+#===============================================================================
+
+#############################################################################
+# API URIs
+#############################################################################
+
+# Log onto an HMC
+WSA_URI_LOGON   = '/api/session'
+
+# Log off of an HMC
+WSA_URI_LOGOFF  = '/api/session/this-session'
+
+# Retrieve the API version
+WSA_URI_VERSION = '/api/version'
+
+# List all ensembles
+WSA_URI_ENSEMBLES      = '/api/ensembles'
+
+# Retrieve properties of a specific ensemble
+WSA_URI_ENSEMBLE       = '/api/ensembles/{0}'
+
+# Retrieve all CPCs
+WSA_URI_CPCS           = '/api/cpcs'
+
+# Retrieve all virtualization hosts of a specific ensemble
+WSA_URI_VIRT_HOSTS_ENS = '/api/ensembles/{0}/virtualization-hosts'
+
+# Retrieve all virtualization hosts of a specific cpc
+WSA_URI_VIRT_HOSTS_CPC = '/api/cpcs/{0}/virtualization-hosts'
+
+# Retrieve all properties of a specific virtualization host
+WSA_URI_VIRT_HOST      = '/api/virtualization-hosts/{0}'
+
+
+#############################################################################
+# Testcase exit return codes
+#############################################################################
+
+# Exit return code for successful testcase execution
+WSA_EXIT_SUCCESS = 0
+
+# Exit return code for an API error
+WSA_EXIT_ERROR_API = 1
+
+# Exit return code for an unexpected error such as a communication failure
+WSA_EXIT_ERROR_UNCAUGHT = 2
+
+# Exit return code for successful --get-properties request
+WSA_EXIT_GET_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for successful --check-properties request
+WSA_EXIT_CHECK_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
+
+# Exit return code for an invalid command line (e.g., an invalid combination of options)
+WSA_EXIT_INVALID_COMMAND_LINE = 5
+
+# Exit return code for an error due to missing testcase properties
+WSA_EXIT_MISSING_TESTCASE_PROPERTIES = 6
+
+# Exit return code indicating that a specific testcase property is not defined
+WSA_EXIT_PROPERTY_NOT_DEFINED = 7
+
+# Exit return code indicating that a testcase requirement was not met
+WSA_EXIT_REQUIREMENT_NOT_MET = 8
+
+
+WSA_EXIT_ERROR_CLEANUP = 9
+#############################################################################
+# HTTP Request and Response
+# Note that the HMC must be configured to explicitly use the non-SSL port.
+#############################################################################
+
+# Non-SSL HTTP Port ... need HTTPConnection ...
+WSA_PORT_NON_SSL = 6167
+
+# SSL HTTP Port ... needs HTTPSConnection ...
+WSA_PORT_SSL     = 6794
+
+# HTTP GET command
+WSA_COMMAND_GET    = 'GET'
+
+# HTTP DELETE command
+WSA_COMMAND_DELETE = 'DELETE'
+
+# HTTP POST command
+WSA_COMMAND_POST   = 'POST'
+
+# HTTP PUT command
+WSA_COMMAND_PUT    = 'PUT'
+
+# Header for content type ... both request and response
+WSA_HEADER_CONTENT    = 'content-type'
+WSA_HEADER_CONTENT_TYPE   = WSA_HEADER_CONTENT  # Synonym with better name
+WSA_HEADER_CONTENT_LENGTH = 'content-length'
+
+# Header for API session ... request header only
+WSA_HEADER_RQ_SESSION = 'x-api-session'
+
+# Header for API session ... response header only
+WSA_HEADER_RS_SESSION = 'api-session'
+
+# Response headers (these are published in the examples in the WS API customer book)
+WSA_HEADER_RESP_SERVER = 'server'
+WSA_HEADER_RESP_CACHE_CONTROL = 'cache-control'
+WSA_HEADER_RESP_DATE = 'date'
+WSA_HEADER_RESP_LOCATION = 'location'
+WSA_HEADER_RESP_TRANSFER_ENCODING = 'transfer-encoding'
+
+WSA_CONTENT_JSON = 'application/json'
+WSA_CONTENT_XML  = 'application/xml'
+WSA_CONTENT_ZIP  = 'application/zip'
+
+# Currently supported content types
+WSA_SUPPORTED_CONTENT = [ WSA_CONTENT_JSON, WSA_CONTENT_XML, WSA_CONTENT_ZIP ]
+
+#############################################################################
+# Common property names
+#############################################################################
+PROPERTY_OBJECT_URI   = 'object-uri'
+PROPERTY_NAME         = 'name'
+PROPERTY_DESCRIPTION  = 'description'
+PROPERTY_LPAR_NAME    = 'lpar-name'
+PROPERTY_ID           = 'partition-id'
+PROPERTY_TYPE         = 'type'
+PROPERTY_ADAPTER_ID   = 'adapter-id'
+PROPERTY_ADAPTER_PORT = 'adapter-port'
+PROPERTY_PORT_INDEX   = 'port-index'
+
+
+
+#############################################################################
+# Command line option names
+#############################################################################
+OPTION_ADDR = '--addr'
+OPTION_PORT = '--port'
+OPTION_USER = '--user'
+OPTION_PASS = '--pass'
+OPTION_GET_PROPERTIES = '--get-properties'
+OPTION_CHECK_PROPERTIES = '--check-properties'
+OPTION_RUN_IF_APPLICABLE = '--run-if-applicable'
+OPTION_CAPABILITY = '--capability'
+OPTION_COMPONENT = '--component'
+OPTION_SCENARIO = '--scenario'
+OPTION_EXECUTION_TYPE = '--execution-type'
+#OPTION_MIN_VERSION = '--min-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+#OPTION_MAX_VERSION = '--max-version'    # (Replaced by OPTION_REQUIRED_VERSION)
+OPTION_REQUIRED_VERSION = '--required-version'
+OPTION_API_VERSION = '--api-version'
+
+
+# Command line destination variable names
+OPTION_ADDR_DEST = 'host'
+OPTION_PORT_DEST = 'port'
+OPTION_USER_DEST = 'user'
+OPTION_PASS_DEST = 'pwd'
+
+#############################################################################
+# Command line default values
+#############################################################################
+DEFAULT_ADDR = '9.56.198.64'#'9.152.151.49'# '9.12.38.189' #'9.56.192.214' # '9.60.15.124'# ''9.56.192.214' #  '9.60.31.100'#'9.152.151.49' #'9.56.192.214' #'9.152.151.49' #'9.60.31.168'#'9.60.31.170'#'9.12.38.183'    # A dummy default, to force the user to specify --addr.  (R32 is no longer available)
+#DEFAULT_ADDR = '9.60.15.62'  #p15
+#DEFAULT_ADDR = '9.60.14.63'   #Ichabod
+#DEFAULT_ADDR = '9.56.196.93'
+DEFAULT_PORT = WSA_PORT_SSL
+WSA_DEFAULT_USERID   = 'ensadmin'
+WSA_DEFAULT_PASSWORD = 'password'
+
+#############################################################################
+# API feature strings.  These identify optional WS API features that may be
+# available on the HMC.  A list of available features is included in the 
+# response to the API Version and Logon requests.  The available features
+# are specified in files in the /console/data/webapi/features/ directory on
+# the HMC.
+#############################################################################
+FEATURE_GET_FILES_FROM_SE = 'internal-get-files-from-se' # Internal-use only API to fetch a specified file(s) from an SE
+
+#############################################################################
+# Response Validation
+#############################################################################
+
+STATUS       = 'status'
+CONTENT_TYPE = 'content-type'
+REQUIRED     = 'required'
+OPTIONAL     = 'optional'
+
+
+STATUS_200     = ( STATUS, 200 )
+STATUS_201     = ( STATUS, 201 )
+STATUS_202     = ( STATUS, 202 )
+STATUS_204     = ( STATUS, 204 )
+CONTENT_JSON   = ( CONTENT_TYPE, WSA_CONTENT_JSON )
+REQUIRED_EMPTY = ( REQUIRED, [] )
+OPTIONAL_EMPTY = ( OPTIONAL, [] )
+OPTIONAL_API1DOT4 = ( OPTIONAL, ['acceptable-avail-status','avail-policies','avail-status','element-groups','perf-policies','absolute-ziip-capping','workload-element-groups','shutdown-timeout', 'shutdown-timeout-source','gpmp-network-adapter'] )
+OPTIONAL_PASSWORD_EXPIRES = (OPTIONAL, ['password-expires'])
+
+
+# Logon and Version #########################################################
+
+__ver_required       = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'hmc-name', 'hmc-version' ] )
+__ver_optional       = ( OPTIONAL, [ 'api-features' ] )
+__logon_required     = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic' ] )
+__logon_required_job = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic','job-notification-topic' ] )
+__logon_optional     = ( OPTIONAL, [ 'password-expires', 'api-features' ] )
+
+# Validate response from 'Get Version' operation
+WSA_VERSION_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __ver_required, __ver_optional ] )
+
+# Validate response from 'Logon' operation
+WSA_LOGON_VALIDATE     = dict( [ STATUS_200, CONTENT_JSON, __logon_required, __logon_optional ] )
+WSA_LOGON_VALIDATE_JOB     = dict( [ STATUS_200, CONTENT_JSON, __logon_required_job, __logon_optional ] )
+
+# Ensembles #################################################################
+
+__list_ensembles_required = ( REQUIRED, [ 'ensembles' ] )
+
+__get_ensemble_required   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix' ] )
+
+__get_ensemble_optional   = ( OPTIONAL, [ 'alt-hmc-name',
+                                            'alt-hmc-ipv4-address',
+                                            'alt-hmc-ipv6-address',
+                                          'cpu-perf-mgmt-enabled-x-hyp',
+                                            'cpu-perf-mgmt-enabled-x-hyp',  #temporarily resumed by lv, for zHelixGA2 testing, but notice it is not running on lower version
+
+                                            'load-balancing-enabled',
+                                            'load-balancing-ip-addresses',
+                                            'load-balancing-port',
+                                            'max-nodes',
+                                            'max-cpc-nodes',
+                                            'max-zbx-nodes' ] )
+
+# Validate response from 'List Ensembles' operation
+WSA_LIST_ENSEMBLES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_ensembles_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each ensemble returned by 'List Ensembles' operation
+WSA_LIST_ENSEMBLE_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Validate response from 'Get Ensemble Properties' operation
+WSA_GET_ENSEMBLE_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required,   __get_ensemble_optional ] )
+
+
+# CPCs ######################################################################
+
+__list_cpcs_required = ( REQUIRED, [ 'cpcs' ] )
+
+# Validate response from 'List CPCs' operation
+WSA_LIST_CPCS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_cpcs_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each cpc returned by 'List CPCs' operation
+WSA_LIST_CPC_REQUIRED  = [ 'name', 'object-uri', 'status' ]
+
+# Required keys for 'Get CPC Properties' operation
+__get_cpc_properties_required  = ( REQUIRED, [ 'name',
+                                               'object-uri',
+                                               'type',
+                                               'status' ] )
+
+# Validate response from 'Get CPC Properties' operation
+WSA_GET_CPC_PROPERTIES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __get_cpc_properties_required, OPTIONAL_EMPTY ] )
+
+
+# Virtualization Hosts ######################################################
+
+__list_virt_hosts_required = ( REQUIRED, [ 'virtualization-hosts' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOSTS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_hosts_required, OPTIONAL_EMPTY ] )
+
+# Required keys for each virtualization host returned by 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_HOST_REQUIRED  = [ 'name', 'object-uri', 'status', 'type' ]
+
+# Wait period for all zvm tests
+WAIT_PERIOD_FOR_ZVM_TEST = 30 
+
+# These are the properties of a notification message that are not of type string.
+# When an incoming message is received, it is used to populate a dictionary of
+# key-value pairs.  Most of the properties are strings, but some are not and require
+# special handling.  Identify them here along with their datatype.  The addition of
+# a new type here will require corresponding changes where this list is processed.
+if Z9474_applied:
+    nonstring_message_properties = [
+                                    ('global-sequence-nr', 'long'), 
+                                    ('session-sequence-nr', 'long'),
+                                   ]
+else:
+    nonstring_message_properties = [
+                                   ]
+
+
+#added by lv start
+APA_TESTENV_CPC_UNDER_TEST = 'BLUECORE'
+
+__list_virt_servers_required = ( REQUIRED, [ 'virtual-servers' ] )
+
+# Validate response from 'List Virtualization Hosts' operation
+WSA_LIST_VIRT_SERVERS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_servers_required, OPTIONAL_EMPTY ] )
+
+__list_virt_server_groups_required = ( REQUIRED, [ 'virtual-server-groups' ] )
+
+WSA_LIST_VIRT_SERVER_GROUPS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_server_groups_required, OPTIONAL_EMPTY ] )
+#added by lv end
+
+#adding the constants need for Ensemble properties for node properties
+__get_ensemble_required_nodes   = ( REQUIRED, [ 'acceptable-status',
+                                            'class',
+                                            'cpu-perf-mgmt-enabled-power-vm',
+                                            'cpu-perf-mgmt-enabled-zvm',
+                                            'description',
+                                            'has-unacceptable-status',
+                                            'is-locked',
+                                            'mac-prefix',
+                                            'management-enablement-level',
+                                            'name',
+                                            'object-id',
+                                            'object-uri',
+                                            'parent',
+                                            'power-consumption',
+                                            'power-rating',
+                                            'reserved-mac-address-prefixes',
+                                            'status',
+                                            'unique-local-unified-prefix',
+                                            'max-cpc-nodes',
+                                            'max-nodes',
+                                            'max-zbx-nodes' ] )
+
+
+WSA_GET_ENSEMBLE_VALIDATE_NODES   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required_nodes,   __get_ensemble_optional ] )
+WSA_DEFAULT_ZBX_NAME = 'ZBX2'
\ No newline at end of file
diff --git a/partitionengine/utils/wsaconst.pyc b/partitionengine/utils/wsaconst.pyc
new file mode 100644
index 0000000..e1949cd
Binary files /dev/null and b/partitionengine/utils/wsaconst.pyc differ
diff --git a/partitionengine/utils/wsaglobals.py b/partitionengine/utils/wsaglobals.py
new file mode 100755
index 0000000..65e6f61
--- /dev/null
+++ b/partitionengine/utils/wsaglobals.py
@@ -0,0 +1,33 @@
+# Global variables for use by wsaconst and friends
+# 
+# Change history:
+# - 2014/07/17 L. Brocious      Initial version.  Added for "temporary object" support.
+# - 2015/02/16 L. Brocious      Add "temporary session" support.
+
+# This is the list of additional command line options (those defined in addition
+# to the "standard" options) defined for the current testcase execution.  This is
+# saved when the Session is created and is used only to allow successful re-parsing
+# of the command line when additional sessions are created during testcase execution
+# (typically during scenario setup and cleanup).
+global global_saved_additional_options
+global_saved_additional_options = None
+
+# The list of all registerd "temporary objects".  This list is managed by the 
+# register_temporary_object() and deregister_temporary_object() methods.  All
+# objects in this list are deleted by default during session shutdown.
+global global_temporary_objects_list
+global_temporary_objects_list = []
+
+# The list of all known "admin" sessions.  Such privileged sessions are typically needed
+# during scenario setup and cleanup.  For performance reasons, they are cached here and
+# reused if needed.  This list is managed by get_admin_session() and delete_all_admin_sessions().
+global global_admin_sessions
+global_admin_sessions = dict()
+
+
+# The list of all registerd "temporary sessions".  A temporary session is associated
+# with a temporary user and is intended for testcase scripts that perform authorization
+# testing.  All sessions in this list are deleted by default during shutdown of the
+# testcase's main session (via the standard session_shutdown(session) call before exit).
+global global_temporary_sessions
+global_temporary_sessions = []
diff --git a/partitionengine/utils/wsaglobals.pyc b/partitionengine/utils/wsaglobals.pyc
new file mode 100644
index 0000000..4244b3c
Binary files /dev/null and b/partitionengine/utils/wsaglobals.pyc differ
diff --git a/partitionengine/utils/wsautils.py b/partitionengine/utils/wsautils.py
new file mode 100755
index 0000000..78800e3
--- /dev/null
+++ b/partitionengine/utils/wsautils.py
@@ -0,0 +1,2905 @@
+#############################################################################
+#
+# Some utility classes and functions that may be useful for API Testing
+#
+# In order to import this module for use in testcases, set the PYTHONPATH
+# environment variable to point to the directory where the modules are
+# located.
+#
+# from wsaconst import *
+# from wsautils import *
+#
+# The call to os.getenv can be used to retrieve any environment variable, so
+# defining a variable that points to the Python common utilities directory
+# could be established in a test environment startup script, then referenced
+# above in the sys.path.append method call ...
+#
+#############################################################################
+
+from wsaconst import *
+import wsaglobals  # True global variables
+
+import httplib
+import pprint
+import json
+import optparse  # use argparse with Python 2.7.x ...
+from optparse import make_option
+from optparse import OptionGroup
+import string
+
+import sys
+import threading
+import time
+import traceback
+import types
+import ssl
+import os
+import re
+import __main__
+
+import logging
+import logging.config
+
+class progress_bar_loading(threading.Thread):
+
+    def run(self):
+            global stop
+            global kill
+            global progress_str
+            print progress_str + '....  ',
+            sys.stdout.flush()
+            i = 0
+            while stop != True:
+                    if (i % 4) == 0: 
+                        sys.stdout.write('\b/')
+                    elif (i % 4) == 1: 
+                        sys.stdout.write('\b-')
+                    elif (i % 4) == 2: 
+                        sys.stdout.write('\b\\')
+                    elif (i % 4) == 3: 
+                        sys.stdout.write('\b|')
+
+                    sys.stdout.flush()
+                    time.sleep(0.2)
+                    i += 1
+
+            if kill == True: 
+                print '\b\b\b\b ABORT!'
+            else: 
+                print '\b\b done!'
+            return
+        
+    def stop(self):
+        global stop
+        stop = True
+        
+    def configure(self,progress_string='Processing'):
+        global progress_str
+        progress_str = progress_string
+        global stop
+        stop = False
+        
+        
+
+progress_str = "Processing"
+kill = False      
+stop = False
+
+def initializeLogging():
+    directory='logs'
+    if not os.path.exists(directory):
+    	os.makedirs(directory)
+    logging.basicConfig(level=logging.DEBUG,
+                        format='%(asctime)s %(levelname)-8s %(message)s',
+                        datefmt='%a, %d %b %Y %H:%M:%S',
+                        filename='logs/console.log',
+                        filemode='w')
+
+
+
+
+
+WSA_UTILS_VERSION = "1.1"  # Current version of the API utilities
+
+#############################################################################
+# Determine which, if any, ActiveMQ clients are installed.  Set global flags
+# for later use.
+#############################################################################
+# Try STOMP
+try:
+    import stomp
+    stomp_present = True
+except ImportError:
+    # print "STOMPPY not installed or not supported"
+    stomp_present = False
+
+# Try PyActiveMQ
+try:
+    import pyactivemq
+    pyactivemq_present = True
+except ImportError:
+    # print "Pyactivemq not installed or not supported"
+    pyactivemq_present = False
+
+#############################################################################
+# Exceptions
+#############################################################################
+
+# General exception raised when api errors occur ...
+class ApiException(Exception) :
+
+    def __init__(self, text, response=None, keys=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text of exception
+        self.response = response  # Response object, if applicable
+        self.keys = keys  # Keys in error, only used by validate_response and
+                                 # validate_dictionary methods
+
+    def __str__(self) :
+
+        text = self.text
+        keys = self.keys
+        resp = self.response
+
+        result = []
+        result.append('ApiException caught ...\n\n')
+        result.append('MESSAGE :\n')
+        result.append(text)
+        result.append('\n')
+
+        if resp is None or not hasattr(resp, 'body'):
+            if keys is not None :
+                result.append(keys)
+        else :
+            body = resp.body
+            message = body[ 'message' ]     if 'message'     in body else None
+            status = body[ 'http-status' ] if 'http-status' in body else None
+            reason = body[ 'reason' ]      if 'reason'      in body else None
+            uri = body[ 'request-uri' ] if 'request-uri' in body else None
+            result.append('\nReturn Code = ')
+            if status is not None and reason is not None :
+                result.append(status)
+                result.append('.')
+                result.append(reason)
+            else :
+                result.append(str(resp.status))
+            result.append(' ')
+            result.append(resp.reason)
+            if message is not None :
+                result.append('\nResponse Message = ')
+                result.append(message)
+            if keys is not None :
+                result.append(' : ')
+                result.append(keys)
+            if uri is not None :
+                result.append('\nRequest URI = ')
+                result.append(uri)
+            result.append('\n\n')
+            result.append(resp)
+
+        result.append('\n\nStack Trace :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+
+        return ''.join([ str(s) for s in result ])
+
+
+#############################################################################
+#
+# Fatal exception ... used for non-API errors ...
+#
+# @parm text      - message text
+# @parm response  - response from HTTP request.  This can be either an
+#                   httplib.HTTPResponse or wsautils.Response object
+# @parm traceback - stack trace, usually taken from a caught exception
+#                   since it will differ from the stack trace created
+#                   when the ApiFatalException is created.
+# @parm request   - a wsautils.Request object representing the information
+#                   sent via an HTTP request.  Since testcase writers do not
+#                   generally have access to the HTTP request, this parameter
+#                   should be considered internal to wsautils only.
+# @parm other     - additional, relevant data provided by the testcase writer
+#                   that may help with diagnostics.
+#
+#############################################################################
+
+class ApiFatalException(Exception) :
+
+    def __init__(self, text, response=None, traceback=None, other=None, request=None) :
+        Exception.__init__(self, text)
+        self.text = text  # Message text for exception
+        self.response = response
+        self.traceback = traceback
+        self.other = other
+        self.request = request
+
+    def __str__(self) :
+
+        result = []
+        result.append('ApiFatalException caught\n\n')
+        result.append('MESSAGE :\n')
+        result.append(self.text)
+        result.append('\n\n')
+
+        if self.response is None and self.request is not None :
+            result.append('REQUEST :\n')
+            result.append(self.request)
+            result.append('\n\n')
+
+        if self.response is not None :
+            result.append('RESPONSE :\n')
+            if isinstance(self.response, httplib.HTTPResponse) :
+                result.append(Response(self.response.status,
+                                         self.response.reason,
+                                         self.response.getheaders(),
+                                         self.response.read()))
+            else :
+                result.append(self.response)
+
+            result.append('\n\n')
+
+        # Append the stack trace created when raising this exception ...
+        result.append('TRACEBACK (most recent stack) :\n')
+        stack = traceback.format_tb(sys.exc_info()[2])
+        result.append(''.join([ s for s in stack ]))
+        result.append('\n')
+
+        # If present, this should be the stack trace created by the
+        # 'caught' exception that was wrapped inside the ApiFatalException
+        if self.traceback is not None :
+            result.append('TRACEBACK (from caught exception) :\n')
+            stack = traceback.format_tb(self.traceback)
+            result.append(''.join([ s for s in stack ]))
+            result.append('\n')
+
+        if self.other is not None :
+            result.append('OTHER :\n')
+            result.append(self.other)
+            result.append('\n')
+
+        return ''.join([ str(s) for s in result ]).strip()
+
+
+#############################################################################
+# Request Class
+#############################################################################
+
+class Request :
+
+    """This class encapsulates an HTTP request"""
+
+    def __init__(self, operation, uri, headers, body) :
+        self.operation = operation
+        self.uri = uri
+        self.headers = headers
+        self.body = body
+
+    def __str__(self) :
+        l = []
+        l.append('Request Operation : ')
+        l.append(str(self.operation))
+        l.append('\nRequest URI       : ')
+        l.append(str(self.uri))
+
+        l.append('\nRequest Headers   : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nRequest Body      : ')
+        if self.body == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(json.loads(self.body), sort_keys=True, indent=1, separators=(',', ':')))
+
+        return ''.join([ s for s in l ])
+
+
+#############################################################################
+#
+# Response Class
+#
+# This class models an HTTP response object.  The response headers will be
+# converted to a Python dictionary and the response body will be processed
+# through the JSON parser if the content-type header is 'application/json'.
+#
+# If the 'content-type' indicates the body is a json-formatted string and
+# the subsequent call to json.loads fails to parse the body, an
+# ApiFatalException with be raised.  The response will be added to the
+# exception, but the body will the unparse HTTP response body.
+#
+#############################################################################
+
+class Response :
+
+    """This class encapsulates an HTTP response"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    # Initialize a response
+    def __init__(self, status, reason, headers, body, request=None) :
+
+        # ##print '====================== begin body ====================================================='
+        # ##print body
+        # ##print '====================== end body ======================================================='
+        self.status = status  # HTTP response status
+        self.reason = reason  # HTTP response reason
+        self.headers = dict(headers)  # HTTP response headers
+        self.body = body  # HTTP response body
+        self.request = request  # HTTP request
+        self.bodyIsJSON = False  # Indicates whether the saved response body is a parsed JSON string
+
+        if body is not None and len(body) > 0 :
+            if self.headers[ CONTENT_TYPE ].startswith(WSA_CONTENT_JSON) :
+                try :
+                    # Parse the body and save the parsed version
+                    self.body = json.loads(body)
+                    self.bodyIsJSON = True  # Body is now a parsed JSON string
+                except :
+                    raise ApiFatalException(''.join([ str(s) for s in sys.exc_info()[1].args ]), response=self)
+            else :
+                self.body = body
+        else :
+            self.body = '{}'
+            self.bodyIsJSON = True  # Body is a parsed JSON string (an empty body)
+
+    # Print out a string representation of the response
+    def __str__(self) :
+        l = []
+        if self.request is not None :
+            l.append(self.request)
+            l.append('\n\n')
+        l.append('Response Status  : ')
+        l.append(self.status)
+        l.append('\nResponse Reason  : ')
+        l.append(self.reason)
+
+        l.append('\nResponse Headers : ')
+        if self.headers == None:
+            l.append('None')
+        else:
+            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
+
+        l.append('\nResponse Body    : ')
+        if self.bodyIsJSON:
+            l.append(json.dumps(self.body, sort_keys=True, indent=1, separators=(',', ':')))
+            if 'stack' in self.body:
+                l.append('\n\nstack (again, but in a more programmer-friendly format):\n')
+                l.append(self.body[ 'stack' ])
+        else:
+            l.append(str(self.body))
+
+
+        return ''.join([ str(s) for s in l ])
+
+
+#############################################################################
+#
+# Session Class
+#
+# This class represents a persistent HTTP connection to an HMC.  As such,
+# when the test code is finished with the HTTP connection, the close
+# method should be called to ensure resources are cleaned up.
+#
+# Currently, only JSON-formatted request bodies are supported.  Addtional
+# formats can be added in the future, as needed.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted for this Session.  See parse_standard_options()
+# for more details.  The option values may be referenced via the "opts" member
+# of the Session object.  For example, if an option was defined with dest='sr_name':
+#      name = session.opts.sr_name
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  See
+# parse_standard_options() for more details.  The command line arguments can
+# be referenced via the "args" member of the Session object, for example,
+# to access the first testcase-specific positional argument:
+#      property_name = session.args[session.arg_start_index + 0]
+#
+# Note that the __init__ method calls parse_standard_options(), which uses os._exit(rc)
+# in some cases rather than the more common sys.exit(rc).  See the prolog of
+# parse_standard_options for more details.
+#############################################################################
+
+class Session :
+
+    """This class supports connecting to an Ensemble HMC via HTTP"""
+
+    #########################################################################
+    # Init
+    #########################################################################
+
+    def __init__(self, host=None, port=None, user=None, pwd=None, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+        """Initialize an instance of the Session class"""
+        # Save any additional command line option definitions so that they're available
+        # when the command line is re-parsed if another session is established.
+        wsaglobals.global_saved_additional_options = additional_options
+#       print 'in Session init: global_saved_additional_options=%s' % wsaglobals.global_saved_additional_options
+        opts, args = parse_standard_options(additional_options, additional_arguments_usage_info)  # Read in command line arguments and options, if any ...
+        self.opts = opts  # Keep all parsed options for anyone that might need them
+        self.args = args  # Keep all parsed arguments for anyone that might need them
+        self.arg_start_index = 0  # The index of the first test-case specific argument, if any.
+                                    # There are currently no "standard" arguments, so all arguments
+                                    # are, in effect, test-case specific; thus this index is 0.
+
+        # Save values from the command line or our caller, as appropriate
+        self.__host = opts.host if host is None else host
+        self.__port = opts.port if port is None else port
+        self.__user = opts.user if user is None else user
+        self.__pass = opts.pwd  if pwd  is None else pwd
+        self.__amq_client = opts.amq_client if amq_client is None else amq_client
+        self.__amq_socket_type = opts.amq_socket_type if amq_socket_type is None else amq_socket_type
+        self.__api_version_override = opts.api_version_override
+        self.__get_properties = opts.get_properties
+        self.__check_properties = opts.check_properties
+        self.__run_if_applicable = opts.run_if_applicable
+        self.__required_version = opts.required_version
+        self.__required_capabilities = opts.required_capabilities
+        self.__required_components = opts.required_components
+        self.__required_scenario_types = opts.required_scenario_types
+        self.__required_execution_types = opts.required_execution_types
+
+        self.__args = args
+
+        self.__connection = None  # Persistent HTTP connection
+        self.__session = None  # Session id
+        self.__topic = None  # Topic id for ActiveMQ notifications
+                                   #
+        self.__api_version = None  # WSA API version supported by HMC
+        self.__hmc_name = None  # Name of the connected HMC
+        self.__hmc_version = None  # Version of the connected HMC
+        self.__jobtopic = None  # Topic id for ActiveMQ JOB Notifications
+        self.__api_features = None  # List of available WS API features
+                                   #
+        self.__consumer = None  # ActiveMQ notification consumer
+        self.__callback = None  # Callback method for notification messages
+
+
+        #########################################################################
+        # If no ActiveMQ client was specified, choose one based on what's installed
+        # and available if possible.  Then, if no SSL preference was specified,
+        # select a sensible one based on the ActiveMQ client.  Then, set the ActiveMQ
+        # port to the appropriate port number.
+        #########################################################################
+        # Determine the client type
+        if self.__amq_client is None:
+            if stomp_present == True:  # STOMP is installed; use it
+                self.__amq_client = AMQ_CLIENT_STOMP
+            elif pyactivemq_present == True:  # No STOMP, but PyActiveMQ is installed; use it
+                self.__amq_client = AMQ_CLIENT_PYACTIVEMQ
+            else:  # None installed, so just go with the default here; errors will be surfaced later if an AMQ client is actually required.
+                self.__amq_client = WSA_DEFAULT_AMQ_CLIENT
+
+        # Use PyActiveMQ ActiveMQ client
+        if self.__amq_client == AMQ_CLIENT_PYACTIVEMQ:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_NON_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:  # Sensible?  Current versions of pyactivemq don't support SSL
+                self.__amq_port = WSA_ACTIVEMQ_PORT_SSL
+            else:
+                self.__amq_port = WSA_ACTIVEMQ_PORT_NON_SSL
+
+        # Use STOMP ActiveMQ client
+        else:
+            if self.__amq_socket_type is None:
+                self.__amq_socket_type = SOCKET_TYPE_SSL  # Not specified, so set default
+
+            if self.__amq_socket_type == SOCKET_TYPE_SSL:
+                self.__amq_port = WSA_STOMP_PORT_SSL
+            else:
+                self.__amq_port = WSA_STOMP_PORT_NON_SSL
+
+#       print "pyactivemq_present = " + str(pyactivemq_present)
+#       print "stomp_present = " + str(stomp_present)
+#       print "leaving parse_standard_options() with"
+#       print "\t self.__amq_client=" + str(self.__amq_client)
+#       print "\t self.__amq_socket_type=" + str(self.__amq_socket_type)
+#       print "\t self.__amq_port=" + str(self.__amq_port)
+#       print "\t self.__get_properties=" + str(self.__get_properties)
+
+
+    #########################################################################
+    # Open connection to HMC
+    #########################################################################
+
+    def open(self) :
+
+        """Create a persistent HTTP connection to an HMC, then logon"""
+
+        body = json.dumps({ 'userid':self.__user, 'password':self.__pass })
+
+        # Issue the Logon request
+        response = self.__executeRequest(WSA_COMMAND_POST, WSA_URI_LOGON, body, WSA_CONTENT_JSON)
+
+        # Check the status code to be sure logon succeeded before trying to validate
+        # the response details.  For example, the response body might not even be a dictionary.
+        if response.status != 200:
+            raise ApiFatalException('Logon failed', response)
+
+
+#       print '****************'
+#       print response.request
+#       print '****************'
+#       print response.request.headers
+#       print '****************'
+#       print response.headers
+#       print '****************'
+
+
+
+        # Parse and validate the response to the Logon request.  Save info for later use.
+
+        if 'job-notification-topic' in response.body.keys():
+            self.__jobtopic = str(response.body[ 'job-notification-topic' ])
+            validate_response(response, WSA_LOGON_VALIDATE_JOB)
+        else :
+            validate_response(response, WSA_LOGON_VALIDATE)
+
+        self.__session = str(response.body[ 'api-session'        ])
+        self.__topic = str(response.body[ 'notification-topic' ])
+
+        if 'api-features' in response.body.keys():
+            self.__api_features = response.body[ 'api-features' ]  # List of strings
+        
+        # Now issue an API Version request and validate the response
+        response = self.get(WSA_URI_VERSION)
+        validate_response(response, WSA_VERSION_VALIDATE)
+
+        # Parse and save this session's version information
+        ver = []
+        ver.append(str(response.body[ 'api-major-version' ]))
+        ver.append('.')
+        ver.append(str(response.body[ 'api-minor-version' ]))
+
+        self.__api_version = "".join(ver)
+        self.__hmc_name = response.body[ 'hmc-name' ]
+        self.__hmc_version = response.body[ 'hmc-version' ]
+
+        # print "Topic ID: \t%s"     % self.__topic
+        # print "Job Topic ID: \t%s" % self.__jobtopic
+        # print "API version: \t%s"  % self.__api_version
+        # print "API features: \t%s" % self.__api_features
+
+        return self.__connection
+
+
+    #########################################################################
+    # Close connection to HMC
+    #########################################################################
+
+    def close(self) :
+        """Logoff from the HMC, then close the HTTP connection"""
+
+# # TODO : Close ActiveMQ consumer, too?
+
+        if self.__connection is not None :
+            try :
+                # Logoff active session, if needed ...
+                if self.__session is not None :
+                    response = self.delete(WSA_URI_LOGOFF)
+                    if response.status != 204 :
+                        raise ApiFatalException('Unexpected response status during logoff', response=response)
+            finally :
+                try :
+                   # Close the HTTP session
+                   self.__connection.close()
+                finally :
+                    if self.__consumer is not None and self.__consumer.isRunning() :
+                        self.__consumer.stop()
+
+
+    #########################################################################
+    # Get
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def get(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP GET operation"""
+        return self.__executeRequest(WSA_COMMAND_GET, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Put
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def put(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP PUT operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_PUT, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Post
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def post(self, uri, body, headers=None, return_full_response=True) :
+        """
+        Execute an HTTP POST operation
+        NOTE: Request body is assumed to be JSON format
+        """
+        return self.__executeRequest(WSA_COMMAND_POST, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
+
+
+    #########################################################################
+    # Delete
+    #
+    # Note : If the headers parameter is passed, ALL the required HTTP
+    #        request headers must be included.  No defaults will be added.
+    #      : Specify return_full_response=False to prevent this method from
+    #        reading the response body and closing the HTTP(S) connection.
+    #        See __executeRequest for more information.
+    #########################################################################
+
+    def delete(self, uri, headers=None, return_full_response=True) :
+        """Execute an HTTP DELETE operation"""
+        return self.__executeRequest(WSA_COMMAND_DELETE, uri, None, None, headers, return_full_response)
+
+
+    #########################################################################
+    # Host
+    #########################################################################
+
+    def host(self) :
+        """Return the host"""
+        return self.__host
+
+
+    #########################################################################
+    # Port
+    #########################################################################
+
+    def port(self) :
+        """Return the port"""
+        return self.__port
+
+
+    #########################################################################
+    # Userid
+    #########################################################################
+
+    def userid(self) :
+        """Return the userid"""
+        return self.__user
+
+
+    #########################################################################
+    # Password
+    #########################################################################
+
+    def password(self) :
+        """Return the password"""
+        return self.__pass
+
+
+    #########################################################################
+    # Session
+    #########################################################################
+
+    def session(self) :
+        """Return the active session identifier"""
+        return self.__session
+
+
+    #########################################################################
+    # Topic and job topic
+    #########################################################################
+
+    def topic(self) :
+        """Return the active topic identifier"""
+        return self.__topic
+
+
+    def jobtopic(self) :
+        """Return the active job topic identifier"""
+        return self.__jobtopic
+
+
+    #########################################################################
+    # Values related to the FVT regression tools
+    #########################################################################
+
+    def api_version_override(self) :
+        """Return the API version value from the command line"""
+        return self.__api_version_override
+
+    def get_properties(self) :
+        """Return the OPTION_GET_PROPERTIES setting"""
+        return self.__get_properties
+    def check_properties(self) :
+        """Return the OPTION_CHECK_PROPERTIES setting"""
+        return self.__check_properties
+    def run_if_applicable(self) :
+        """Return the OPTION_RUN_IF_APPLICABLE setting"""
+        return self.__run_if_applicable
+
+    def required_version(self) :
+        """Return the testcase required_version"""
+        return self.__required_version
+
+    def required_capabilities(self) :
+        """Return the testcase required_capabilities"""
+        return self.__required_capabilities
+    def required_components(self) :
+        """Return the testcase required_components"""
+        return self.__required_components
+    def required_scenario_types(self) :
+        """Return the testcase required_scenario_types"""
+        return self.__required_scenario_types
+    def required_execution_types(self) :
+        """Return the testcase required_execution_types"""
+        return self.__required_execution_types
+
+
+    #########################################################################
+    # API Version
+    #########################################################################
+
+    def api_version(self) :
+        """Return the reported API version supported by the HMC"""
+        return self.__api_version
+
+
+    #########################################################################
+    # API Features
+    #########################################################################
+
+    def api_features(self) :
+        """Return the reported API features supported by the HMC"""
+        return self.__api_features
+
+
+    #########################################################################
+    # HMC Name
+    #########################################################################
+
+    def hmc_name(self) :
+        """Return the name of the connected HMC"""
+        return self.__hmc_name
+
+
+    #########################################################################
+    # HMC Version
+    #########################################################################
+
+    def hmc_version(self) :
+        """Return the version of the connected HMC"""
+        return self.__hmc_version
+
+
+    #########################################################################
+    # Register and start receiving general notification messages
+    #########################################################################
+
+    def start_receiving_messages(self, callback=None) :
+        # print "in start_receiving_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__topic, callback)  # Start receiving messages for the general notification topic
+
+
+    #########################################################################
+    # Register and start receiving job notification messages
+    #########################################################################
+
+    def start_receiving_job_messages(self, callback=None) :
+        # print "in start_receiving_job_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        self.start_message_consumer(self.__jobtopic, callback)  # Start receiving messages for the job notification topic
+
+
+    #########################################################################
+    # Register and start receiving audit log notification messages
+    #########################################################################
+
+    def start_receiving_audit_messages(self, callback=None) :
+        # print "in start_receiving_audit_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'audit')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the audit notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the audit notification topic
+
+
+    #########################################################################
+    # Register and start receiving security log notification messages
+    #########################################################################
+
+    def start_receiving_security_messages(self, callback=None) :
+        # print "in start_receiving_security_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+        topic = get_notification_topic(self, 'security')  # Get the topic name and make sure user is authorized to connect to it
+        if topic == None:  # User is not authorized to connect to this topic
+            raise ApiException('The API user is not authorized to connect to the security notification topic')
+        self.start_message_consumer(topic, callback)  # Start receiving messages for the security notification topic
+
+
+    #########################################################################
+    # Register and start receiving messages for the specified topic
+    #########################################################################
+
+    def start_message_consumer(self, topic, callback=None) :
+        try :
+            # print "in start_message_consumer(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
+
+            if (self.__amq_client == AMQ_CLIENT_PYACTIVEMQ):  # Use PyActiveMQ ActiveMQ consumer.  It supports only non-SSL connections
+                if pyactivemq_present == False:
+                    raise ApiFatalException("Cannot use PyActiveMQ ActiveMQ client - pyactivemq module is not installed")
+                self.__consumer = PyActiveMQ_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+            else:  # Use STOMP ActiveMQ consumer.  It supports both SSL and non-SSL connections
+                if stomp_present == False:
+                    raise ApiFatalException("Cannot use STOMP ActiveMQ client - stomp module is not installed")
+                self.__consumer = STOMP_Consumer(self.__host,
+                                            self.__amq_port,
+                                            self.__user,
+                                            self.__pass,
+                                            topic,
+                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
+                                            callback)
+
+            # print "About to start() the message consumer"
+            self.__consumer.start()
+        except :
+            raise ApiFatalException(sys.exc_info()[1].args)
+
+
+
+    #########################################################################
+    # Stop receiving notification messages
+    #########################################################################
+
+    def stop_receiving_messages(self) :
+        self.__consumer.stop()
+
+
+    #########################################################################
+    # Determine whether any notification messages have been received
+    #########################################################################
+
+    def has_messages(self) :
+        return self.__consumer.has_messages()
+
+    #########################################################################
+    # Retrieve existing notification messages ... empty message queue
+    #########################################################################
+
+    def get_received_messages(self) :
+        return self.__consumer.get_messages()
+
+
+    #########################################################################
+    # Retrieve raw notification messages ... empty message queue
+    # Should be used for debug only ...
+    #########################################################################
+
+    def get_raw_messages(self) :
+        return self.__consumer.get_raw_messages()
+
+
+    #########################################################################
+    #
+    # __executeRequest (package private method)
+    #
+    # This method is private to the class and NOT called directly.
+    #
+    # Currently, the supported content types are :
+    #
+    #    None and 'application/json'
+    #
+    # Specify return_full_response=False to prevent this method from reading
+    # response body and closing the HTTP(S) connection.  This allows the
+    # caller to read the response as it sees fit, for example, one byte at a
+    # time.  In this case, the caller is responsible for closing the HTTP(S)
+    # connection.  The read_response_streamed method in this class can be used
+    # to read the response body one byte at a time and then close the connection.
+    #
+    #########################################################################
+
+    def __executeRequest(self, operation, uri, body, content, headers=None, return_full_response=True) :
+
+        """Execute an HTTP request"""
+
+        request = None
+        response = None
+
+        try :
+
+            # Build up the default HTTP headers
+            if headers is None :
+                requestHeaders = {}
+                requestHeaders[ 'Accept' ] = '*/*'
+                if content in WSA_SUPPORTED_CONTENT :
+                    requestHeaders[ WSA_HEADER_CONTENT ] = content
+                if body is not None :
+                    requestHeaders[ WSA_HEADER_CONTENT_LENGTH ] = len(body)
+                if self.__session is not None :
+                    requestHeaders[ WSA_HEADER_RQ_SESSION ] = self.__session
+            else :
+                requestHeaders = headers.copy()
+
+            request = Request(operation, uri, requestHeaders, body)
+
+            # **MHB**
+            # Persistent connections, both SSL and non-SSL, are being closed after sitting
+            # idle for 15-30 seconds.  As a workaround, create a new HTTP connection for
+            # each request until a solution can be found ...
+            if self.__port == WSA_PORT_SSL :
+                # Beginning with Python 2.7.9, SSL connections are more secure and require a valid
+                # X509 certificate signed by a trusted CA.  Since the HMC uses a self-signed certificate,
+                # we revert to previous Python behavior by explicitly requesting an unverified context.
+                # This is generally not advisable, for obvious reasons, but it is acceptable in the
+                # development and test environments in which these API test utilities are intended to
+                # be used.
+                if sys.hexversion < 0x020709F0:  # Prior to 2.7.9; use default behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port)
+                else:  # 2.7.9 or later; specifically request prior behavior
+                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port, context=ssl._create_unverified_context())
+                    print ""
+                    
+            else :
+                self.__connection = httplib.HTTPConnection(self.__host, self.__port)
+
+            try :
+                self.__connection.request(operation, uri, body, requestHeaders)
+                response = self.__connection.getresponse()
+                # If we're returning the full Response object, then read the response body and construct a Response object;
+                # otherwise, we just return the response from the HTTP(S)Connection object.
+                if return_full_response is True :
+                    result = Response(response.status, response.reason, response.getheaders(), response.read(), request)
+                else :
+                    result = response
+            finally :
+                # If we're returning the full Response object, then we've already read the response and can close out HTTP(S) connection.
+                # Otherwise, leave it open for later reading by, for example, read_response_streamed().  Callers that specify
+                # return_full_response=False are responsible for closing this connection.
+                if return_full_response is True :
+                    self.__connection.close()
+
+        except (ApiFatalException, ApiFatalException) :
+            raise
+        except :
+            text = self.buildExceptionMessage()
+            raise ApiFatalException(text, response=response, traceback=sys.exc_info()[2])
+
+        return result
+
+
+    def buildExceptionMessage(self) :
+        name = sys.exc_info()[0]
+        args = []
+        for arg in sys.exc_info()[1].args :
+            if len(str(arg)) > 0 :
+                args.append(arg)
+                args.append(' ')
+        text = ''.join([ str(s) for s in args ]).strip()
+        return str(name) + ' ' + text
+
+
+    #########################################################################
+    #
+    # read_response_streamed method
+    #
+    # Use this method to read the response to a request that was issued via
+    # __executeRequest with return_full_response==False.  This method will
+    # read the response one byte at a time and then close the connection.
+    #
+    # The response argument is the response as returned from
+    # self.__connection.getresponse().
+    #
+    #########################################################################
+
+    def read_response_streamed(self, response):
+        try :
+            print "\nAbout to read the response one byte at a time...\n"
+            responseString = ""
+            chunk = response.read(1)
+            while (chunk != ""):
+                responseString += chunk
+                sys.stdout.write(chunk)
+                chunk = response.read(1)
+
+        finally :
+            self.__connection.close()
+
+        return responseString
+
+
+#############################################################################
+#
+# Class PyActiveMQ_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a PyActiveMQ client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class PyActiveMQ_Consumer() :
+    # Only define the internals of this class if PyActiveMQ is installed, due to references to the pyactivemq module
+    if (pyactivemq_present == True):
+        """Private class ... do not use directly"""
+
+        class __MessageListener(pyactivemq.MessageListener):
+
+            def __init__(self, topic, callback):
+                pyactivemq.MessageListener.__init__(self)
+                self.topic = topic
+                self.callback = callback
+
+            def onMessage(self, message):
+                try :
+                    self.callback(self.topic, message)
+                except :
+                    print traceback.print_exc()
+
+
+        def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+            """This is the constructor ... all parameters required, exception callback"""
+
+            self.messageLock = threading.Lock()  # Control access to message queue
+
+            self.running = False
+
+            self.host = host
+            self.port = port
+            self.username = username
+            self.password = password
+            self.topic = topic
+            self.use_ssl = use_ssl
+
+            if callback is None :
+                self.callback = self.__callback
+                self.messages = []
+                self.raw_messages = []
+            else :
+                self.callback = callback
+
+            self.url = 'tcp://' + str(self.host) + ':' + str(self.port)
+
+            self.factory = pyactivemq.ActiveMQConnectionFactory(self.url)
+            self.factory.username = self.username;
+            self.factory.password = self.password;
+            print("Creating PyActiveMQ consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+            self.connection = self.factory.createConnection()
+            self.session = self.connection.createSession()
+            self.consumer = self.session.createConsumer(self.session.createTopic(self.topic), "")
+            self.listener = self.__MessageListener(self.topic, self.callback)
+            self.consumer.messageListener = self.listener
+
+
+        def start(self) :
+            """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+            self.connection.start()
+
+
+            self.running = True
+
+        def stop(self) :
+            """Stop consuming messages from the ActiveMQ server"""
+            time.sleep(2)
+
+            self.connection.close()
+            self.running = False
+
+        def isRunning(self) :
+            """Connection still active?"""
+            return self.running
+
+        def has_messages(self) :
+            """Test whether any messages have been received"""
+            self.messageLock.acquire()
+            try :
+                return len(self.messages) > 0
+            finally :
+                self.messageLock.release()
+
+        def get_messages(self) :
+            """Get the current list of received messages ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.messages)
+                self.messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def get_raw_messages(self) :
+            """Get the list of raw messges received so far ... the list is cleared"""
+            self.messageLock.acquire()
+            try :
+                result = list(self.raw_messages)
+                self.raw_messages = []
+                return result
+            finally :
+                self.messageLock.release()
+
+        def __toDictionary(self, message) :
+            """Convert a raw message to a dictionary"""
+            if message is None : return None
+
+            result = {}
+            result[ 'expiration' ] = message.expiration
+            result[ 'timestamp'  ] = message.timestamp
+            result[ 'text'       ] = message.text if len(message.text) > 0 else None
+
+            # Fetch each property in the message and put it into the dictionary.  Treat each
+            # property as a string, unless specifically identified otherwise.  Use the 
+            # appropriate getXXXProperty() method to fetch the value from the raw message.
+            for property in message.propertyNames :
+                string_type = True  # Assume a standard string type, not handled yet
+                # See if this is one of the non-string properties
+                for property_name, property_type in nonstring_message_properties:
+                    if not string_type:  # Known not to be a string; already handled
+                        break
+                    if property == property_name:  # Some non-string type; handle specially
+                        # ##print "Fetching " + property_name + " as type " + property_type
+                        if property_type == 'long':
+                            try:
+                                result[ property ] = message.getLongProperty(property)
+                                string_type = False  # Non-string type; handled
+                            except :  # Failed conversion; ignore and leave it as a string...
+                                print "\n********** error fetching '" + property + "' property as type " + property_type + " from incoming notification message! ***********"
+                                print "Treating it as type string\n"
+                                traceback.print_exc()
+                                # (Allow this code path to continue and attempt to fetch it as a string...)
+                if string_type:
+                    try :
+                        # ##print "Fetching " + property_name + " as type string"
+                        result[ property ] = message.getStringProperty(property)
+                    except :
+                        print "\n********** error fetching '" + property + "' property as type string from incoming notification message! ***********\n"
+                        traceback.print_exc()
+                        result[ property ] = None
+
+                # ##print "property name: " + property + "; value=" + str(result[property]) + "; type=" + str(type(result[property]))
+
+            return result
+
+        def __callback(self, topic, message) :
+            """The default callback method to receive incoming messages"""
+            self.messageLock.acquire()
+            try :
+                if message is not None :
+                    self.messages.append(self.__toDictionary(message))
+                    self.raw_messages.append(message)
+            finally :
+                self.messageLock.release()
+
+        def __execute(self, connection) :
+            """Start listening for messages - deprecated"""
+            try :
+                self.running = True
+                connection.start()
+                while self.running :
+                    time.sleep(1)
+            finally :
+                self.running = False
+                connection.close()
+
+
+#############################################################################
+#
+# Class STOMP_Consumer - Private class ... do not use directly ...
+#
+# This class sets up an ActiveMQ message consumer using a STOMP client.
+#
+# It requires a callback function that will be invoked upon receiving each
+# new message from the ActiveMQ server.  The callback function takes exactly
+# two arguments, the topic registered when the Consumer is created and the
+# incoming message from the server.
+#
+# Typical usage :
+#
+#    Create a Consumer object.
+#    Call Consumer.start to begin consuming messages.
+#    Cause one or more notification events to fire.
+#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
+#    Verify the accuracy of the notification messages.
+#
+#############################################################################
+
+class STOMP_Consumer() :
+    """Private class ... do not use directly"""
+
+    class __STOMPInternalListener():
+
+            def __init__(self, topic, callback):
+                self.callback = callback
+                self.topic = topic
+
+            def on_connecting(self, host_and_port):
+
+                print "Started connecting to broker..."
+
+            def on_connected(self, headers, message):
+
+                print "Now connected to broker: %s" % message
+
+            def on_disconnected(self, headers, message):
+
+                print "No longer connected to broker: %s" % message
+
+            def on_error(self, headers, message):
+
+                print "Received an error: %s" % message
+
+            def on_message(self, headers, message):
+                # This method processes an HMC APi notificaiton message which
+                # always have header fields, and may optionally contain a body
+                # that is a string containing a JSON object.
+
+                try :
+                    # print "inside on_message block"
+                    # print "H is", headers
+                    # print "M is",message
+                    
+                    # If this is a Property Change notification or a Status Change notification, put the body into
+                    # a header named 'text'.  That's where PyActiveMQ puts it, and this hides that difference from
+                    # other places in our Test utilities and the testcase programs themselves.
+                    if (headers['notification-type'] == 'property-change' or headers['notification-type'] == 'status-change' or headers['notification-type'] == 'log-entry'):
+                        headers['text'] = message
+
+                    self.callback(self.topic, headers)
+                except :
+                    print traceback.print_exc()
+
+
+
+
+    def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
+
+        """This is the constructor ... all parameters required, exception callback"""
+
+        self.messageLock = threading.Lock()  # Control access to message queue
+
+        self.running = False
+
+        self.host = host
+        self.port = port
+        self.username = username
+        self.password = password
+        self.topic = topic
+        self.use_ssl = use_ssl
+
+        if callback is None :
+            self.callback = self.__callback
+            self.messages = []
+            self.raw_messages = []
+        else :
+            self.callback = callback
+
+        self._dest = "/topic/" + self.topic
+        print("Creating STOMP consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
+        self.connection = stomp.Connection([(self.host, self.port)], self.username,
+                                            self.password, use_ssl=self.use_ssl,
+                                            ssl_version=ssl.PROTOCOL_SSLv23)
+
+        self._internal_listener = self.__STOMPInternalListener(self.topic, self.callback)
+        self.connection.set_listener('', self._internal_listener)
+
+
+    def start(self) :
+        """Start consuming messages from the ActiveMQ server.  Returns immediately"""
+        self.connection.start()
+        self.connection.connect(wait=True)
+        time.sleep(10)
+        self.connection.subscribe(destination=self._dest, ack="auto")
+
+        self.running = True
+
+    def stop(self) :
+        """Stop consuming messages from the ActiveMQ server"""
+        time.sleep(2)
+
+        self.connection.stop()
+        self.running = False
+
+    def isRunning(self) :
+        """Connection still active?"""
+        return self.running
+
+    def has_messages(self) :
+        """Test whether any messages have been received"""
+        self.messageLock.acquire()
+        try :
+            return len(self.messages) > 0
+        finally :
+            self.messageLock.release()
+
+    def get_messages(self) :
+        """Get the current list of received messages ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.messages)
+            self.messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def get_raw_messages(self) :
+        """Get the list of raw messges received so far ... the list is cleared"""
+        self.messageLock.acquire()
+        try :
+            result = list(self.raw_messages)
+            self.raw_messages = []
+            return result
+        finally :
+            self.messageLock.release()
+
+    def __toDictionary(self, message) :
+        """Convert a raw message to a dictionary"""
+        if message is None : return None
+        result = message
+        return result
+
+    def __callback(self, topic, message) :
+        """The default callback method to receive incoming messages"""
+        self.messageLock.acquire()
+        try :
+            if message is not None :
+
+                # Regardless of the type specified by the HMC code that builds the JMS message, 
+                # the properties always seem to arrive as strings.  Convert the non-string
+                # properties to their proper type here.
+                for property_name, property_type in nonstring_message_properties:
+                    try:
+                        if property_type == 'long':
+                            # ##print "Converting " + property_name + " to " + property_type
+                            message[property_name] = long(message[property_name])
+                    except ValueError:  # Failed conversion; ignore and leave it as a string...
+                        print "\n********** error converting '" + property_name + "' property to type " + property_type + " from incoming notification message! ***********"
+                        print "Leaving it as type " + str(type(message[property_name])) + "\n"
+
+                self.messages.append(self.__toDictionary(message))
+                self.raw_messages.append(message)
+        finally :
+            self.messageLock.release()
+
+    def __execute(self, connection) :
+        """Start listening for messages - deprecated"""
+        try :
+            self.running = True
+            connection.start()
+            while self.running :
+                time.sleep(1)
+        finally :
+            self.running = False
+            connection.close()
+
+#############################################################################
+# Miscellaneous Functions
+#############################################################################
+
+#############################################################################
+#
+# Function parse_standard_options
+#
+# Parses command line options
+#
+# Standard options available to all testcases are :
+#
+#    --addr = IP address of the target HMC
+#    --port = Port number to connect to on the target HMC
+#    --user = Logon userid to use on the target HMC
+#    --pass = Logon password to use on the target HMC
+#    --amq-client = ActiveMQ client to use for notification messages
+#    --amq-socket-type = Type of socket to use for ActiveMQ messages; either ssl or non-ssl
+#    --api-version = Version of the API being tested.  Use this to override the version 
+#                    information reported by the API framework.
+#    
+#    These options are provided primarily to support the FVT regression testing tools.  They are
+#    available to all testcases:
+#    --get-properties = a request to return the testcase's properties
+#    --check-properties = a request to check the testcase's properties against the specified required properties
+#    --run-if-applicable = a request to check the testcase's properties and then run the testcase if all requirements are met
+#    --min-version = required minimum version
+#    --max-version = required maximum version
+#    --capability = required capability; may be specified multiple times
+#    --component = required component; may be specified multiple times
+#    --scenario  = required scenario type; may be specified multiple times
+#    --execution-type = required execution type; may be specified multiple times
+#
+# NOTE : Currently, if ommitted, these values will default to :
+#
+#    Logon to R32 HMC ( 9.60.15.48 ) on the default WSA SSL port with user ensadmin
+#    An ActiveMQ client is chosen based on what is installed; STOMP over SSL is preferred.
+#
+# The additional_options argument may be used to define any additional command
+# line options to be permitted.  It is a list of Option objects created via
+# the make_option() function in the optparse library.  For example:
+#     additional_opts = [
+#         make_option("--srname", dest="storage_resource_name", type="string", default="tempSR", help='The name of the storage resource to be created.  Default is %default.'),
+#         make_option("--count", dest="iteration_count", metavar="COUNT", type="int", help='The number of iterations to run'),
+#         make_option("--treat", dest="dessert", type="choice", choices=["candy", "soda", "fudge"], help='Your dessert choice')
+#         make_option("--verbose", "-v", dest="verbose", action="store_true", default=False, help="Specify this option to get lots of output.  Default is %default."),
+#         ]
+#         
+# Those option definitions are then passed to session_startup():
+#       # Create a session and parse the command line, including our additional options
+#       session = session_startup(additional_options=additional_opts)
+#
+# Note that it is permissible to override any of the standard options by specifying them in additional_options.
+#
+# If the testcase script defines any positional arguments, their Usage information
+# should be specified on the additional_arguments_usage_info argument.  For example,
+#      my_args_usage_info = "property_name timeout_seconds"
+#
+# To see the usage and help information on the command line, issue:
+#         "<script_name> -h" or "<script_name> --help"
+#               
+# Note that this method uses os._exit(rc) in some cases rather than the more
+# common sys.exit(rc).  os._exit(rc) makes a quick exit from the testcase
+# script without raising any exception, including SystemExit.  This makes
+# for a cleaner exit sequence in these special situations.  Note, however,
+# that it also bypasses any finally block; this should be OK, since no
+# session has been created yet and there is most likely no resource cleanup
+# necessary at this point in testcase execution.
+#
+#############################################################################
+
+def parse_standard_options(additional_options=None, additional_arguments_usage_info=None) :
+    # Define the standard options
+    option_list = [
+       make_option(OPTION_ADDR, dest='host', type='string', default=DEFAULT_ADDR,
+           help='The IP address or hostname of the target HMC.  Default=%default'),
+       make_option(OPTION_PORT, dest='port', type='int', default=DEFAULT_PORT,
+           help='The TCP/IP port number on which to connect to the target HMC for Web Services API requests.  Default=%default'),
+       make_option(OPTION_USER, dest=OPTION_USER_DEST, type='string', default=WSA_DEFAULT_USERID,
+           help='The HMC userid to use for the API request.  Default=%default'),
+       make_option(OPTION_PASS, dest=OPTION_PASS_DEST, type='string', default=WSA_DEFAULT_PASSWORD,
+           help='The login password for the HMC userid to use for the API request.  Default is the default user\'s standard password.'),
+       make_option('--amq-client', dest='amq_client', type='choice', choices=[AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP],
+           help='ActiveMQ client: %s or %s.  Default is %s unless it is not installed and %s is installed.'
+               % (AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP, AMQ_CLIENT_STOMP, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option('--amq-socket-type', dest='amq_socket_type', type='choice', choices=[SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL],
+           help='ActiveMQ socket type: %s or %s.  Default depends on the ActiveMQ client: %s for %s; %s for %s.'
+               % (SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL, SOCKET_TYPE_SSL, AMQ_CLIENT_STOMP, SOCKET_TYPE_NON_SSL, AMQ_CLIENT_PYACTIVEMQ)),
+       make_option(OPTION_API_VERSION, dest='api_version_override', metavar='API_VERSION', type='string',
+           help='The version information for the API implementation being tested.  Specify this to override the version level reported by the API framework on the target HMC.'),
+       # for force tags
+       make_option("--include", type='string', default=""),
+       make_option("--exclude", type='string', default=""),
+       make_option("--variablefile", type='string', default=""),
+       make_option("--outputdir", type='string', default=""),
+        
+       ]
+
+    # Define our usage statement
+    usage_info = "%prog [options]"  # There are no standard command line arguments, only options
+
+    # Add any additional testcase-specific options
+    if additional_options is not None:
+        option_list.extend(additional_options)
+    
+
+    # Add any additional testcase-specific usage information
+    if additional_arguments_usage_info is not None:
+        usage_info += " " + additional_arguments_usage_info
+    # Create a parser with the options
+    parser = optparse.OptionParser(option_list=option_list, usage=usage_info, conflict_handler="resolve")
+
+    # Define a group of options intended for use by the FVT regression bucket and then add the specific option definitions to the group.
+    # This group will appear separate from the other command line options in the usage and help information.
+    FVT_option_group = OptionGroup(parser, 'Function Verification Test (FVT) regression test options', 'These options are intended primarily for use by the FVT regression tools.'
+        + '  Only one of %s, %s or %s may be specified.' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        + '  Some options may each be specified more than once.  If so, a testcase need only support one of the specified values in order to satisfy that requirement.'
+        + '  These options are: %s, %s, %s and %s' % (OPTION_CAPABILITY, OPTION_COMPONENT, OPTION_SCENARIO, OPTION_EXECUTION_TYPE))
+    
+    # The type of operation to perform.  Only 1 of these should be specified.
+    FVT_option_group.add_option(make_option(OPTION_GET_PROPERTIES, dest='get_properties', action='store_true', default=False,
+        help='Denotes a request to return the testcase properties.  These are defined by the %s variable in the testcase source code.' % TESTCASE_PROPERTIES_VARIABLE_NAME))
+    FVT_option_group.add_option(make_option(OPTION_CHECK_PROPERTIES, dest='check_properties', action='store_true', default=False,
+        help='Denotes a request to check testcase properties against the required testcase properties specified on the command line.'))
+    FVT_option_group.add_option(make_option(OPTION_RUN_IF_APPLICABLE, dest='run_if_applicable', metavar='APPLICABLE', action='store_true', default=False,
+        help='Denotes a request to check properties as if %s were specified and then, if the testcase meets the specified requirements, actually execute the testcase.' % OPTION_CHECK_PROPERTIES))
+    # Required API version
+    FVT_option_group.add_option(make_option(OPTION_REQUIRED_VERSION, dest='required_version', metavar='VERSION', type='choice', choices=TC_API_VERSION_LIST,
+        help='A required testcase property: the required API version.  The testcase must support this API level.'
+             '  That is, this level must be between the testcase\'s supported minimum and maximum levels, inclusive.  Valid values are: %s' % TC_API_VERSION_LIST))
+    # Testcase properties that can have multiple values.  If a property is specified more than once on the command line, a testcase is
+    # considered to meet that criterion if it includes at least one of the specified values.  That is, they are logically OR'd together.
+    # Then the different properties are AND'd together.
+    FVT_option_group.add_option(make_option(OPTION_CAPABILITY, dest='required_capabilities', metavar='CAPABILITY', action='append', choices=TC_CAPABILITY_LIST,
+        help='A required testcase property: a capability.  May be specified multiple times.  Valid values are: %s' % TC_CAPABILITY_LIST))
+    FVT_option_group.add_option(make_option(OPTION_COMPONENT, dest='required_components', metavar='COMPONENT', action='append', choices=TC_COMPONENT_LIST,
+        help='A required testcase property: a component.  May be specified multiple times.  Valid values are: %s' % TC_COMPONENT_LIST))
+    FVT_option_group.add_option(make_option(OPTION_SCENARIO, dest='required_scenario_types', metavar='SCENARIO_TYPE', action='append', choices=TC_SCENARIO_TYPE_LIST,
+        help='A required testcase property: a scenario.  May be specified multiple times.  Valid values are: %s' % TC_SCENARIO_TYPE_LIST))
+    FVT_option_group.add_option(make_option(OPTION_EXECUTION_TYPE, dest='required_execution_types', metavar='EXECUTION_TYPE', action='append', choices=TC_EXECUTION_TYPE_LIST,
+        help='A required testcase property: an execution type.  May be specified multiple times.  Valid values are: %s' % TC_EXECUTION_TYPE_LIST))
+
+    # Add the group of FVT regression bucket options
+    parser.add_option_group(FVT_option_group)
+
+    (opts, args) = parser.parse_args()
+
+    #
+    # The command line options have been parsed and validated.  Some of them will be handled
+    # here.  These are the FVT regression run options.  Individual testcases don't even need
+    # to know that these options exist.  Handle them and then exit the testcase directly (not
+    # even "finally:" blocks are executed).  If none of these special options was specified,
+    # return the option and argument collections to the caller for handling of the other
+    # options and arguments, if any.
+    #
+
+    # Determine and validate the type of request specified on the command line, if any
+    get_properties_request = opts.get_properties
+    check_properties_request = opts.check_properties
+    run_if_applicable_request = opts.run_if_applicable
+    option_count = ((1 if get_properties_request else 0)
+                  + (1 if check_properties_request else 0)
+                  + (1 if run_if_applicable_request else 0))
+
+    if (option_count > 1):  # Only 0 (they're all optional) or 1 of these options may be specified at a time
+        print 'At most 1 of the following options may be specified: %s, %s, %s' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
+        os._exit(WSA_EXIT_INVALID_COMMAND_LINE)  # Make a direct exit
+
+    # Fetch the testcase properties from the testcase source code itself
+    testcase_props = getattr(__main__, TESTCASE_PROPERTIES_VARIABLE_NAME, None)
+
+    # Certain requests need the testcase properties.  Make sure they are defined.
+    if get_properties_request or check_properties_request or run_if_applicable_request:
+        if testcase_props is None:
+            print "The testcase source code does not define the %s variable" % TESTCASE_PROPERTIES_VARIABLE_NAME
+            os._exit(WSA_EXIT_MISSING_TESTCASE_PROPERTIES)  # Make a direct exit
+
+    # Handle a request to display the testcase properties
+    if get_properties_request:
+        print GET_PROPERTIES_BEGIN_MARKER
+        print "%s=\n%s" % (TESTCASE_PROPERTIES_VARIABLE_NAME, pprint.pformat(testcase_props))
+        print GET_PROPERTIES_END_MARKER
+        os._exit(WSA_EXIT_GET_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    # Handle requests that need to check the testcase properties against the required properties.
+    if check_properties_request or run_if_applicable_request:
+        # Check all simple string properties.  Some may have been specified multiple times on the command line.
+        properties_to_check = [(testcase_props, TC_CAPABILITIES, opts.required_capabilities),
+                               (testcase_props, TC_COMPONENT, opts.required_components),
+                               (testcase_props, TC_SCENARIO_TYPE, opts.required_scenario_types),
+                               (testcase_props, TC_EXECUTION_TYPE, opts.required_execution_types),
+                              ]
+
+        for property in properties_to_check:
+            # print 'checking %s' % property[1]
+            if check_testcase_requirement(property[0], property[1], property[2]) is False:
+                print "The testcase does not support any required value for the '%s' property, supplied values are " % (property[1]), (property[2])
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Doesn't meet this requirement, so exit.  Make a direct exit.
+    
+        # If a required API version was specified, check it now by making sure it is within the
+        # range defined by the testcase's minimum supported version and its maximum supported version
+        # (if defined).  First make sure its minimum supported version is <= the requirement.
+        required_version = opts.required_version
+        if required_version is not None:
+            if TC_MINIMUM_API_VERSION not in testcase_props.keys():
+                print "The testcase properties do not define the %s property" % (TC_MINIMUM_API_VERSION)
+                os._exit(WSA_EXIT_PROPERTY_NOT_DEFINED)  # Make a direct exit
+
+            available_minimum_version = testcase_props[TC_MINIMUM_API_VERSION]  # Get the value of this testcase property
+            # print "required & supported min versions: %s, %s" % (required_version, available_minimum_version)
+            # if required_minimum_version < available_minimum_version:
+            if not is_version_at_most(required_version, available_minimum_version):  # required < supported min
+                print "The testcase does not support the %s required API version; the testcase supports a minimum version of %s" % (required_version, available_minimum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If a required maximum version was specified and the testcase provides it, check it now.  This is
+        # an optional property that is not expected to be used very often.  It is intended to denote a
+        # testcase that has become obsolete at a certain API level.  Make sure the testcase's maximum
+        # supported version is >= the requirement.
+        if required_version is not None and TC_MAXIMUM_API_VERSION in testcase_props.keys():
+            available_maximum_version = testcase_props[TC_MAXIMUM_API_VERSION]  # Get the value if this testcase property
+            # print "required & supported max versions: %s, %s" % (required_maximum_version, available_maximum_version)
+            # if required_version > available_maximum_version:
+            if not is_version_at_most(available_maximum_version, required_version):  # required > supported max
+                print "The testcase does not support the %s required API version; the testcase supports a maximum version of %s" % (required_version, available_maximum_version)
+                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
+
+        # If we're only checking testcase requirements, all requirements are met and we're done!
+        # If this is a run-if-applicable request, all requirements have been met, so continue and
+        # actually execute the testcase.
+        if check_properties_request:   
+            print "The testcase meets the specified requirements"
+            os._exit(WSA_EXIT_CHECK_PROPERTIES_SUCCESS)  # Make a direct exit
+
+    return (opts, args)
+
+
+#############################################################################
+#
+# This method provides a simple method to validate the response from an HTTP
+# request.
+#
+# @param rs - the Response object returned by one of the Session methods,
+#             such as Session.get, for example.
+# @param vm - validation map that can contain on or more of the following:
+#             status       : the expected status code from the operation
+#             content-type : the expected content type in the response
+#             required     : a list of required properties in the
+#                            response body
+#             optional     : a list of optional properties in the
+#                            response body
+#
+# An example validation map :
+#  { 'status':200,
+#    'content-type':'application/json',
+#    'required':[],
+#    'optional':[] }
+#
+# All validation map parameters are optional.  Parameters that are not
+# present in the map will not be used as part of the validation test.
+#
+# @return True is validation is successful, False otherwise
+#
+#############################################################################
+
+def validate_response(rs, vm) :
+
+    if vm is None : return True  # Nothing to validate in this case ...
+
+    if rs is None or not isinstance(rs, Response) :
+        raise ApiFatalException('Response missing or invalid', response=rs)
+
+    # Validate the status
+    if 'status' in vm and rs.status != vm[ 'status' ] :
+        raise ApiException('Invalid status ' + str(rs.status) + ' ' + str(rs.reason), response=rs)
+
+    # Validate the content type
+    content = rs.headers[ WSA_HEADER_CONTENT ] if WSA_HEADER_CONTENT in rs.headers else None
+    if WSA_HEADER_CONTENT in vm :
+        if content is None or not content.startswith(vm[ WSA_HEADER_CONTENT ]) :
+            raise ApiException('Invalid content type ' + str(content), response=rs)
+
+    if content is not None and content.startswith(WSA_CONTENT_JSON) :
+        req = vm[ 'required' ] if 'required' in vm else None
+        opt = vm[ 'optional' ] if 'optional' in vm else None
+        try :
+            validate_dictionary(rs.body, req, opt)
+        except ApiException as exception :
+            exception.response = rs
+            raise exception
+
+    return True
+
+
+
+
+# Verify the response is consistent with No Content (204)
+# @param response Response object
+def validate_no_content_response (response) :
+    print
+    print 'Validating that Response is a proper No Content (204) response'
+    if response.status != 204 :
+        print_response(response)
+        raise Exception('Failed: Expected No Content status 204, got ' + str(response.status))
+    if response.headers.get(WSA_HEADER_CONTENT) != None :
+        print_response(response)
+        raise Exception('Failed: Expected no content-type header for 204 response, got ' + str(response.headers.at(WSA_HEADER_CONTENT)))
+    if (response.body != None) and (response.body != '') and (response.body != '{}') :  # Response object returns {} for no content?
+        print_response(response)
+        raise Exception('Failed: Expected no content in body, got ' + str(response.body))
+# end validate_no_content_response
+
+#############################################################################
+#
+#############################################################################
+
+def validate_dictionary(dict, req, opt) :
+
+    if dict is None or type(dict) is not types.DictType :
+        raise ApiFatalException('Dictionary missing or invalid type')
+
+    if req is None : req = []
+    if opt is None : opt = []
+
+    if req == [] and opt == [] : return True
+
+    allKeys = set(dict.keys())
+    reqKeys = set(req)
+    result = reqKeys.difference(allKeys)
+    if len(result) > 0 :
+        raise ApiException('Missing required keys', keys=sorted(list(result)))
+
+    optKeys = set(opt)
+    result = allKeys.difference(reqKeys).difference(optKeys)
+    if len(result) > 0 :
+        raise ApiException('Extraneous keys found', keys=sorted(list(result)))
+
+    return True
+
+
+#############################################################################
+# Return a list of all ensembles, after first validating the response
+#############################################################################
+
+def list_ensembles(session) :
+    ensembles = None
+    response = session.get(WSA_URI_ENSEMBLES)
+    validate_response(response, WSA_LIST_ENSEMBLES_VALIDATE)
+    for ensemble in response.body[ 'ensembles' ] :
+        validate_dictionary(ensemble, WSA_LIST_ENSEMBLE_REQUIRED, [])
+    return response.body[ 'ensembles' ]
+
+
+#############################################################################
+# Update the ensemble properties 
+# ensemble_uri : the uri of the ensemble to be updated (str)
+# request_body : request body containing the fields to update (dict)
+#############################################################################
+
+def update_ensemble(session, ensemble_uri, request_body):
+    response = None
+    print 'ensemble update body: ' + json.dumps(request_body)
+    response = session.post(ensemble_uri, json.dumps(request_body))
+    print 'Ensemble update response status: ' + str(response.status)
+    return response
+
+
+#############################################################################
+# Return information about the ensemble on the system
+#############################################################################
+
+def get_ensemble_info(session) :
+    print '\nGet the ensemble information'
+    ensembles = list_ensembles(session)
+    if len(ensembles) == 0 :
+        raise Exception('No ensemble defined on system')
+    ensemble_info = ensembles[0]
+    ensemble_uri = ensemble_info['object-uri']
+    print 'Ensemble uri is [' + ensemble_uri + ']'
+    return ensemble_uri, ensemble_info
+
+
+#############################################################################
+# Return all the properties of the specified ensemble
+#############################################################################
+
+def get_ensemble_properties(session, ensemble) :
+    response = session.get(ensemble[ 'object-uri' ])
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return all the properties of the ensemble identified by its URI
+#############################################################################
+
+def get_ensemble_properties_by_uri(session, ensemble_uri) :
+    response = session.get(ensemble_uri)
+    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
+    else :
+        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
+    return response.body
+
+
+#############################################################################
+# Return a list of all cpcs, afer first validating the response
+#############################################################################
+
+def list_cpcs(session) :
+    cpcs = None
+    response = session.get(WSA_URI_CPCS)
+    if response.status != 200:
+        raise ApiException("ERROR: status=" + response.status + ", uri=" + WSA_URI_CPCS)
+    strCPCs = str(response)
+    cpcCount = strCPCs.count('object-uri')
+    if cpcCount == 0 :
+        raise ApiException('No cpcs defined on system')
+    validate_response(response, WSA_LIST_CPCS_VALIDATE)
+    for cpc in response.body[ 'cpcs' ] :
+        validate_dictionary(cpc, WSA_LIST_CPC_REQUIRED, [])
+    cpcs = response.body['cpcs']
+    return cpcs
+    
+
+#############################################################################
+# Return either the default CPC or the first cpc found in the operating state
+#############################################################################
+
+def get_operating_cpc(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    # # See how many cpcs we have
+    strCPCs = str(cpcs)
+    n = strCPCs.count('object-uri')
+    cpc_name = ''
+    # # See if we have a default CPC name to find
+    if DEFAULT_CPC_NAME != '' :
+        # # Find the default cpc
+            for i in range(0, n):
+                if (cpcs[i]['name'] == DEFAULT_CPC_NAME) & (cpcs[i]['status'] == 'operating') :
+                    cpc_uri = cpcs[i]['object-uri']
+                    cpc_name = cpcs[i]['name']
+                    print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                    break
+    # # If default CPC is not found and operating, look for the first operating CPC
+    if cpc_name == '' :
+        # # Find an operating cpc
+        for i in range(0, n):
+            if (cpcs[i]['status'] == 'operating') :
+                cpc_uri = cpcs[i]['object-uri']
+                cpc_name = cpcs[i]['name']
+                print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
+                break
+    # # Make sure we found an operating cpc
+    if cpc_name == '' :
+        raise Exception('No operating cpcs defined on system')
+    else :
+        # cpc_uri = cpcs[0]['object-uri']
+        return cpc_uri
+    
+    
+#############################################################################
+# Return either the default CPC or the first cpc found
+#############################################################################
+
+def get_cpc_new(session) :
+    print '\nGet the operating cpc'
+    cpcs = list_cpcs(session)
+    if len(cpcs) == 0 :
+        raise Exception('No cpcs defined on system')
+    targetCpc = None
+    for cpc in cpcs :
+        if cpc['name'] == APA_TESTENV_CPC_UNDER_TEST :
+            targetCpc = cpc
+            break
+    if targetCpc is None :
+        raise ApiFatalException("Unable to find a required CPC, exiting")    
+    cpc_uri = targetCpc['object-uri']
+    return cpc_uri
+
+
+##########################################################################################
+# Return either the default virtualization host or the first found in the operating state
+##########################################################################################
+
+def get_operating_virtualization_host(session, virtualization_hosts) :
+    print '\nGet the operating virtualization host'
+    virtualization_host_name = None
+    for virtualization_host in virtualization_hosts :
+        if virtualization_host[ 'name' ] == DEFAULT_VIRTUALIZATION_HOST_NAME :
+            if  virtualization_host[ 'status' ] == 'operating' :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    if virtualization_host_name is None :
+        for virtualization_host in virtualization_hosts :
+            if (virtualization_host[ 'status' ] == 'operating') & (virtualization_host[ 'type' ] == 'zvm')  :
+                virtualization_host_name = virtualization_host[ 'name' ]
+                break
+    # # Make sure we found an operating virtualization host
+    if virtualization_host_name is None :
+        raise ApiFatalException('No zvm virtualization host present in the Ensemble or is not in the right state to perform this test')
+    else :
+        return virtualization_host
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble(session, ensemble_info, query=None) :
+    return list_virtualization_hosts_by_ensemble_uri(session, ensemble_info['object-uri'], query)
+
+
+#############################################################################
+# Return a list of virtualization-host-info objects for all virtualization
+# hosts managed by the specified ensemble that match the optional query
+# filter, after first validating the response
+#############################################################################
+
+def list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=None) :
+    response = None
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    if query is None :
+        response = session.get(node_uri + '/virtualization-hosts')
+    else :
+        response = session.get(node_uri + '/virtualization-hosts?' + query)
+    validate_response(response, WSA_LIST_VIRT_HOSTS_VALIDATE)
+    for host in response.body[ 'virtualization-hosts' ] :
+        validate_dictionary(host, WSA_LIST_VIRT_HOST_REQUIRED, [])
+    return response.body[ 'virtualization-hosts' ]
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for an arbitrary
+# (or specific, if virtualization_host_name is specified) virtualization
+# host of the specified type, managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host(session, virtualization_host_type, ensemble_uri=None, virtualization_host_name=None):
+    print '\nSearching the ensemble for a virtualization_host of type ' + virtualization_host_type
+    typefilter = 'type=%s' % (virtualization_host_type)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+    
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, 'name=ZBX51.*&'+typefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    if len(nodes) == 0 :
+        raise Exception('No suitable node (name=' + WSA_DEFAULT_ZBX_NAME + ') is defined in ensemble ' + ensemble_name)
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + typefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_type + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    # Set the virtualization host name to search for, if any
+    vh_name = None
+    if virtualization_host_name is None:
+        # If we're looking for a zvm virtualization host on the R32 ensemble, restrict Test usage to a specific virtualization host
+        if virtualization_host_type == 'zvm':
+            if ensemble_name == ENSEMBLE_NAME_R32:
+                vh_name = PREFERRED_ZVM_VIRTUALIZATION_HOST_R32
+    else:
+        vh_name = virtualization_host_name
+
+    virtualization_host_info = None  # Assume no appropriate virtualization host will be found
+    if vh_name is None:
+        virtualization_host_info = virtualization_hosts[0]  # Use the first one (arbitrary choice)
+    else:
+        for virtualization_host in virtualization_hosts:  # Iterate over all vh info objects that match the desired vh type
+            if virtualization_host['name'] == vh_name:  # Found it
+                virtualization_host_info = virtualization_host
+        if virtualization_host_info is None:
+            raise Exception('No ' + virtualization_host_type + ' virtualization host with name ' + vh_name + ' is defined in ensemble ' + ensemble_name)
+
+    virtualization_host_uri = virtualization_host_info['object-uri']
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI and a virtualization-host-info object for a specified
+# virtualization host managed by the specified ensemble.  Raises
+# an Exception if none is found.
+#############################################################################
+
+def find_virtualization_host_by_name(session, virtualization_host_name, ensemble_uri=None):
+    print '\nSearching the ensemble for a virtualization_host of name ' + virtualization_host_name
+    namefilter = 'name=%s' % (virtualization_host_name)
+
+    # Get the ensemble name, and uri if not provided
+    if ensemble_uri is None:
+        ensemble_uri, ensemble_info = get_ensemble_info(session)
+        ensemble_name = ensemble_info['name']
+    else:
+        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
+        ensemble_name = ensemble_properties['name']
+
+    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=namefilter)
+    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
+    nodes = response.body['nodes']
+    node_uri = nodes[0]['element-uri']
+    response = session.get(node_uri + "/virtualization-hosts?" + namefilter)
+    virtualization_hosts = response.body['virtualization-hosts']
+    if len(virtualization_hosts) == 0 :
+        raise Exception('No ' + virtualization_host_name + ' virtualization hosts defined in ensemble ' + ensemble_name)
+
+    virtualization_host_info = virtualization_hosts[0]
+    virtualization_host_uri = virtualization_host_info['object-uri']
+
+    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
+    return virtualization_host_uri, virtualization_host_info
+
+
+#############################################################################
+# Returns the URI of a virtual server object with the specified name owned
+# by the specified virtualization host.  If return_response is True, then
+# the response object is always returned; otherwise, the URI is returned
+# or an exception is raised.
+#############################################################################
+
+def find_virtual_server_in_virtualization_host(session, virtualization_host_uri, virtual_server_name, return_response=False) :
+    # Find the VS within the specified VH
+    response = session.get(virtualization_host_uri + "/virtual-servers?name=" + virtual_server_name)
+    if response.status != 200:
+        msg = "An error occurred fetching virtual server information for the virtualization host"
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    virtual_servers = response.body["virtual-servers"]
+    if len(virtual_servers) == 0 :
+        msg = "The virtualization host has no virtual server with name " + virtual_server_name
+        print msg
+        if return_response :
+            return response
+        else :
+            print response
+            raise Exception(msg)
+
+    if return_response :
+        return response
+    else :
+        return virtual_servers[0]["object-uri"]
+
+
+#############################################################################
+# Startup method to create session and logon ...
+# Connection parameters (host, port, user, and pwd) should not be overridden
+# by test scripts unless there is an explicit need (eg log in under different
+# users to verify access permission)
+# @param host - IP address of the target HMC (str)
+# @param port - Port number to connection on the target HMC (int)
+# @param user - Logon userid to use on the target HMC (str)
+# @param pwd  - Logon password to use on the target HMC(str)
+# @param additional_options - any additional command line option definitions.
+#               See parse_standard_options() and the Session class for more details.
+#               (list of Option objects created via make_option())
+# @param additional_arguments_usage_info - Usage information for any additional
+#               command line arguments.  See parse_standard_options() and the
+#               Session class for more details. (str)
+# @param amq-client - ActiveMQ client to use for notification messages
+# @param amq-socket-type - Type of socket to use for ActiveMQ messages;
+#               either ssl or non-ssl
+#
+# Note that the Session __init__ method calls parse_standard_options(), which 
+# uses os._exit(rc) in some cases rather than the more common sys.exit(rc).
+# See the prolog of parse_standard_options for more details.
+#############################################################################
+
+#############################################################################
+# Find the object with a given name from a list of objects
+#############################################################################
+def find_object_by_name(session, object_list, object_name) :
+    result = None
+    for obj in object_list :
+        if type(obj['name']) is unicode :
+            obj_name = obj['name'].encode('utf-8')
+        if (obj_name == object_name) :
+            result = obj
+    return result
+
+
+def session_startup(host=None, port=None, user=None, pwd=None, verbose=False, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
+    session = Session(host, port, user, pwd, additional_options, additional_arguments_usage_info, amq_client, amq_socket_type)
+
+    # Now open the session by establishing an HTTP connection to the target HMC
+    if verbose :
+        print 'Connecting to', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+    session.open()
+    if verbose :
+        print 'Session ID: \t%s' % session.session()
+
+    return session
+
+
+#############################################################################
+# Determine if the API version being tested is at least as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# added or changed in an incompatible fashion after the initial API release.
+# The testcase can use this function in order to know what behavior to expect
+# from the API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_least(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    # return (api_version >= version_to_check)  #??? Need to do a real implementation of this that can handle all valid version formats!  (For example, need to be able to compare "1.2" and "1.12")
+    return is_version_at_least(version_to_check, api_version)
+
+
+# See is_api_version_at_least() above for description
+def is_version_at_least(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_least: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version >= version_to_check)
+
+    # Iterate over the numeric parts of the input version number and compare them to the
+    # corresponding parts of the session's API version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(version_to_check_parts)):
+        version_to_check_part = int(version_to_check_parts[i])
+        if len(api_version_parts) >= i + 1:
+            api_version_part = int(api_version_parts[i])
+        else:  # Not enough parts in api_version; supply a 0
+            api_version_part = 0
+        if version_to_check_part < api_version_part:
+            return True
+        elif version_to_check_part > api_version_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the input version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # version_to_check has fewer parts, which means that it cannot be greater than
+    # api_version.  Thus it must be <=, so we return True.
+    return True
+
+
+#############################################################################
+# Determine if the API version being tested is exactly the same as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.
+# 
+# Returns:
+#    True if it is; otherwise, False.
+#############################################################################
+
+def is_api_version_exactly(session, version_to_check):
+    api_version = api_effective_version(session)
+    # print 'api version = %s' % api_version
+    return (api_version == version_to_check)
+
+
+#############################################################################
+# Determine if the API version being tested is at most as recent (high) as
+# the specified API version.  The version information for the API implementation
+# being tested comes from the API framework itself (GET /api/version) unless it
+# has been overridden via the --api-version command line option.  The version
+# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
+#
+# This method is intended for use by testcases that test function that was
+# removed or changed in an incompatible fashion at some point.  The testcase
+# can use this function in order to know what behavior to expect from the
+# API(s) it is testing.
+# 
+# Returns:
+#    True if it is; False otherwise
+#############################################################################
+
+def is_api_version_at_most(session, version_to_check):
+    api_version = api_effective_version(session)
+    return is_version_at_most(version_to_check, api_version)
+
+
+# See is_api_version_at_most() above for description
+def is_version_at_most(version_to_check, api_version):
+    # Split each version string into its numeric parts
+    api_version_parts = api_version.split('.')
+    version_to_check_parts = version_to_check.split('.')
+
+    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
+    # a meaningful numeric comparison, so just do a straight string comparison.
+    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
+    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
+        print "is_version_at_most: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
+        return (api_version <= version_to_check)
+
+    # Iterate over the numeric parts of the session's API version number and compare them to the
+    # corresponding parts of the input version number.  Once an inequality is found,
+    # we know which is greater.
+    for i in xrange(len(api_version_parts)):
+        api_version_part = int(api_version_parts[i])
+        if len(version_to_check_parts) >= i + 1:
+            version_to_check_part = int(version_to_check_parts[i])
+        else:  # Not enough parts in version_to_check; supply a 0
+            version_to_check_part = 0
+        if api_version_part < version_to_check_part:
+            return True
+        elif api_version_part > version_to_check_part:
+            return False
+        # Equal, need to look at next part, if any
+
+
+    # We checked all of the numeric parts of the API version number without finding
+    # an inequality.  This means that either the versions are completely equal or 
+    # api_version has fewer parts, which means that it cannot be greater than
+    # version_to_check.  Thus it must be <=, so we return True.
+    return True
+
+# Return the "effective" version (the version reported by the HMC itself, or the override
+# value from the command line (if specified).
+def api_effective_version(session):
+    return session.api_version() if session.api_version_override() is None else session.api_version_override()
+
+#############################################################################
+# Determine if the specified WS API feature is available to the current session.
+# 
+# Returns:
+#    True if the feature is available; otherwise, False.
+#############################################################################
+
+def is_feature_available(session, feature):
+    features = session.api_features()
+    return (features is not None and feature in features)
+
+
+#############################################################################
+# Check the supplied testcase properties to see if they meet at least one of
+# the required values for the specified property.  This is effectively a
+# logical OR of the required property values.
+# 
+# Returns:
+#    True if the testcase supports at least one of the required property
+#    values; otherwise, False.
+#############################################################################
+
+def check_testcase_requirement(testcase_properties, property_name, required_properties):
+    if required_properties is None:
+        required_found = True
+    else:
+        # Check required property; these are OR'd together
+        required_found = False  # Something is required; assume we don't have it
+
+        if property_name in testcase_properties.keys():
+            available = testcase_properties[property_name]
+            for r in required_properties :
+                # Many requirement values are accepted in upper or lower case, so 
+                # convert everything to lowercase before looking for a match.
+                # We currently support testcase properties whose values are of
+                # type string or list.
+                # if r.upper() in available:
+                if type(available) is types.StringType:  # A string
+                    if r.lower() == available.lower():
+                        required_found = True
+                        break
+                else:  # Assume a list
+                    if r.lower() in make_lowercase_copy(available):
+                        required_found = True
+                        break
+        else:
+            print "The testcase properties do not define the %s property" % (property_name)
+
+    return required_found
+
+
+#############################################################################
+# Exit test code cleanly ...
+# By default, all "temporary" objects are deleted, and any "admin sessions"
+# and "temporary sessions" are shutdown after the specified session is shutdown.
+#############################################################################
+
+def session_shutdown(session, verbose=True, delete_temporary_objects=True, delete_admin_sessions=True, delete_temporary_sessions=True) :
+    if session is not None :
+        if verbose :
+            print 'Disconnecting from', session.hmc_name(), 'at', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
+        try :
+            session.close()
+        except (ApiException, ApiFatalException) as exception :
+            print
+            print 'Exception raised during shutdown ...'
+            print exception
+            print
+
+
+    # Delete temporary sessions first, in case one is for a temporary user that we're
+    # about to delete in delete_all_temporary_objects().
+    if delete_temporary_sessions:
+        delete_all_temporary_sessions()
+
+    if delete_temporary_objects:
+        delete_all_temporary_objects()
+
+    if delete_admin_sessions:
+        delete_all_admin_sessions()
+
+
+#############################################################################
+# This function returns True if value is a number, False otherwise.
+#############################################################################
+
+def isNumeric(value) :
+    try :
+        float(value)
+    except (ValueError) :
+        return False
+    return True
+
+
+#############################################################################
+#
+# This function prints out data as formatted columns.
+#
+# Formatting is simple : Strings will be left-justified
+#                        Numbers will be right-justified
+#
+# Input :
+#
+#   The keys parameter is a list of keys whose values should be printed
+#   The data parameter is a list of dictionaries
+#
+# No error checking is done currently ...
+#
+# Example :
+#
+#    keys = [ 'name', 'status', 'type' ]
+#    data = [ { 'name':'abc',     'type':'foo',    'status':'operating',     'count':1    },
+#             { 'name':'abcde',   'type':'bar',    'status':'not_operating', 'count':10   },
+#             { 'name':'ab',      'type':'foobar', 'status':'status_check',  'count':100  },
+#             { 'name':'abcdefg', 'type':'fubar',  'status':'starting',      'count':1000 } ]
+#
+#    prettyPrint( data, keys ) will print ...
+#
+#       abc     operating     foo
+#       abcde   not_operating bar
+#       ab      status_check  foobar
+#       abcdefg starting      fubar
+#
+#############################################################################
+
+def prettyPrint(data, keys) :
+    if data is None or len(data) == 0 : return
+    if keys is None or len(keys) == 0 : return
+    width = {}
+    for key in keys :
+        width[ key ] = max([ len(str(row[ key ])) for row in data ])
+    for row in data :
+        for key in keys :
+            if isNumeric(row[ key ]) :
+                print str(row[ key ]).rjust(width[ key ]),
+            else :
+                print str(row[ key ]).ljust(width[ key ]),
+        print
+
+
+# Print a Response object with formatted headers and body
+# @param response - API response (Response)
+def print_response(response, sort_body=True) :
+    if response is None or response.__class__ is not Response :
+        raise ApiFatalException('response is missing or invalid type')
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(response.headers, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    print json.dumps(response.body, sort_keys=sort_body, indent=1, separators=(',', ':'))
+    if 'stack' in response.body:
+        print 'stack (again, but in a more programmer-friendly format):'
+        print response.body['stack']
+    return
+# end print_response
+
+
+# Print information in a formatted fashion from a response object and an optional response body.
+# This is useful for streamed responses; see return_full_response in wsautils.py and the 
+# read_response_streamed() function.
+def print_response_info(response, response_body=None) :
+    print 'Response Status  : ' + str(response.status)
+    print 'Response Reason  : ' + str(response.reason)
+    print 'Response Headers :'
+    print json.dumps(dict (response.getheaders()), indent=1, separators=(',', ':'))
+    print 'Response Body    :'
+    if response_body is None:
+        print json.dumps(response.read(), indent=1, separators=(',', ':'))
+    else:
+        body = json.loads(response_body)
+        print json.dumps(body, indent=1, separators=(',', ':'))
+    return
+   # end print_response_info
+
+
+# Print a line(s) between separator lines so that they stand out among the testcase output.
+# Optional text can be included in the separator line that precedes the lines and the one 
+# that follows the lines.  The length and composition of the separator line can by customized
+# with input parameters.
+def print_between_separator_lines(lines, header_text=None, footer_text=None, length=90, box_char="=", blank_lines=1):
+    if header_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(header_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, header_text)  # Leading box chars and header text
+
+    header_line = "%s%s%s" % ("\n"*blank_lines, line, box_char * (length - len(line)))  # Add the blank lines and trailing box chars
+    print header_line
+
+    # Write all of the input lines
+    for line in lines:
+        print line
+    
+    if footer_text == None:
+        line = ""
+    else:
+        box_char_count = (length - len(footer_text) - 2) / 2
+        line = "%s %s " % (box_char * box_char_count, footer_text)  # Leading box chars and footer text
+
+    footer_line = "%s%s%s" % (line, box_char * (length - len(line)), "\n"*blank_lines)  # Add the trailing box chars and blank lines
+    print footer_line
+
+
+#############################################################################
+#
+# Filter a list of dictionaries based on keys and values
+#
+# This function is a "generator", meaning its output should be wrapped
+# in a list in order to iterate over the results.
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'foo'.
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'foo'
+# print list( filter_dictionary( data, func ) )
+#
+# The following snippet will return all the dictionaries in the list that
+# contain the key 'bar' with the value of 'bar2'
+#
+# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
+# func = lambda k, v : k == 'bar' and v == 'bar2'
+# print list( filter_dictionary( data, func ) )
+#
+#############################################################################
+
+def filter_list(data, predicate=lambda k, v: True) :
+    for d in data:
+         for k, v in d.items():
+               if predicate(k, v):
+                    yield d
+
+#########################################################################
+# Determine the Output body, response, and reason code
+#
+# NOTE : The Response object has been updated to raise an
+# ApiFatalException if the HTTP headers indicate a content type of json,
+# but the response body fails to parse with json.loads.
+# This negates the need for 'determine' to check for a malformed body
+# with a subsequent return code of '2'.
+#########################################################################
+
+def determine(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code and reason == reason_code :
+        return(0)
+    else :
+        return(1)
+    
+# added by lv start
+def determine_with_raise_exception(response, status_code, reason_code) :
+
+    status = response.status
+    if 'http-status' in response.body :
+        status = response.body[ 'http-status' ]
+    reason = None
+    if 'reason' in response.body :
+        reason = response.body[ 'reason' ]
+    if status == status_code :
+        if reason == reason_code :
+            return (0)
+        else: 
+            raise ApiException('expected reason code' + str(reason_code) + ' not seen')
+    else :
+        raise ApiException('expected status code' + str(status_code) + ' not seen')
+# added by lv end
+
+
+#########################################################################
+# Get the current time, formatted
+#########################################################################
+def get_time_stamp() :
+    return time.strftime("%Y%m%d %H:%M:%S %z", time.localtime())
+# end get_time_stamp
+
+
+#########################################################################
+# Get the fully-qualified filename of the current testcase
+#########################################################################
+
+def get_testcase_full_filename ():
+    return sys.argv[0]
+
+
+#########################################################################
+# Get the testcase ID for the current testcase, based on its filename,
+# or for a specified filename.
+# The expected format for testcase filenames is
+#           <comp>_<id>.py
+# where <comp> is the component (e.g., svm, vsm, lpar) and <id> is the
+# testcase ID number.  For example, vsm_3588.py
+#########################################################################
+
+def get_testcase_id (filename=None):
+    name = get_testcase_full_filename() if filename == None else filename
+    basename = os.path.basename(name)  # Just the filename, no path
+    (name, ext) = os.path.splitext(basename)  # Separate name from extension (e..g, svm_3588)
+    parts = string.split(name, '_')  # Split at underscore (e.g., 'svm', '3588')
+    id = parts[len(parts) - 1]  # ID is the last one of the parts
+    return id
+
+
+
+
+def get_files_from_se(remote_files, local_zip_file):
+    return
+# Get the name of the user's notification topic for a specified topic type
+#
+# Inputs:
+# - requested_topic_type: the type of topic to find.  Must be a valid topic type as
+#                         returned by the Get Notification Topics operation:
+#                         'object', 'job', 'audit' or 'security'.
+#
+# Returns: the name of the topic, or None if there is no such topic for the user (e.g.,
+#          the user is not authorized to connect to it).
+#
+# Any failure is reported via an exception
+def get_notification_topic(session, requested_topic_type):
+    """Get the name of the user's notification topic for the specified topic type"""
+
+    # Make sure the targetted HMC supports the request required to fetch the notification topics
+    if not is_api_version_at_least(session, TC_API_VERSION_ZSPHINX_GA1):
+        raise ApiFatalException('The targetted HMC (effective version %s) does not support audit or security notifications; must be version %s or later' % (api_effective_version(session), TC_API_VERSION_ZSPHINX_GA1))
+
+    valid_topic_types = ['object', 'job', 'audit', 'security']
+    if requested_topic_type not in valid_topic_types:
+        raise ApiException("get_notification_topic(): Invalid topic type: " + requested_topic_type)
+    true_topic_type = requested_topic_type + "-notification"  # The name returned by Get Notification Topics
+
+    # Issue a Get Notification Topics request to get all of the user's authorized topics
+    uri = "/api/sessions/operations/get-notification-topics"
+    response = session.get(uri)
+    if response.status != 200:
+        raise ApiException("Get Notification Topics operation failed", response)
+    topics = response.body['topics']
+
+    if len(topics) == 0:  # No topics!  Should never happen, per the doc
+        print 'User is not authorized for any notification topics - this should never happen!'
+        return None
+
+    # Iterate over the user's authorized topics looking for the specified one
+    for topic in topics:
+        topic_type = topic['topic-type']
+        topic_name = topic['topic-name']
+#       print 'Topic type: %s, topic_name: %s' % (topic_type, topic_name)
+        if topic_type == true_topic_type:  # Found it
+            return topic_name
+
+    # Not found
+    return None
+
+
+# Issue the provided request and return the response along with a string containing 
+# the formatted request and response.  This formatted version is suitable for inclusion
+# in the HMC Web Services API external customer publication.  It contains:
+# - the caption text for the request example
+# - the HTTP method and full request URI
+# - certain request headers
+# - the request body, if any, alphabetized, nicely formatted and indented
+# - the caption text for the response example
+# - the HTTP status code and its meaning (e.g., "201 (Created)")
+# - certain response headers
+# - the response body, if any, alphabetized, nicely formatted and indented
+#
+# The operation_name should be the full name by which the operation is known in the external book
+# The URI may contain query parms.  This is handy for limiting the size of the response body
+# for List <class> operations.  It is OK to publish these, but not necessary.
+# The request_body is a dictionary (and is optional).
+def capture_example_for_book(session, operation_name, uri, method="get", request_body=None):
+    indent_amount = 3
+    request_headers_to_publish_get = [WSA_HEADER_RQ_SESSION]
+    request_headers_to_publish_post = [WSA_HEADER_RQ_SESSION,
+                                       WSA_HEADER_CONTENT_TYPE,
+                                       WSA_HEADER_CONTENT_LENGTH]
+    request_headers_to_publish_delete = [WSA_HEADER_RQ_SESSION]
+    response_headers_to_publish = [WSA_HEADER_RESP_SERVER,
+                                   WSA_HEADER_RESP_TRANSFER_ENCODING,  # "chunked" is of interest
+                                   WSA_HEADER_RESP_LOCATION,
+                                   WSA_HEADER_RESP_CACHE_CONTROL,
+                                   WSA_HEADER_RESP_DATE,
+                                   WSA_HEADER_CONTENT_TYPE,
+                                   WSA_HEADER_CONTENT_LENGTH]
+
+    if method == 'get':
+        request_headers_to_publish = request_headers_to_publish_get
+        response = session.get(uri)
+    elif method == 'post':
+        request_headers_to_publish = request_headers_to_publish_post
+        response = session.post(uri, json.dumps(request_body))
+    elif method == 'delete':
+        request_headers_to_publish = request_headers_to_publish_delete
+        response = session.delete(uri)
+
+    request_headers = response.request.headers
+    response_headers = response.headers
+
+    # First format the request URI, filtered headers and body
+    formatted_request_response = "\n\n%s: Request\n\n" % operation_name
+    formatted_request_response += "\n%s %s %s" % (method.upper(), uri, "HTTP/1.1")
+
+    for header_name in request_headers_to_publish:
+        formatted_request_response += "\n%s: %s" % (header_name, request_headers[header_name])
+
+    if request_body != None:
+        formatted_request_body = json.dumps(request_body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+        formatted_request_response += "\n" + formatted_request_body
+
+    #------- end request, begin response --------
+    # Noe format the filtered response headers and the response body
+    formatted_request_response += "\n\n%s\n\n%s: Response\n\n" % (20 * '-', operation_name)
+    formatted_request_response += "\n%s %s" % (response.status, response.reason)
+
+    for header_name in response_headers_to_publish:
+        if header_name in response_headers.keys():
+            formatted_request_response += "\n%s: %s" % (header_name, response_headers[header_name])
+
+    if response.status == 204 or response.body == None:
+        formatted_response_body = "\n<No response body>"
+    else:  # There is a response body; make it look pretty
+        formatted_response_body = json.dumps(response.body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
+    formatted_request_response += "\n" + formatted_response_body
+
+    # Formatting is complete
+
+#   # Make sure the request succeeded; assume any 2xx indicates success
+#   if response.status < 200 or response.status > 299:
+#       print_response(response)
+#       raise ApiException("The request appears to have failed.  URI '%s' returned HTTP status code %d (%s)" % (uri, response.status, response.reason))
+
+    # Return the complete Response object and the formatted request/response string
+    return response, formatted_request_response
+
+
+#########################################################################
+#                  "Temporary object" support
+#########################################################################
+
+# Add a temporary object to the registry.  All objects in the registry will
+# be deleted by default when the session is shutdown.  The object must be
+# of a type that is supported by the "temporary object" support.
+# See the temporary_object_types_deletion_order and temporary_object_types_info
+# constants in wsaconst.py.
+def register_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        if is_supported_temporary_object_type(temporary_object_uri):
+            wsaglobals.global_temporary_objects_list.append(temporary_object_uri)
+        else:
+            raise ApiFatalException('URI "%s" does not designate an object of a type that is supported by the "temporary object" support in wsautils' % temporary_object_uri)
+
+
+# Remove a temporary object from the registry
+def deregister_temporary_object(temporary_object_uri):
+    if temporary_object_uri is not None:
+        wsaglobals.global_temporary_objects_list.remove(temporary_object_uri)
+
+
+# Gets a copy of the list of all registered temporary objects.
+# Use register_temporary_object() and deregister_temporary_object()
+# to update this list if needed.
+def get_temporary_objects_list():
+    return list(wsaglobals.global_temporary_objects_list)  # Return a copy
+
+
+# Determine if the specified URI designates an object of a type that is supported
+# by the "temporary object" support.
+def is_supported_temporary_object_type(uri):
+    if uri is None or not isinstance(uri, types.StringTypes):  # Not a string (likely to be a Response object from a failed request...)
+        return False
+    
+    for info_entry in temporary_object_types_info.values():
+        uri_prefix = info_entry[KEY_URI_PREFIX]
+        if uri.startswith(uri_prefix):  # It's a supported type
+            return True
+    return False
+
+
+# Delete all temporary objects in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_objects():
+    temporary_objects_list = get_temporary_objects_list()  # Get a copy to iterate over; the real list gets updated
+    if temporary_objects_list is not None and len(temporary_objects_list) > 0:  # There are temporary objects to be deleted
+        print '\nTemporary objects to delete: %d' % len(temporary_objects_list)
+
+        # Iterate over all supported object types and delete all instances of each type,
+        # then move on to the next type
+        for object_type in temporary_object_types_deletion_order:  # Go in a certain order, since it sometimes matters
+            info_entry = temporary_object_types_info[object_type]  # Get handling info about the current object type
+            uri_prefix = info_entry[KEY_URI_PREFIX]
+#           print 'Looking for temporary objects with a URI prefix of "%s"' % uri_prefix
+            
+            # Iterate over all temporary objects in the registry, searching for those
+            # of the type we're currently handling.  Delete each as it is found and 
+            # remove it from the registry.
+            for uri in temporary_objects_list:
+                if uri is not None and uri.startswith(uri_prefix):  # Its type matches the type we're handling now
+                    try:
+                        admin_user = info_entry[KEY_ADMIN_USERID]
+
+                        admin_session = get_admin_session(admin_user)
+
+                        print 'Using %s to delete temporary object: %s' % (admin_user, uri)
+                        response = admin_session.delete(uri)
+                        if response.status != 204:
+                            print '\nError deleting temporary object: %s\n%s' % (uri, response)
+
+                        deregister_temporary_object(uri)  # Remove it from the list of temporary objects, since we've deleted it
+#                       print 'There are %d temporary objects left to delete' % len(wsaglobals.global_temporary_objects_list)
+                    except:
+                        print 'Caught exception!!'
+                        traceback.print_exc()
+                        print 'Continuing with any remaining temporary objects...'
+        print
+
+    # Get a current copy of the list; check to see if it's empty (it should be)
+    temporary_objects_list = get_temporary_objects_list()
+    if len(temporary_objects_list) > 0:  # Hmmmm, must have had an error trying to delete something; tell the user
+        print '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
+        print 'Not all temporary objects were deleted.  There are still %d temporary objects in the registry.' % len(temporary_objects_list)
+        print '\n%s\n' % temporary_objects_list
+        print '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n'
+
+
+# Get a Session authenticated as the specified userid.  This method is intended for use when
+# a priviledged (admin-type) user is required for performing scenario setup in the beginning
+# of a testcase (e.g., creating objects, setting properties)and at the end when that setup is
+# being undone (e.g., deleting temporary objects, resetting properties back to original values).
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase
+# exit.  There are constants for the standard system-defined  userids (e.g., 
+# ACCCES_ADMINISTRATOR, ENSEMBLE_ADMINISTRATOR) in wsaconst.py.
+def get_admin_session(admin_userid):
+    if admin_userid in wsaglobals.global_admin_sessions:
+        admin_session = wsaglobals.global_admin_sessions[admin_userid]
+#       print 'fetched cached session: %s' % admin_session
+    else:
+        admin_session = session_startup(user=admin_userid, additional_options=wsaglobals.global_saved_additional_options)
+        wsaglobals.global_admin_sessions.update({admin_userid : admin_session})
+#       print 'created and cached new session: %s' % admin_session
+
+#   print 'There are %d admin sessions' % len(wsaglobals.global_admin_sessions)
+#   print 'Returning admin session for admin user %s: %s' % (admin_userid, admin_session)
+    return admin_session
+
+
+# Get a Session object authenticated as the system-defined user that is appropriate for performing
+# administrative operations relative to the specified URI.  If no specific administrator has been
+# identified in the uri_admin_info map, then a session authenticated as PEDEBUG is returned.
+# These sessions are cached and can be reused.  They are cleaned up automatically during testcase exit.
+def get_admin_session_for_uri(uri):
+    admin_session = None
+    # See if the specified URI has an associated administrator userid
+    for uri_prefix in uri_admin_info:
+        if uri.startswith(uri_prefix):
+            admin_session = get_admin_session(uri_admin_info[uri_prefix])
+    if admin_session == None:
+        admin_session = get_admin_session(PEDEBUG)
+    return admin_session
+
+
+# Delete all (cached) admin sessions created by get_admin_session().
+# This method is intended to be called during session shutdown immediately before testcase exit.
+def delete_all_admin_sessions():
+    admin_sessions = dict(wsaglobals.global_admin_sessions)  # Make a copy to iterate over; the real list gets updated
+    if admin_sessions is not None and len(admin_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nAdmin sessions to shutdown: %d' % len(admin_sessions)
+        for admin_user_name in admin_sessions.keys():
+            try:
+                admin_session = admin_sessions[admin_user_name]
+                print 'Shutting down session for admin user: %s' % admin_user_name
+                # Shutdown this admin session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(admin_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)  # Delete just the session, and nothing else
+                del wsaglobals.global_admin_sessions[admin_user_name]  # Remove it from the list of admin sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining admin sessions...'
+
+#   print 'There are now %d admin sessions' % len(wsaglobals.global_admin_sessions)
+
+
+# Delete all temporary sessions in the registry.  This method is intended to be
+# called during session shutdown immediately before testcase exit.
+def delete_all_temporary_sessions():
+    temporary_sessions = get_temporary_sessions()  # Make a copy to iterate over; the real list gets updated
+    if temporary_sessions is not None and len(temporary_sessions) > 0:  # There are admin sessions to be deleted
+        print '\nTemporary sessions to shutdown: %d' % len(temporary_sessions)
+        for temporary_session in temporary_sessions:
+            try:
+                print 'Shutting down temporary session for user: %s' % temporary_session.userid()
+                # Shutdown this temporary session.  Specify options on the session_shutdown() call so that
+                # it only deletes this session and nothing else, because we don't want to interfere with
+                # the very deliberate order in which the various objects and sessions are cleaned up.
+                session_shutdown(temporary_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)
+                wsaglobals.global_temporary_sessions.remove(temporary_session)  # Remove it from the list of temporary sessions
+            except:
+                print 'Caught exception!!'
+                traceback.print_exc()
+                print 'Continuing with any remaining temporary sessions...'
+
+
+
+# Gets a copy of the list of all registered temporary sessions.
+def get_temporary_sessions():
+    return list(wsaglobals.global_temporary_sessions)  # Return a copy
+
+def start_receiving_messages(session):
+    session.start_receiving_messages()
+    
+def stop_receiving_messages(session):
+    session.stop_receiving_messages()
+    msgs = session.get_received_messages()
+    print msgs
+    return msgs
+
+def create_python_list(item):
+    return [item]
+
+def create_python_dict(prop, value):
+    return {prop:value}
+
+"""
+Generic function that finds an object of type ObjectType by its attribute.    
+The function looks for a objectToFind which is a string type by it's attribute.
+Params: Field Name refers to properties like name, status etc
+        objectType refers to objects like cpcs, groups, members etc
+        FielddNameValue is the string that is searched for in the listOfDictionaries 
+"""
+def verify_object_in_list_by_attribute(listOfDictionaries, fieldNameValue, objectType, fieldName):
+    verifyIn = False
+    for myObject in listOfDictionaries.body[objectType]:
+        if myObject[fieldName] == fieldNameValue:
+            verifyIn = True
+            break
+    return verifyIn
+
+def get_partition_list(session, cpc):
+    response = session.get(cpc, '/partitions')
+    for partition in response.body['partitions']:
+        print partition['name']
+    return response.body['partitions']
+    
diff --git a/partitionengine/utils/wsautils.pyc b/partitionengine/utils/wsautils.pyc
new file mode 100644
index 0000000..a2c94f4
Binary files /dev/null and b/partitionengine/utils/wsautils.pyc differ
diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..06bd71b
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,27 @@
+# -*- coding: utf-8 -*-
+
+from setuptools import setup, find_packages, Extension
+#from disutils.core import Extension
+
+
+with open('README.md') as f:
+    readme = f.read()
+
+
+setup(
+    name='partitionengine',
+    version='0.0.1',
+    description='Package for Export Import Template Engine',
+    long_description=readme,
+    author='Preethi PY',
+    author_email='preethi.py@gmail.com',
+    packages=find_packages(exclude=('tests', 'docs')),
+    #ext_modules=[Extension('log', ['partitionengine/logs/console.log'])],
+    platforms=['any'],
+    entry_points={
+              'console_scripts': [
+                  'partitionengine = partitionengine.Console:main',                  
+              ],              
+          },
+)
+
diff --git a/src/Console.py b/src/Console.py
deleted file mode 100755
index 912aeca..0000000
--- a/src/Console.py
+++ /dev/null
@@ -1,322 +0,0 @@
-from getpass import *
-
-#from babel.messages.catalog import Catalog
-
-from CreateTemplate import *
-from CreateTemplatePartition import *
-from utils.wsautils import *
-import ConfigParser
-
-
-session = None
-
-
-CONFIG_FILE=".saved-settings"
-config = ConfigParser.RawConfigParser()
-
-
-def print_helper(print_string=None, operationFailed=False, exception=None):
-    string_out = ''
-    if (operationFailed):
-        string_out += ("\n" + "*"*100)
-        string_out += ("\n**********************************Operation Failed**************************************************")
-        
-    else:
-        string_out += ("\n" + "*"*100)
-    string_out += ("\n" + print_string)
-    string_out += ("\n" + "*"*100)
-    print string_out
-    logging.debug(string_out)
-    if not (exception == None):
-        logging.debug("Failure Reason:")
-        logging.debug(exception)
-        exc_type, exc_value, exc_traceback = sys.exc_info()
-        traceback_details = {
-                         'filename': exc_traceback.tb_frame.f_code.co_filename,
-                         'lineno'  : exc_traceback.tb_lineno,
-                         'name'    : exc_traceback.tb_frame.f_code.co_name,
-                         'type'    : exc_type.__name__,
-                         'message' : exc_value.message, # or see traceback._some_str()
-                        }
-        del(exc_type, exc_value, exc_traceback)
-        logging.debug(traceback.format_exc())
-        
-    return
-        
-
-
-
-
-
-finalSelectedOption = 0
-def option_choser(queryString='Choose from Index',option_title='', indexLength=0,chosenOption = 0):
-    logging.info('option_choser method invoked') 
-    if chosenOption < 1 or chosenOption > indexLength:
-        try:
-            chosenOption = int(user_input('\n'+queryString, 'OPTIONS', option_title))#raw_input('\n' + queryString.ljust(30) + ':'))         
-        except:
-            print("Invalid Value!!! ")
-        option_choser(queryString,option_title,indexLength,chosenOption)
-    else:
-        global finalSelectedOption
-        finalSelectedOption = chosenOption   
-    logging.debug("chosen option: " + str(chosenOption))
-    return finalSelectedOption
-
-def createPartitionIteratively(temp_name='', no_of_partitions=0, cpc_uri=''):
-    logging.info('-> createPartitionIteratively for the templatename ' + temp_name + " number of Partitions: " + str(no_of_partitions) + " CPC URI: " + cpc_uri)
-    partionList=dict();
-    for num in range(0, no_of_partitions):
-        print_helper("Creating Partition " + str(num+1), False)
-        try:
-            partition_unique_name,part_uri=createTemplatePartition(temp_name, session, cpc_uri, ''.join(random.choice(string.ascii_uppercase + string.digits) for num in range(4)))
-        except Exception as ex:
-            print_helper('Partition Creation failed while creating partition number' + num , True, str(ex))
-        except:
-            print_helper('Partition Creation failed while creating partition number' + num , True, str(sys.exc_info()[:2]))
-        #partionList[partition_unique_name] = part_uri
-    logging.info('<- createPartitionIteratively')
-    return partionList
-
-def createPartitionFromTemplate(cpc_name='', cpc_uri=''):
-    logging.info('->createPartitionFromTemplate')
-    partitionStatus=''
-    try:
-        template_dir_name = os.path.join(os.path.dirname(os.path.abspath(__file__)) , 'templates/cpc_' + cpc_name);
-        logging.debug(template_dir_name)
-        if not(os.path.isdir(template_dir_name)):
-            print_helper("No Template File exists")
-            return
-        template_files = os.listdir(template_dir_name)
-        logging.debug('template_files ' + str(template_files))
-        
-        print("\nChoose one of the below Templates:\n")
-        
-        for index in range(0, len(template_files)):
-            print index + 1, '. '.ljust(10), os.path.splitext(template_files[index])[0]
-        selected_template = option_choser("Select a template available to create partition:","TEMPLATE" ,len(template_files))
-        
-        temp_name = template_files[selected_template - 1]
-        logging.debug("Selected Template..." + temp_name)
-        
-        no_of_partitions = option_choser('Enter the number of partitions to be created ',"PARTITIONCOUNT", 100)
-        logging.debug('no_of_partitions' + str(no_of_partitions))
-        
-        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/cpc_' + cpc_name, temp_name)
-        logging.debug('template_name ' + template_name)
-        
-        if not(os.path.isfile(template_name)):
-            raise IOError("File not found: " + template_name)
-        partitionList=createPartitionIteratively(template_name, no_of_partitions, cpc_uri)
-        partitionStatus = 'Partition Created Successfully from template\n'
-        for part in partitionList.keys():
-        
-            partitionStatus+= 'Partition Name: '+part+'\n'
-            partitionStatus+= 'Partition URI: ' +partitionList[part]+'\n'
-    except:
-        print_helper('Partition Creation failed to create from given Template', True, str(sys.exc_info()[:2]))
-    logging.info('<-createPartitionFromTemplate')    
-    
-    print_helper(partitionStatus, False)
-    
-    print_helper("Process Completed", False)    
-    return
-
-def createPartitionFromPartition(cpc_name='', cpc_uri=''):
-    logging.info('->createPartitionFromPartition')
-    try:
-        part = session.get(cpc_uri + '/partitions')
-        partitions = part.body['partitions']
-        for  index in range(0, len(partitions)):
-            print index + 1, '  ', partitions[index]['name']
-        partition_option = option_choser('Select partition by index','PARTITION_INDEX', len(partitions))
-        
-        partition_name = partitions[partition_option - 1]['name']
-        no_of_partitions = option_choser('Enter the number of partitions to be created ','NUMPARTS', 100)
-        logging.debug('no_of_partitions' + str(no_of_partitions))
-        
-        p = progress_bar_loading()
-        p.configure("Fetching Partition Inventory...")
-        p.start() 
-        
-        
-        
-        temp_name = createTemplate(session,[partitions[partition_option - 1]], cpc_name, partition_name)
-        logging.debug('template_name '+ temp_name)
-        
-        time.sleep(1)
-        p.stop()      
-        
-        time.sleep(2)
-        
-        if not(os.path.isfile(temp_name)):
-            raise IOError("File not found: " + temp_name)
-        
-        createPartitionIteratively(temp_name, no_of_partitions, cpc_uri)
-    except:
-        print_helper('Partition Creation failed to create from chosen partition ' + partition_name, True, str(sys.exc_info()[:2]))
-        time.sleep(1)
-        p.stop() 
-    logging.info('<-createPartitionFromPartition')
-    
-    print_helper("Successfully Completed", False)    
-    return
-
-def exportPartition(cpc_name="",cpc_uri=""):
-    logging.info('->exportPartition')
-    try:
-        part = session.get(cpc_uri + '/partitions')
-        partitions = part.body['partitions']
-        temp_name = createTemplate(session,partitions, cpc_name)
-        p = progress_bar_loading()
-        p.configure("Fetching Partition Inventory...")
-        p.start() 
-        time.sleep(1)
-        p.stop()
-        time.sleep(2)   
-        logging.debug('template_name '+ temp_name)
-        
-        if not(os.path.isfile(temp_name)):
-            raise IOError("Partition Inventory is not exported to the file " + temp_name)
-    except:
-        print_helper('Partition Export failed', True, str(sys.exc_info()[:2]))
-        time.sleep(1)
-        p.stop() 
-    logging.info('<-exportPartition')
-    
-    print_helper("Successfully Completed", False)    
-    return
-
-def importPartition(cpc_name='', cpc_uri=''):
-    logging.info('->importPartition')
-    try:
-        template_name = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates/base_' + cpc_name, 'base_template.json')
-        logging.debug('template_name '+ template_name)
-        if not(os.path.isfile(template_name)):
-            raise IOError("File not found: " + template_name)
-        createTemplatePartition(template_name, session, cpc_uri)
-    except:
-        print_helper("Sorry! There is no backup inventory for the CPC selected", True, str(sys.exc_info()[:2]))
-    logging.info('<-importPartition')
-    
-    print_helper("Successfully Completed", False)    
-    return
-
-def readConfig():
-    config.read('savedsettings.cfg')
-    return config
-
-def updateConfig(params=None):
-    with open('savedsettings.cfg', 'wb') as configfile:
-        config.write(configfile)
-    return
-
-def user_input(inputStr='',section='',parameter='', password=False):
-    config = readConfig()
-    
-    userinput=''
-    
-    try: 
-        value=config.get(section, parameter)
-    except ConfigParser.NoSectionError:
-        if not section == '':
-            config.add_section(section)
-        value = ''
-    except:
-        value = ''    
-    if password:
-        userinput=getpass(inputStr.ljust(15) + ':')        
-    else:
-        userinput=raw_input(inputStr +' ['+ value + ']'.ljust(15) + ':')
-        
-    if not userinput == '':
-        value = userinput
-       
-    if not parameter=='':
-        config.set(section,parameter,value)
-    updateConfig()
-    return value 
-
-
-
-def main():
-    initializeLogging()
-    logging.info('Starting the PartitionManagementTemplating Tool')
-    print "*"*100
-    print "Capture and replay partition creation".center(100)
-    print "*"*100   
-    
-            
-    hmc_ip = user_input('Enter HMC IP', 'BASE_PARAMS', 'HMC_IP')#raw_input('Enter HMC IP ['+ config.get('BASE_PARAMS', 'HMC_IP') + ']'.ljust(30) + ':')
-    hmc_user = user_input('Enter Username', 'BASE_PARAMS', 'HMC_USER')#raw_input('Enter Username ['+ config.get('BASE_PARAMS', 'HMC_USER') + ']'.ljust(30) + ':')
-    hmc_password = user_input('Enter Password','','',True)#('Enter Password'.ljust(30) + ':')
-    
-    #hmc_ip = '9.152.151.49'
-    #hmc_user = 'pedebug'
-    #hmc_password = 'password'
-    # print hmc_password
-    logging.debug('hmc_ip: '+hmc_ip+' hmc_user '+hmc_user+' hmc_password '+hmc_password)
-    cpcs = []
-    global session
-    try:
-        
-        p = progress_bar_loading()
-        p.configure("Establishing session")
-        p.start()     
-        session = session_startup(host=hmc_ip, user=hmc_user, pwd=hmc_password)
-        logging.debug("Printing the session details... /n"+ str(session))
-        time.sleep(2)
-        p.stop()
-        
-        p = progress_bar_loading()
-        p.configure("Fetching CPC List")
-        p.start()
-        cpcs = list_cpcs(session)
-        p.stop()        
-        time.sleep(2)
-        
-        logging.debug("Printing the cpcs... /n"+ str(cpcs))
-    except ApiFatalException as ex:
-        print_helper("Sorry! Session could not be established. Please verify the IP, HMC Username/Password", True)
-        time.sleep(1)
-        p.stop() 
-        return
-    
-    print "****************************************************************************************************"
-    if len(cpcs) > 0:        
-        print "List of CPCs available"
-    else:
-        print_helper("No CPCs managed by the HMC!!!")
-        return
-    
-    
-    for  index in range(0, len(cpcs)):
-        print index + 1, '  ', cpcs[index]['name']
-    
-    try:
-        cpc_option = option_choser("Select cpc by index from the given list",'CPCSEL', len(cpcs))
-    
-        cpc_uri = cpcs[cpc_option - 1]['object-uri']
-        cpc_name = cpcs[cpc_option - 1]['name']
-        print_helper('CPC ' + cpc_name + ' is selected')
-        print("Choose one of the below options:")
-        options = '\n1.  create n partitions from existing templates?\n2.  create a partition based on another partition?\n3.  Export Partition Inventory?\n4.  Import Partition Inventory? '
-        print options
-        selected_option = option_choser('Select an option by index','FLAVOR', 4)
-    
-    
-        if selected_option == 1:
-            createPartitionFromTemplate(cpc_name, cpc_uri)
-            
-        elif selected_option == 2:
-            createPartitionFromPartition(cpc_name, cpc_uri)
-            
-        elif selected_option == 3:
-            exportPartition(cpc_name, cpc_uri)
-            
-        if selected_option == 4:
-            importPartition(cpc_name, cpc_uri)
-    except:
-        print_helper('Process Failed ', True, str(sys.exc_info()[:2]))
-   
-main()
diff --git a/src/CreateTemplate.py b/src/CreateTemplate.py
deleted file mode 100755
index cd9c35e..0000000
--- a/src/CreateTemplate.py
+++ /dev/null
@@ -1,152 +0,0 @@
-
-import ast
-import json
-import os
-from utils.wsautils import *
-
-
-roce_nic_writable_properties = ['description','device-number','name','network-adapter-port-uri']
-vfn_writable_properties = ['description','device-number','name','adapter-uri']
-vs_nic_writable_properties = ['description','device-number','name','virtual-switch-uri']
-writable_properties = [u'ifl-processing-weight-capped', u'minimum-cp-processing-weight',  u'maximum-ifl-processing-weight', u'access-problem-state-counter-set', u'ifl-processors',  u'cp-absolute-processor-capping-value',  u'reserve-resources', u'maximum-memory', u'boot-timeout', u'boot-os-specific-parameters',  u'processor-management-enabled', u'boot-device', u'access-basic-sampling', u'cp-absolute-processor-capping',  u'boot-record-lba', u'permit-cross-partition-commands', u'acceptable-status', u'maximum-cp-processing-weight', u'minimum-ifl-processing-weight',   u'access-global-performance-data', u'cp-processing-weight-capped', u'permit-aes-key-import-functions',  u'ifl-absolute-processor-capping-value', u'initial-ifl-processing-weight', u'access-extended-counter-set',  u'initial-cp-processing-weight', u'access-crypto-activity-counter-set', u'initial-memory', u'access-basic-counter-set', u'name', u'boot-configuration-selector', u'description', u'cp-processors',  u'access-diagnostic-sampling',u'permit-des-key-import-functions', u'processor-mode',u'ifl-absolute-processor-capping', u'access-coprocessor-group-set']
-hba_writable_properties = ['description','device-number','name','adapter-port-uri']
-boot_device = {'storage-adapter':['boot-logical-unit-number','boot-world-wide-port-name','boot-storage-device'],'network-adapter':['boot-network-device'],'ftp':['boot-ftp-host','boot-ftp-insfile','boot-ftp-password','boot-ftp-username'],'iso-image':['boot-iso-image-name','boot-iso-ins-file'],'removable-media':['boot-removable-media', 'boot-removable-media-type']}
-global nic_device_uri
-global hba_device_uri
-    
-class Object:
-    def to_JSON(self):
-        return json.dumps(self, default=lambda o: o.__dict__, 
-            sort_keys=True, indent=4)
-class Payload(object):
-    def __init__(self, j):
-        self.__dict__ = json.loads(j)
-        
-        
-def getNicList(session,ob,ob1):
-    logging.info('->getNicList')
-    nic_list = []
-    global nic_device_uri
-    for nic in getattr(ob,'nic-uris'):
-        logging.debug(str(nic))
-        response = session.get(nic)
-        
-        logging.debug(str(response.body))
-        nic_ob1= Payload(json.dumps(response.body))
-        nic_ob = Object()
-        for key in nic_ob1.__dict__.keys():
-            if response.body['type'] == 'roce':
-                if key in roce_nic_writable_properties:
-                    logging.debug(str(getattr(nic_ob1,key)))
-                    setattr(nic_ob,key,getattr(nic_ob1,key))
-            else:
-                #print key
-                if key in vs_nic_writable_properties:
-                    setattr(nic_ob,key,getattr(nic_ob1,key))
-            if key == 'element-uri':
-                if getattr(ob, 'boot-device') == 'network-adapter' and getattr(nic_ob1, key) == nic_device_uri:
-                    setattr(ob1, 'nic-boot-device-number', getattr(nic_ob1, 'device-number')) 
-        nic_list.append(nic_ob)
-        
-        logging.debug(str(nic_list));
-        logging.info('<-getNicList')
-    return nic_list 
-
-def getHbaList(session,ob,ob1):
-    logging.info('->getHbaList')
-    hba_list = []
-    global hba_device_uri
-    for hba in getattr(ob,'hba-uris'):
-        response = session.get(hba)
-        hba_ob = Object()
-        hba_ob1= Payload(json.dumps(response.body))
-        for key in hba_ob1.__dict__.keys():
-            if key in hba_writable_properties:
-                setattr(hba_ob,key,getattr(hba_ob1,key))
-            if key == 'element-uri':
-                if getattr(ob, 'boot-device') == 'storage-adapter' and getattr(hba_ob1, key) == hba_device_uri:
-                    setattr(ob1, 'hba-boot-device-number', getattr(hba_ob1, 'device-number')) 
-        hba_list.append(hba_ob)
-    logging.info('<-getHbaList')
-    return hba_list 
-
-def getVfnList(session,ob):
-    logging.info('->getVfnList')
-    vfn_list = []
-    for vfn in getattr(ob,'virtual-function-uris'):
-        response = session.get(vfn)
-        vfn_ob = Object()
-        vfn_ob1= Payload(json.dumps(response.body))
-        for key in vfn_ob1.__dict__.keys():
-            if key in vfn_writable_properties:
-                setattr(vfn_ob,key,getattr(vfn_ob1,key))
-    
-        vfn_list.append(vfn_ob)
-    logging.info('<-getVfnList')
-    return vfn_list 
-
-def setBootDevice(ob,ob1):
-    logging.info('->setBootDevice')
-    global hba_device_uri
-    global nic_device_uri
-    if getattr(ob, 'boot-device') == 'storage-adapter':
-        hba_device_uri = getattr(ob, 'boot-storage-device')
-            
-    if getattr(ob, 'boot-device') == 'network-adapter':
-        nic_device_uri = getattr(ob, 'boot-network-device')
-           
-    if getattr(ob, 'boot-device') in boot_device.keys():
-        for boot_property in boot_device[getattr(ob, 'boot-device')]:
-            setattr(ob1,boot_property,getattr(ob, boot_property))
-    logging.info('<-setBootDevice')
-    return
-                
-def getPartitionTemplate(session,inv_response,partition_list):
-    logging.info('Retriving the partition info and loading into template....')
-    logging.info('->getPartitionTemplate')
-    ob1 = Object()
-    ob = Payload(json.dumps(inv_response))
-    for key in ob.__dict__.keys():
-        if key in writable_properties:
-            setattr(ob1,key,getattr(ob,key))
-        if key == 'crypto-configuration':
-            setattr(ob1,'cryptos',getattr(ob,key))
-    setBootDevice(ob, ob1)
-    nic_list = getNicList(session,ob,ob1)
-    hba_list = getHbaList(session, ob,ob1)
-    vfn_list = getVfnList(session, ob)
-    setattr(ob1,'nics',nic_list)
-    setattr(ob1,'virtual-functions',vfn_list)
-    setattr(ob1,'hbas',hba_list)
-    partition_list.append(ob1)
-    logging.info('<-getPartitionTemplate')
-    return partition_list
-        
-def createTemplate(session,inv_response,cpc_name,partition_name = None):
-    logging.info('->createTemplate')
-    logging.debug(str(inv_response))
-    partition_list = []
-    complete = Object()
-    for partition in inv_response:
-            response = session.get(partition['object-uri'])
-            complete = Object()
-            partition_list = getPartitionTemplate(session, response.body, partition_list) 
-            
-    setattr(complete,'partition',partition_list)  
-    if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates'):
-        os.mkdir(os.path.dirname(os.path.abspath(__file__))+'/templates')
-    if partition_name == None:
-        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/base_'+cpc_name):
-            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name))
-        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/base_'+cpc_name,'base_template.json')
-    else:
-        if not os.path.exists(os.path.dirname(os.path.abspath(__file__))+'/templates/cpc_'+cpc_name):
-            os.mkdir(os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name))
-        file_name = os.path.join(os.path.dirname(os.path.abspath(__file__)),'templates/cpc_'+cpc_name,partition_name+'_template.json')
-    file = open(file_name,'w+')        
-    file.write(complete.to_JSON())
-    file.close()
-    logging.info('template created successfully...')
-    logging.info('<-createTemplate')
-    
-    return file_name
diff --git a/src/CreateTemplatePartition.py b/src/CreateTemplatePartition.py
deleted file mode 100755
index 5e06d02..0000000
--- a/src/CreateTemplatePartition.py
+++ /dev/null
@@ -1,147 +0,0 @@
-
-import ast
-import json
-import random
-
-from utils.wsautils import *
-
-import sys
-import time
-import threading
-
-
-
-
-
-def remove(body,keys_list):
-    for key in keys_list:
-        if key in body.keys():
-            del body[key]
-
-def createTemplatePartition(temp_filename,session,cpc,partition_unique_name=None):
-    logging.info('==>>################# createTemplatePartition invoked#################')
-    logging.debug('Template file name: '+ temp_filename)
-    logging.debug('cpc uri: '+ cpc)
-    logging.debug('Partition unique name: '+ str(partition_unique_name))
-    temp_file = open(temp_filename,'r')
-    json_text = temp_file.read()
-    ip = json.loads((json_text))
-    ip_body = ip['partition']
-    p = progress_bar_loading()
-    try:
-        for partition in ip_body:
-            body = {'processor-mode':partition['processor-mode'], 'initial-memory':partition['initial-memory'],'maximum-memory':partition['maximum-memory']}
-            if partition_unique_name != None:
-                body.update({'name':partition['name']+'_'+str(partition_unique_name)})
-            else:
-                body.update({'name':partition['name']})
-            if partition['cp-processors'] != 0:
-                body.update({'cp-processors':partition['cp-processors']})
-            else:
-                body.update({'ifl-processors':partition['ifl-processors']})
-                
-            p = progress_bar_loading()
-            p.configure("Creating Partition")
-            p.start()
-            response = session.post(cpc+'/partitions',json.dumps(body))
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-            logging.debug("Respose from partitions Post request" + str(response)) 
-            
-            
-            part_uri = response.body['object-uri']
-            logging.debug("Partition URI from newly created partition" + part_uri)
-            
-            
-            p = progress_bar_loading()
-            p.configure("Creating VNics")
-            p.start()   
-            for nic in partition['nics']:
-                logging.info("Iterating through nic URIS")            
-                response = session.post(part_uri+'/nics',json.dumps(nic))            
-                logging.debug("Respose from nics Post request" + str(response)) 
-                
-                if (partition['boot-device'] == 'network-adapter') and (nic['device-number'] == partition['nic-boot-device-number']) :            
-                    nicRes = response.body['element-uri']
-                    partition['boot-network-device'] = nicRes
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-             
-             
-            p = progress_bar_loading()
-            p.configure("Creating HBAs")
-            p.start()       
-            for hba in partition['hbas']:
-                logging.info("Iterating through hba URIS")
-                
-                response = session.post(part_uri+'/hbas',json.dumps(hba))
-                
-                logging.debug("Respose from hbas Post request" + str(response)) 
-                
-                if (partition['boot-device'] == 'storage-adapter') and (hba['device-number'] == partition['hba-boot-device-number']) :            
-                    hbaRes = response.body['element-uri']
-                    partition['boot-storage-device'] = hbaRes
-                 
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-                
-            
-            p = progress_bar_loading()
-            p.configure("Creating VirtualFunctions")
-            p.start()       
-            for vfn in partition['virtual-functions']:
-                logging.info("Iterating through virtual-functions URIS")
-                
-                response = session.post(part_uri+'/virtual-functions',json.dumps(vfn))
-                
-                
-                logging.debug("Respose from virtual-functions Post request" + str(response))
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-            
-            p = progress_bar_loading()
-            p.configure("Configuring Cryptos")
-            p.start()
-            if partition['cryptos'] != None:
-                logging.info("Adding crypto configurations")
-                
-                response = session.post(part_uri+'/operations/increase-crypto-configuration',json.dumps(partition['cryptos']))
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-                
-            remove(partition,['nics','hbas','virtual-functions','name','hba-boot-device-number','nic-boot-device-number','cryptos'])
-            logging.debug("Removed unwanted attributes")
-            
-            p = progress_bar_loading()
-            p.configure("\nUpdating Partition Properties")        
-            p.start()
-            response = session.post(part_uri,json.dumps(partition))        
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-            logging.debug("Response from Update Partition request"+ str(response))
-            
-            
-            p = progress_bar_loading()
-            p.configure("Retrieve and Verify Partition Properties")        
-            p.start()
-            response = session.get(part_uri)            
-            time.sleep(1)
-            p.stop()
-            time.sleep(2)
-            
-            if(response.status == 200):
-                sys.stdout.write("Partition: " + response.body['name']+" Created Successfully" )
-            logging.debug("Partition Properties"+ str(response))
-    except:
-        time.sleep(1)
-        p.stop()
-        raise
-        
-    logging.info('<<=########## createTemplatePartition invoked#########')
-    return partition_unique_name,part_uri
\ No newline at end of file
diff --git a/src/delete_all.py b/src/delete_all.py
deleted file mode 100755
index 74fda68..0000000
--- a/src/delete_all.py
+++ /dev/null
@@ -1,14 +0,0 @@
-'''
-Created on Apr 13, 2016
-
-@author: sowmya
-'''
-from utils.wsautils import *
-
-session= session_startup(host='9.12.38.77')
-cpc_uri = list_cpcs(session)[0]['object-uri']
-part = session.get(cpc_uri+'/partitions')
-print part
-
-for partition in part.body['partitions']:
-    print session.delete(partition['object-uri'])
diff --git a/src/logs/console.log b/src/logs/console.log
deleted file mode 100644
index f996a14..0000000
--- a/src/logs/console.log
+++ /dev/null
@@ -1 +0,0 @@
-Tue, 13 Sep 2016 11:28:24 INFO     Starting the PartitionManagementTemplating Tool
diff --git a/src/savedsettings.cfg b/src/savedsettings.cfg
deleted file mode 100755
index bbd0004..0000000
--- a/src/savedsettings.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-[BASE_PARAMS]
-hmc_ip = 9.152.151.49
-hmc_user = pedebug
-
-[OPTIONS]
-cpcsel = 1
-flavor = 4
-partition_index = 1
-numparts = 1
-
diff --git a/src/templates/base_ANIL2SE/base_template.json b/src/templates/base_ANIL2SE/base_template.json
deleted file mode 100755
index a735671..0000000
--- a/src/templates/base_ANIL2SE/base_template.json
+++ /dev/null
@@ -1,178 +0,0 @@
-{
-    "partition": [        
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_BAWC", 
-            "nics": [
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }, 
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF", 
-            "nics": [
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
diff --git a/src/templates/base_P000S67B/base_template.json b/src/templates/base_P000S67B/base_template.json
deleted file mode 100755
index 908db2f..0000000
--- a/src/templates/base_P000S67B/base_template.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "test-operating-system", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": 1.0, 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 1, 
-            "cryptos": null, 
-            "description": "", 
-            "hbas": [], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": 1.0, 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "test", 
-            "nics": [], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": []
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/CPC_2_20423_template.json b/src/templates/cpc_ANIL2SE/CPC_2_20423_template.json
deleted file mode 100755
index 221f17f..0000000
--- a/src/templates/cpc_ANIL2SE/CPC_2_20423_template.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": null, 
-            "description": "", 
-            "hbas": [], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 1024, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 1024, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "CPC_2_20423", 
-            "nics": [], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": []
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json b/src/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json
deleted file mode 100755
index fcb0939..0000000
--- a/src/templates/cpc_ANIL2SE/CPC_2_20423_template_LXSD_template.json
+++ /dev/null
@@ -1,50 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": null, 
-            "description": "", 
-            "hbas": [], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 1024, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 1024, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "CPC_2_20423_template_LXSD", 
-            "nics": [], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": []
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template.json
deleted file mode 100755
index cd2aed4..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template.json
+++ /dev/null
@@ -1,91 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition", 
-            "nics": [
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json
deleted file mode 100755
index 4c0a25d..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_AMUO_template.json
+++ /dev/null
@@ -1,93 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "network-adapter", 
-            "boot-network-device": "/api/partitions/e47b85a8-0205-11e6-9e8f-02c20001b57e/nics/e7d94c76-0205-11e6-9e8f-02c20001b57e", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF_AMUO", 
-            "nic-boot-device-number": "0004", 
-            "nics": [
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json
deleted file mode 100755
index 22ebf1f..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_RWB9_template.json
+++ /dev/null
@@ -1,93 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "network-adapter", 
-            "boot-network-device": "/api/partitions/1121c1e2-0203-11e6-ac1a-02c20001b57e/nics/1463ace4-0203-11e6-9e8f-02c20001b57e", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF_RWB9", 
-            "nic-boot-device-number": "0004", 
-            "nics": [
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json
deleted file mode 100755
index 41ce228..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template.json
+++ /dev/null
@@ -1,93 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "network-adapter", 
-            "boot-network-device": "/api/partitions/6ea4993e-019f-11e6-84a8-02c20001b57e/nics/730be194-019f-11e6-84a8-02c20001b57e", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF", 
-            "nic-boot-device-number": "0004", 
-            "nics": [
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json
deleted file mode 100755
index 102c2fe..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template.json
+++ /dev/null
@@ -1,95 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "storage-adapter", 
-            "boot-logical-unit-number": "1111122331232324", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "", 
-            "boot-storage-device": "/api/partitions/c5146d8a-01f4-11e6-9e8f-02c20001b57e/hbas/cf1b1aa4-01f4-11e6-b9cd-02c20001b57e", 
-            "boot-timeout": 60, 
-            "boot-world-wide-port-name": "1111111111123422", 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hba-boot-device-number": "0007", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF_template_C99M", 
-            "nics": [
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json b/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json
deleted file mode 100755
index ce2533e..0000000
--- a/src/templates/cpc_ANIL2SE/TestPartition_template_FPUF_template_C99M_template_NAVY_template.json
+++ /dev/null
@@ -1,95 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "storage-adapter", 
-            "boot-logical-unit-number": "1111122331232324", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "", 
-            "boot-storage-device": "/api/partitions/4aeb3330-01f5-11e6-ac1a-02c20001b57e/hbas/54a1fcba-01f5-11e6-ac1a-02c20001b57e", 
-            "boot-timeout": 60, 
-            "boot-world-wide-port-name": "1111111111123422", 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 3, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/daf1a66e-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 0
-                    }, 
-                    {
-                        "access-mode": "control", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hba-boot-device-number": "0007", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/dcd03d74-f893-11e5-84a2-02c20001b57e/storage-ports/0", 
-                    "description": "for testing storage adapter", 
-                    "device-number": "0007", 
-                    "name": "TestHBA"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "TestPartition_template_FPUF_template_C99M_template_NAVY", 
-            "nics": [
-                {
-                    "description": "for testing nic", 
-                    "device-number": "0001", 
-                    "name": "TestNIC", 
-                    "virtual-switch-uri": "/api/virtual-switches/e245f4b0-f893-11e5-a44e-02c20001b57e"
-                }, 
-                {
-                    "description": "", 
-                    "device-number": "0004", 
-                    "name": "TestNIC3", 
-                    "virtual-switch-uri": "/api/virtual-switches/d59baaca-f893-11e5-a44e-02c20001b57e"
-                }
-            ], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": [
-                {
-                    "adapter-uri": "/api/adapters/ddad059c-f893-11e5-84a2-02c20001b57e", 
-                    "description": "for testing virtual function", 
-                    "device-number": "0002", 
-                    "name": "TestVirtualFunction"
-                }
-            ]
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json b/src/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json
deleted file mode 100755
index 9044ba9..0000000
--- a/src/templates/cpc_ANIL2SE/VSM_2_20478_1_template.json
+++ /dev/null
@@ -1,60 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 0, 
-            "boot-device": "none", 
-            "boot-os-specific-parameters": "", 
-            "boot-record-lba": "0", 
-            "boot-timeout": 60, 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 1, 
-            "cryptos": {
-                "crypto-adapter-uris": [
-                    "/api/adapters/df3a888a-f893-11e5-84a2-02c20001b57e"
-                ], 
-                "crypto-domain-configurations": [
-                    {
-                        "access-mode": "control-usage", 
-                        "domain-index": 1
-                    }
-                ]
-            }, 
-            "description": "", 
-            "hbas": [], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 1024, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 2048, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "VSM_2_20478_1", 
-            "nics": [], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": []
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/templates/cpc_P000S67B/HariTest1_template.json b/src/templates/cpc_P000S67B/HariTest1_template.json
deleted file mode 100755
index 7cbf550..0000000
--- a/src/templates/cpc_P000S67B/HariTest1_template.json
+++ /dev/null
@@ -1,61 +0,0 @@
-{
-    "partition": [
-        {
-            "acceptable-status": [
-                "active"
-            ], 
-            "access-basic-counter-set": false, 
-            "access-basic-sampling": false, 
-            "access-coprocessor-group-set": false, 
-            "access-crypto-activity-counter-set": false, 
-            "access-diagnostic-sampling": false, 
-            "access-extended-counter-set": false, 
-            "access-global-performance-data": false, 
-            "access-problem-state-counter-set": false, 
-            "boot-configuration-selector": 1, 
-            "boot-device": "storage-adapter", 
-            "boot-logical-unit-number": "1111111111111111", 
-            "boot-os-specific-parameters": "blah", 
-            "boot-record-lba": "456", 
-            "boot-storage-device": "/api/partitions/1b472a76-fb38-11e5-8417-40f2e9ef1644/hbas/1c12715e-fb38-11e5-9217-40f2e9ef1644", 
-            "boot-timeout": 60, 
-            "boot-world-wide-port-name": "0001000000000000", 
-            "cp-absolute-processor-capping": false, 
-            "cp-absolute-processor-capping-value": "1.0", 
-            "cp-processing-weight-capped": false, 
-            "cp-processors": 1, 
-            "cryptos": null, 
-            "description": "", 
-            "hba-boot-device-number": "0001", 
-            "hbas": [
-                {
-                    "adapter-port-uri": "/api/adapters/bd9cfba0-f040-11e5-a770-42f2e9ef1641/storage-ports/0", 
-                    "description": "", 
-                    "device-number": "0001", 
-                    "name": "HariTest1"
-                }
-            ], 
-            "ifl-absolute-processor-capping": false, 
-            "ifl-absolute-processor-capping-value": "1.0", 
-            "ifl-processing-weight-capped": false, 
-            "ifl-processors": 0, 
-            "initial-cp-processing-weight": 100, 
-            "initial-ifl-processing-weight": 100, 
-            "initial-memory": 4096, 
-            "maximum-cp-processing-weight": 999, 
-            "maximum-ifl-processing-weight": 999, 
-            "maximum-memory": 4096, 
-            "minimum-cp-processing-weight": 1, 
-            "minimum-ifl-processing-weight": 1, 
-            "name": "HariTest1", 
-            "nics": [], 
-            "permit-aes-key-import-functions": true, 
-            "permit-cross-partition-commands": false, 
-            "permit-des-key-import-functions": true, 
-            "processor-management-enabled": false, 
-            "processor-mode": "shared", 
-            "reserve-resources": false, 
-            "virtual-functions": []
-        }
-    ]
-}
\ No newline at end of file
diff --git a/src/utils/__init__.py b/src/utils/__init__.py
deleted file mode 100755
index e69de29..0000000
diff --git a/src/utils/__init__.pyc b/src/utils/__init__.pyc
deleted file mode 100644
index 4367e53..0000000
Binary files a/src/utils/__init__.pyc and /dev/null differ
diff --git a/src/utils/wsaconst.py b/src/utils/wsaconst.py
deleted file mode 100755
index b16f4d9..0000000
--- a/src/utils/wsaconst.py
+++ /dev/null
@@ -1,685 +0,0 @@
-
-WSA_CONST_VERSION = "1.1"  # Current version of the API constants
-
-# Make a copy of the input array.  This copy contains lowercase versions of each
-# array element that is not already lowercase.
-def make_lowercase_copy(tokens):
-    lower_tokens = []
-    for token in tokens:
-        lower_token = token.lower()
-        #print "token: %s (%s)" % (token, lower_token)
-        if lower_token not in tokens:
-            lower_tokens.append(lower_token)
-        #print "lower_tokens(%s): %s" % (len(lower_tokens), lower_tokens)
-    return lower_tokens
-
-# ??? FVT regression test framework to-do's
-# - Need to add testcase_properties definition to all existing testcases.  Use this template
-#   and replace the items in angle brackets with the appropriate strings:
-#
-#      testcase_properties = {TC_FULL_NAME : get_testcase_full_filename(),
-#                             TC_COMPONENT : TC_COMPONENT_<component>,
-#                             TC_ID : get_testcase_id(),
-#                             TC_TITLE : '<title>',
-#                             TC_URI : '<uri>',
-#                             TC_MINIMUM_API_VERSION : TC_API_VERSION_<minimum_version>,
-#                             TC_SCENARIO_TYPE : TC_SCENARIO_TYPE_<scenario_type>,
-#                             TC_EXECUTION_TYPE : TC_EXECUTION_TYPE_<execution_type>,
-#                             TC_CAPABILITIES : [<appropriate TC_CAPABILITY_<capability> values, OR empty array>]}
-#
-# x Consider reworking skeleton.py to follow the above model, so that future automated updates are easier,
-#   and as many as possible of these properties can come from the FVT Lotus Notes database. [done]
-#   x Consider adding code to the skeleton to fetch the minimum version out of testcase_properties for
-#     use in a testcase environment check. [done]
-#   x Need to fetch the component, id and title from testcase_properties as well, because they are used
-#     in some print statements at the beginning of the testcase execution. [done]
-# x Need a proper implementation of is_api_version_at_least(). [done]
-# - Should probably add an is_api_version_at_most() method for potential use in the future.
-# - Add a check for required testcase properties???  When?  --get-properties?  --check-properties?
-#   - The list of required properties would be defined in a constant in wsaconst.py
-# x Add support for creating a CSV file of testcases that meet specified criteria? ["done".  Not CSV though.  See runregress.py]
-#   - Add --csv-file option to specify the output CSV filename
-#   - If testcase meets requirements, *append* a line to the CSV file
-#     - If file doesn't exist, create it by writing a header line that defines the columns
-#       - column names and order would be defined in a constant in wsaconst.py
-#   - Requires caller to erase any leftover CSV file before beginning this run
-# x Add an option to runregress.py to specify a top directory to search for testcases to run 
-#     and run all it finds that meet the requirements. [done]
-#   x The requirements can be specified as a single complex string option which is passed
-#     as a bunch of arguments to the testcase.  Maybe something like this:
-#        runregress.py --top-dir <dir> --requirements "--component SVM --component VSM --scenario success --execution-type self-checking" [done]
-
-
-# The name of the variable that defines a testcase's properties.  
-# Each testcase must define this variable appropriately.
-TESTCASE_PROPERTIES_VARIABLE_NAME = 'testcase_properties'
-
-#############################################################################
-# These constants define property names and values that are used to describe
-# testcases.  They are intended for use in the definition of the 
-# TESTCASE_PROPERTIES_VARIABLE_NAME dictionary in each testcase's source code.
-# Some of them can be specified on the command line as testcase requirements.
-#############################################################################
-# Testcase filename, with full path information
-TC_FULL_NAME = 'full_name'
-
-# Testcase ID.  The numeric ID, typically found in the testcase filename, which is of the form:
-# comp_id.py, where comp is the component and id is the testcase ID.
-TC_ID = 'id'
-
-# Testcase title
-TC_TITLE = 'title'
-
-# Primary URI being tested by this testcase
-TC_URI = 'uri'
-
-# API versions.  They must be defined in such a way that they can be meaningfully supported by the is_api_version_*() methods.
-# Be sure to add any new ones to TC_API_VERSION_LIST.
-TC_MINIMUM_API_VERSION = 'min_api_version'
-TC_MAXIMUM_API_VERSION = 'max_api_version'
-TC_API_VERSION_ZGRYPHON_GA2  = '1.1'
-TC_API_VERSION_ZGRYPHON_GA2A = '1.2'
-TC_API_VERSION_ZHELIX_GA1    = '1.3'
-TC_API_VERSION_ZHELIX_GA2    = '1.4'
-TC_API_VERSION_ZHELIX_GA2A   = '1.5'    # LI 1065 - Support for Shutdown and Power-off Tasks
-TC_API_VERSION_ZSPHINX_GA1   = '1.6'
-TC_API_VERSION_ZSPHINX_GA2   = '1.7'
-TC_API_VERSION_ZMIDAS_GA1    = '1.8'
-# List of all valid API versions, used for command line validation
-TC_API_VERSION_LIST = [TC_API_VERSION_ZGRYPHON_GA2, TC_API_VERSION_ZGRYPHON_GA2A, TC_API_VERSION_ZHELIX_GA1, TC_API_VERSION_ZHELIX_GA2,
-                       TC_API_VERSION_ZHELIX_GA2A, TC_API_VERSION_ZSPHINX_GA1, TC_API_VERSION_ZSPHINX_GA2,TC_API_VERSION_ZMIDAS_GA1]
-
-# Testcase capabilities.  These define API/HMC/SE "capabilities" that are tested by certain testcases.
-# They can be, for example, MCF bundles, line items, parts of line items, ODTs, MCFs, MCLs, optional facilities, etc...
-# Be sure to add any new ones to TC_CAPABILITY_LIST.
-TC_CAPABILITIES = 'capabilities'
-TESTCASE_CAPABILITIES = TC_CAPABILITIES  # ??? Temp duplicate of TC_CAPABILITIES until FVT API database is updated to use TC_CAPABILITIES
-TC_CAPABILITY_ZVM           = 'ZVM'  # This testcase requires a z/VM system
-TC_CAPABILITY_IEDN          = 'IEDN'
-TC_CAPABILITY_QDIO          = 'QDIO'
-TC_CAPABILITY_VSWITCH       = 'VIRTUAL SWITCH'
-TC_CAPABILITY_PRSM          = 'PRSM'
-TC_CAPABILITY_XHYP          = 'X86'
-TC_CAPABILITY_POWERVM       = 'POWER-VM'
-#TC_CAPABILITY_BLADEXHYP     = 'X86-BLADE'
-#TC_CAPABILITY_BLADEPOWER    = 'POWER-BLADE'
-TC_CAPABILITY_BLADEISAOPT   = 'ISAOPT-BLADE'
-TC_CAPABILITY_BLADEDPXI50Z  = 'DPXI50Z-BLADE'
-TC_CAPABILITY_ZAWARE  = 'ZAWARE'
-TC_CAPABILITY_ZBX  = 'ZBX'
-TC_CAPABILITY_ZFX  = 'ZFX'
-TC_CAPABILITY_ZHYP  = 'ZHYP'
-TC_CAPABILITY_ZXN  = 'ZXN' # For zExtension nodes - zFX Mod 001 & zBX Mod 004 nodes
-TC_CAPABILITY_ZBXMOD004 = 'ZBXMOD004'
-# List of all valid capabilities, used for command line validation
-TC_CAPABILITY_LIST = [TC_CAPABILITY_ZVM, TC_CAPABILITY_IEDN, TC_CAPABILITY_QDIO, TC_CAPABILITY_VSWITCH, TC_CAPABILITY_PRSM, TC_CAPABILITY_XHYP, 
-                      TC_CAPABILITY_POWERVM, TC_CAPABILITY_BLADEISAOPT, TC_CAPABILITY_BLADEDPXI50Z, TC_CAPABILITY_ZAWARE]
-TC_CAPABILITY_LIST.extend(make_lowercase_copy(TC_CAPABILITY_LIST))  # Add lowercase versions as needed, for command line convenience
-
-
-# Testcase components
-# Be sure to add any new ones to TC_COMPONENT_LIST.
-TC_COMPONENT = 'component'
-TC_COMPONENT_CONS = 'CONS'  #CreateTemplate
-TC_COMPONENT_CPC  = 'CPC'   #Central Processor Complex
-TC_COMPONENT_CREC = 'CREC'  #Capacity Records
-TC_COMPONENT_EAM  = 'EAM'   #Enterprise Availability Management
-TC_COMPONENT_EM   = 'EM'    #Energy Management
-TC_COMPONENT_EMM  = 'EMM'   #Ensemble Membership Management
-TC_COMPONENT_EMF  = 'EMF'   #Ensemble Measurement Facility
-TC_COMPONENT_GPRO = 'GPRO'  #Group Profiles
-TC_COMPONENT_GRP  = 'GRP'   #Groups
-TC_COMPONENT_GS   = 'GS'    #General Services
-TC_COMPONENT_HVM  = 'HVM'   #Hypervisor Virtualization Management
-TC_COMPONENT_IOM  = 'IOM'   #I/O Configuration Management
-TC_COMPONENT_IPRO = 'IPRO'  #Image Activation Profiles
-TC_COMPONENT_IS   = 'IS'    #Inventory Service
-TC_COMPONENT_LGR  = 'LGR'   #Live Guest Relocation
-TC_COMPONENT_LPAR = 'LPAR'  #Logical Partition
-TC_COMPONENT_LPRO = 'LPRO'  #Load Activation Profile
-TC_COMPONENT_MDM  = 'MDM'   #Monitors Dashboard Metric Groups
-TC_COMPONENT_MS   = 'MS'    #Metrics Service
-TC_COMPONENT_NVM  = 'NVM'   #Network Virtualization Management
-TC_COMPONENT_PPM  = 'PPM'   #Workloads and Performance Management
-TC_COMPONENT_RPRO = 'RPRO'  #Reset Activation Profiles
-TC_COMPONENT_SEC  = 'SEC'   #Security and User Management
-TC_COMPONENT_SVM  = 'SVM'   #Storage Virtualization Management
-TC_COMPONENT_VSM  = 'VSM'   #Virtual Server Management
-TC_COMPONENT_zBX  = 'zBX'   #zEnterprise Blade Extension
-TC_COMPONENT_ZFX  = 'ZFX'   #zEnterprise Flex System
-TC_COMPONENT_ZXN  = 'ZXN'   #zNode for both zFX and zBX nodes
-TC_COMPONENT_HVM_2 = 'HVM_2'#hvm for prsm2
-TC_COMPONENT_SVM_2 = 'SVM_2'#svm for prsm2
-TC_COMPONENT_VSM_2 = 'VSM_2'#vsm for prsm2
-TC_COMPONENT_CPC_2 = 'CPC_2'#cpc for prsm2
-TC_COMPONENT_NVM_2 = 'NVM_2'#nvm for prsm2
-
-# List of all valid components, used for command line validation
-TC_COMPONENT_LIST = [TC_COMPONENT_CONS, TC_COMPONENT_CPC, TC_COMPONENT_CREC, TC_COMPONENT_EAM, TC_COMPONENT_EM, TC_COMPONENT_EMM,
-                     TC_COMPONENT_GPRO, TC_COMPONENT_GRP, TC_COMPONENT_GS, TC_COMPONENT_HVM, TC_COMPONENT_IPRO, TC_COMPONENT_IS,
-                     TC_COMPONENT_LPAR, TC_COMPONENT_LPRO, TC_COMPONENT_MDM, TC_COMPONENT_MS, TC_COMPONENT_NVM, TC_COMPONENT_PPM,
-                     TC_COMPONENT_RPRO, TC_COMPONENT_SVM, TC_COMPONENT_VSM, TC_COMPONENT_SEC,TC_COMPONENT_zBX, 
-                     TC_COMPONENT_HVM_2, TC_COMPONENT_SVM_2,TC_COMPONENT_NVM_2,TC_COMPONENT_VSM_2,TC_COMPONENT_CPC_2]
-TC_COMPONENT_LIST.extend(make_lowercase_copy(TC_COMPONENT_LIST))    # Add lowercase versions as needed, for command line convenience
-
-
-# Testcase scenario type
-# Be sure to add any new ones to TC_SCENARIO_TYPE_LIST.
-TC_SCENARIO_TYPE = 'scenario_type'
-TC_SCENARIO_TYPE_AUTHORIZATION = 'authorization'
-TC_SCENARIO_TYPE_FAILURE       = 'failure'
-TC_SCENARIO_TYPE_NOTIFICATION  = 'notification'
-TC_SCENARIO_TYPE_SUCCESS       = 'success'
-# List of all valid scenario types, used for command line validation
-TC_SCENARIO_TYPE_LIST = [TC_SCENARIO_TYPE_AUTHORIZATION, TC_SCENARIO_TYPE_FAILURE, TC_SCENARIO_TYPE_NOTIFICATION, TC_SCENARIO_TYPE_SUCCESS]
-TC_SCENARIO_TYPE_LIST.extend(make_lowercase_copy(TC_SCENARIO_TYPE_LIST))    # Add lowercase versions as needed, for command line convenience
-
-# Testcase execution type
-# Be sure to add any new ones to TC_EXECUTION_TYPE_LIST.
-TC_EXECUTION_TYPE = 'execution_type'
-TC_EXECUTION_TYPE_DISRUPTIVE               = 'disruptive'
-TC_EXECUTION_TYPE_MANUAL                   = 'manual'
-TC_EXECUTION_TYPE_SELF_CHECKING            = 'self-checking'
-TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE  = 'self-checking-exclusive'
-TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP = 'self-checking-with-setup'
-TC_EXECUTION_TYPE_SUBTEST                  = 'subtest'
-# List of all valid execution types, used for command line validation
-TC_EXECUTION_TYPE_LIST = [TC_EXECUTION_TYPE_DISRUPTIVE, TC_EXECUTION_TYPE_MANUAL, TC_EXECUTION_TYPE_SELF_CHECKING,
-                          TC_EXECUTION_TYPE_SELF_CHECKING_EXCLUSIVE, TC_EXECUTION_TYPE_SELF_CHECKING_WITH_SETUP, TC_EXECUTION_TYPE_SUBTEST]
-TC_EXECUTION_TYPE_LIST.extend(make_lowercase_copy(TC_EXECUTION_TYPE_LIST))  # Add lowercase versions as needed, for command line convenience
-
-# Marker lines for output of --get-properties requests
-GET_PROPERTIES_BEGIN_MARKER = "***%s begin***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
-GET_PROPERTIES_END_MARKER = "***%s end***" % (TESTCASE_PROPERTIES_VARIABLE_NAME)
-
-
-#############################################################################
-# Miscellaneous constants
-#############################################################################
-
-# Flag to indicate whether ODT Z9474 is applied to the target system.  It changes some
-# characteristics of notification messages.  This flag allows the message validation
-# code to react accordingly.
-Z9474_applied = True
-
-
-#############################################################################
-# "Temporary object" support.  These are constants that support the creation
-# (via the various object-specific "create_temporary_<object-type>()" methods)
-# and deletion of "temporary" objects.
-#############################################################################
-
-# System-defined users, used for admin-type operations during testcase scenario setup
-# and cleanup.  These constants are intended for use as values for the KEY_ADMIN_USERID 
-# property in the temporary_object_types_info collection and on calls to get_admin_session(userid).
-ACCESS_ADMINISTRATOR =      'ACSADMIN'
-ADVANCED_OPERATOR =         'ADVANCED'
-ENSEMBLE_ADMINISTRATOR =    'ENSADMIN'
-ENSEMBLE_OPERATOR =         'ENSOPERATOR'
-SYSTEM_OPERATOR =           'OPERATOR'
-SERVICE_REPRESENTATIVE =    'SERVICE'
-SYSTEM_PROGRAMMER =         'SYSPROG'
-PEDEBUG =                   'PEDEBUG'
-
-# These constants identify the kinds of objects that are supported by the
-# "temporary object" support in wsautils.  Each type must be added to the
-# temporary_object_types_deletion_order list in the appropriate position,
-# and it must also be added to the temporary_object_types_info collection
-# so it can be identified and handled properly.
-TEMP_OBJ_TYPE_USER =                'user'
-TEMP_OBJ_TYPE_USER_ROLE =           'role'
-TEMP_OBJ_TYPE_USERID_PATTERN =      'userid-pattern'
-TEMP_OBJ_TYPE_PASSWORD_RULE =       'password-rule'
-TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG =  'ldap'
-TEMP_OBJ_TYPE_CUSTOM_GROUP =        'group'
-TEMP_OBJ_TYPE_VIRTUAL_SERVER =      'virtual-server'
-TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP = 'workload-resource_group'
-TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP = 'workload-element_group'
-
-# An ordered list of object types supported as "temporary objects".  This list defines
-# the order in which the temporary objects are deleted at the end of testcase execution.
-temporary_object_types_deletion_order = [TEMP_OBJ_TYPE_USERID_PATTERN,  # must be before User (specifically, before type=template Users are deleted)
-                                         TEMP_OBJ_TYPE_USER,
-                                         TEMP_OBJ_TYPE_USER_ROLE,       # must be after User
-                                         TEMP_OBJ_TYPE_CUSTOM_GROUP,    # must be after User Role and User
-                                         TEMP_OBJ_TYPE_PASSWORD_RULE,   # must be after User
-                                         TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG,  # must be after patterns
-                                         TEMP_OBJ_TYPE_VIRTUAL_SERVER,
-                                         TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP,
-                                         TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP, # must be after Workload Element Groups
-                                        ]
-
-# Keys for info in the temporary_object_types_info map
-KEY_ADMIN_USERID = 'admin_userid'   # Key for the name of the system-defined user that has administration privileges for this type of object
-KEY_URI_PREFIX =   'uri_prefix'     # Key for the initial constant part of the URI that identifies an object this type
-
-# Map of information about the object types that are supported as "temporary objects"
-temporary_object_types_info = dict({TEMP_OBJ_TYPE_USER :                {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/users/'}, 
-                                    TEMP_OBJ_TYPE_USER_ROLE :           {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/user-roles/'},
-                                    TEMP_OBJ_TYPE_USERID_PATTERN :      {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/user-patterns/'},
-                                    TEMP_OBJ_TYPE_PASSWORD_RULE :       {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/password-rules/'},
-                                    TEMP_OBJ_TYPE_LDAP_SERVER_CONFIG :  {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/console/ldap-server-definitions/'},
-                                    TEMP_OBJ_TYPE_CUSTOM_GROUP :        {KEY_ADMIN_USERID : ACCESS_ADMINISTRATOR, KEY_URI_PREFIX : '/api/groups/'},
-                                    TEMP_OBJ_TYPE_VIRTUAL_SERVER :      {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/virtual-servers/'},
-                                    TEMP_OBJ_TYPE_WORKLOAD_RESOURCE_GROUP   : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-resource-groups/'},
-                                    TEMP_OBJ_TYPE_WORKLOAD_ELEMENT_GROUP    : {KEY_ADMIN_USERID : ENSEMBLE_ADMINISTRATOR, KEY_URI_PREFIX : '/api/workload-element-groups/'},
-                                  })
-
-
-# Map of URI prefixes to the name of the system-defined user that has administrator permissions for objects with that URI prefix.
-# This map is used to locate/create an API session with administrator permissions for the URI prefix.
-# Note that these prefixes must be listed from most-specific to least-specific, since they are searched in order.
-# It is recommended to include a trailing slash only on URI prefixes that require it in order for it to be a valid URI.
-# (Some URI prefixes can be used in their entirety on List operations, and thus should not include a trailing slash;
-# if needed, two entries can be included: one with a trailing slash and one without).
-# TODO: add support for expressions or wildcards for objects that contain multiple IDs (e.g., element objects often have multiple IDs)
-uri_admin_info = dict({'/api/ensembles' : ENSEMBLE_ADMINISTRATOR,
-                       '/api/console/hardware-messages' : SYSTEM_PROGRAMMER,
-                       '/api/console/users' : ACCESS_ADMINISTRATOR,
-                       '/api/console/user-roles' : ACCESS_ADMINISTRATOR,
-                       '/api/console/tasks' : ACCESS_ADMINISTRATOR,
-                       '/api/console/user-patterns' : ACCESS_ADMINISTRATOR,
-                       '/api/console/password-rules' : ACCESS_ADMINISTRATOR,
-                       '/api/console/ldap-server-definitions' : ACCESS_ADMINISTRATOR,
-                       '/api/users/' : ACCESS_ADMINISTRATOR,
-                       '/api/user-roles/' : ACCESS_ADMINISTRATOR,
-                     })
-#############################################################################
-# ActiveMQ
-# Note that the HMC must be configured to explicitly use the non-SSL ports.
-#############################################################################
-
-# PyActiveMQ ports
-WSA_ACTIVEMQ_PORT_NON_SSL = 61616
-WSA_ACTIVEMQ_PORT_SSL     = 61617
-
-# STOMP ports
-WSA_STOMP_PORT_NON_SSL = 61613
-WSA_STOMP_PORT_SSL = 61612
-
-# Supported ActiveMQ clients
-# These constants are used as command line option values.
-AMQ_CLIENT_PYACTIVEMQ = 'pyactivemq'
-AMQ_CLIENT_STOMP = 'stomp'
-WSA_DEFAULT_AMQ_CLIENT = AMQ_CLIENT_STOMP
-
-# ActiveMQ socket types.
-# These constants are used as command line option values.
-SOCKET_TYPE_SSL = 'ssl'
-SOCKET_TYPE_NON_SSL = 'non-ssl'
-
-#############################################################################
-# Test systems information
-#############################################################################
-### R32 ensemble
-# The name of the ensemble on the primary FVT test system.  This can be used
-# in testcases with certain prerequisites/restrictions that are known to
-# exist on R32.
-ENSEMBLE_NAME_R32 = 'R32Ensemble'
-DEFAULT_ENSEMBLE_NAME = 'ZBX51'
-DEFAULT_CPC_NAME = 'S32'
-DEFAULT_VIRTUALIZATION_HOST_NAME = 'B.1.12'
-DEFAULT_VIRTUAL_SERVER_NAME = 'APIVM1'
-DEFAULT_LPAR_NAME = 'APIVM1'
-PREFERRED_ZVM_VIRTUALIZATION_HOST_R32 = 'APIVM1'
-IP_ADDRESS_R32_HMC = 'Y.Y.Y.Y'         # (R32 is no longer available for API testing)
-IP_ADDRESS_R32_ALT_HMC = '9.60.14.45'     # (R32 is no longer available for API testing)
-FAMILIAR_NAME_R32_HMC = 'S32'          # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
-
-# Ichabod ensemble
-IP_ADDRESS_ICHABOD_HMC = '9.60.14.63'
-FAMILIAR_NAME_ICHABOD_HMC = 'ICHABOD'  # The familiar name for the HMC/SE/Ensemble, not necessarily the HMC's hostname
-
-#===============================================================================
-# Constant file to run the Testcase : lpar_5433
-# 
-LPAR_CPC_NAME = 'APIVM1'
-LPAR_NAME     = 'VMALT' # remove the postfix '1' from the lpar name.
-LPAR_NAME_ONE = 'VMALT1'
-LPAR_NAME_TWO = 'VMALT2'
-LPAR_NAME_THREE = 'VMALT3'
-#===============================================================================
-
-#############################################################################
-# API URIs
-#############################################################################
-
-# Log onto an HMC
-WSA_URI_LOGON   = '/api/session'
-
-# Log off of an HMC
-WSA_URI_LOGOFF  = '/api/session/this-session'
-
-# Retrieve the API version
-WSA_URI_VERSION = '/api/version'
-
-# List all ensembles
-WSA_URI_ENSEMBLES      = '/api/ensembles'
-
-# Retrieve properties of a specific ensemble
-WSA_URI_ENSEMBLE       = '/api/ensembles/{0}'
-
-# Retrieve all CPCs
-WSA_URI_CPCS           = '/api/cpcs'
-
-# Retrieve all virtualization hosts of a specific ensemble
-WSA_URI_VIRT_HOSTS_ENS = '/api/ensembles/{0}/virtualization-hosts'
-
-# Retrieve all virtualization hosts of a specific cpc
-WSA_URI_VIRT_HOSTS_CPC = '/api/cpcs/{0}/virtualization-hosts'
-
-# Retrieve all properties of a specific virtualization host
-WSA_URI_VIRT_HOST      = '/api/virtualization-hosts/{0}'
-
-
-#############################################################################
-# Testcase exit return codes
-#############################################################################
-
-# Exit return code for successful testcase execution
-WSA_EXIT_SUCCESS = 0
-
-# Exit return code for an API error
-WSA_EXIT_ERROR_API = 1
-
-# Exit return code for an unexpected error such as a communication failure
-WSA_EXIT_ERROR_UNCAUGHT = 2
-
-# Exit return code for successful --get-properties request
-WSA_EXIT_GET_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
-
-# Exit return code for successful --check-properties request
-WSA_EXIT_CHECK_PROPERTIES_SUCCESS = WSA_EXIT_SUCCESS
-
-# Exit return code for an invalid command line (e.g., an invalid combination of options)
-WSA_EXIT_INVALID_COMMAND_LINE = 5
-
-# Exit return code for an error due to missing testcase properties
-WSA_EXIT_MISSING_TESTCASE_PROPERTIES = 6
-
-# Exit return code indicating that a specific testcase property is not defined
-WSA_EXIT_PROPERTY_NOT_DEFINED = 7
-
-# Exit return code indicating that a testcase requirement was not met
-WSA_EXIT_REQUIREMENT_NOT_MET = 8
-
-
-WSA_EXIT_ERROR_CLEANUP = 9
-#############################################################################
-# HTTP Request and Response
-# Note that the HMC must be configured to explicitly use the non-SSL port.
-#############################################################################
-
-# Non-SSL HTTP Port ... need HTTPConnection ...
-WSA_PORT_NON_SSL = 6167
-
-# SSL HTTP Port ... needs HTTPSConnection ...
-WSA_PORT_SSL     = 6794
-
-# HTTP GET command
-WSA_COMMAND_GET    = 'GET'
-
-# HTTP DELETE command
-WSA_COMMAND_DELETE = 'DELETE'
-
-# HTTP POST command
-WSA_COMMAND_POST   = 'POST'
-
-# HTTP PUT command
-WSA_COMMAND_PUT    = 'PUT'
-
-# Header for content type ... both request and response
-WSA_HEADER_CONTENT    = 'content-type'
-WSA_HEADER_CONTENT_TYPE   = WSA_HEADER_CONTENT  # Synonym with better name
-WSA_HEADER_CONTENT_LENGTH = 'content-length'
-
-# Header for API session ... request header only
-WSA_HEADER_RQ_SESSION = 'x-api-session'
-
-# Header for API session ... response header only
-WSA_HEADER_RS_SESSION = 'api-session'
-
-# Response headers (these are published in the examples in the WS API customer book)
-WSA_HEADER_RESP_SERVER = 'server'
-WSA_HEADER_RESP_CACHE_CONTROL = 'cache-control'
-WSA_HEADER_RESP_DATE = 'date'
-WSA_HEADER_RESP_LOCATION = 'location'
-WSA_HEADER_RESP_TRANSFER_ENCODING = 'transfer-encoding'
-
-WSA_CONTENT_JSON = 'application/json'
-WSA_CONTENT_XML  = 'application/xml'
-WSA_CONTENT_ZIP  = 'application/zip'
-
-# Currently supported content types
-WSA_SUPPORTED_CONTENT = [ WSA_CONTENT_JSON, WSA_CONTENT_XML, WSA_CONTENT_ZIP ]
-
-#############################################################################
-# Common property names
-#############################################################################
-PROPERTY_OBJECT_URI   = 'object-uri'
-PROPERTY_NAME         = 'name'
-PROPERTY_DESCRIPTION  = 'description'
-PROPERTY_LPAR_NAME    = 'lpar-name'
-PROPERTY_ID           = 'partition-id'
-PROPERTY_TYPE         = 'type'
-PROPERTY_ADAPTER_ID   = 'adapter-id'
-PROPERTY_ADAPTER_PORT = 'adapter-port'
-PROPERTY_PORT_INDEX   = 'port-index'
-
-
-
-#############################################################################
-# Command line option names
-#############################################################################
-OPTION_ADDR = '--addr'
-OPTION_PORT = '--port'
-OPTION_USER = '--user'
-OPTION_PASS = '--pass'
-OPTION_GET_PROPERTIES = '--get-properties'
-OPTION_CHECK_PROPERTIES = '--check-properties'
-OPTION_RUN_IF_APPLICABLE = '--run-if-applicable'
-OPTION_CAPABILITY = '--capability'
-OPTION_COMPONENT = '--component'
-OPTION_SCENARIO = '--scenario'
-OPTION_EXECUTION_TYPE = '--execution-type'
-#OPTION_MIN_VERSION = '--min-version'    # (Replaced by OPTION_REQUIRED_VERSION)
-#OPTION_MAX_VERSION = '--max-version'    # (Replaced by OPTION_REQUIRED_VERSION)
-OPTION_REQUIRED_VERSION = '--required-version'
-OPTION_API_VERSION = '--api-version'
-
-
-# Command line destination variable names
-OPTION_ADDR_DEST = 'host'
-OPTION_PORT_DEST = 'port'
-OPTION_USER_DEST = 'user'
-OPTION_PASS_DEST = 'pwd'
-
-#############################################################################
-# Command line default values
-#############################################################################
-DEFAULT_ADDR = '9.56.198.64'#'9.152.151.49'# '9.12.38.189' #'9.56.192.214' # '9.60.15.124'# ''9.56.192.214' #  '9.60.31.100'#'9.152.151.49' #'9.56.192.214' #'9.152.151.49' #'9.60.31.168'#'9.60.31.170'#'9.12.38.183'    # A dummy default, to force the user to specify --addr.  (R32 is no longer available)
-#DEFAULT_ADDR = '9.60.15.62'  #p15
-#DEFAULT_ADDR = '9.60.14.63'   #Ichabod
-#DEFAULT_ADDR = '9.56.196.93'
-DEFAULT_PORT = WSA_PORT_SSL
-WSA_DEFAULT_USERID   = 'ensadmin'
-WSA_DEFAULT_PASSWORD = 'password'
-
-#############################################################################
-# API feature strings.  These identify optional WS API features that may be
-# available on the HMC.  A list of available features is included in the 
-# response to the API Version and Logon requests.  The available features
-# are specified in files in the /console/data/webapi/features/ directory on
-# the HMC.
-#############################################################################
-FEATURE_GET_FILES_FROM_SE = 'internal-get-files-from-se' # Internal-use only API to fetch a specified file(s) from an SE
-
-#############################################################################
-# Response Validation
-#############################################################################
-
-STATUS       = 'status'
-CONTENT_TYPE = 'content-type'
-REQUIRED     = 'required'
-OPTIONAL     = 'optional'
-
-
-STATUS_200     = ( STATUS, 200 )
-STATUS_201     = ( STATUS, 201 )
-STATUS_202     = ( STATUS, 202 )
-STATUS_204     = ( STATUS, 204 )
-CONTENT_JSON   = ( CONTENT_TYPE, WSA_CONTENT_JSON )
-REQUIRED_EMPTY = ( REQUIRED, [] )
-OPTIONAL_EMPTY = ( OPTIONAL, [] )
-OPTIONAL_API1DOT4 = ( OPTIONAL, ['acceptable-avail-status','avail-policies','avail-status','element-groups','perf-policies','absolute-ziip-capping','workload-element-groups','shutdown-timeout', 'shutdown-timeout-source','gpmp-network-adapter'] )
-OPTIONAL_PASSWORD_EXPIRES = (OPTIONAL, ['password-expires'])
-
-
-# Logon and Version #########################################################
-
-__ver_required       = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'hmc-name', 'hmc-version' ] )
-__ver_optional       = ( OPTIONAL, [ 'api-features' ] )
-__logon_required     = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic' ] )
-__logon_required_job = ( REQUIRED, [ 'api-major-version', 'api-minor-version', 'api-session', 'notification-topic','job-notification-topic' ] )
-__logon_optional     = ( OPTIONAL, [ 'password-expires', 'api-features' ] )
-
-# Validate response from 'Get Version' operation
-WSA_VERSION_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __ver_required, __ver_optional ] )
-
-# Validate response from 'Logon' operation
-WSA_LOGON_VALIDATE     = dict( [ STATUS_200, CONTENT_JSON, __logon_required, __logon_optional ] )
-WSA_LOGON_VALIDATE_JOB     = dict( [ STATUS_200, CONTENT_JSON, __logon_required_job, __logon_optional ] )
-
-# Ensembles #################################################################
-
-__list_ensembles_required = ( REQUIRED, [ 'ensembles' ] )
-
-__get_ensemble_required   = ( REQUIRED, [ 'acceptable-status',
-                                            'class',
-                                            'cpu-perf-mgmt-enabled-power-vm',
-                                            'cpu-perf-mgmt-enabled-zvm',
-                                            'description',
-                                            'has-unacceptable-status',
-                                            'is-locked',
-                                            'mac-prefix',
-                                            'management-enablement-level',
-                                            'name',
-                                            'object-id',
-                                            'object-uri',
-                                            'parent',
-                                            'power-consumption',
-                                            'power-rating',
-                                            'reserved-mac-address-prefixes',
-                                            'status',
-                                            'unique-local-unified-prefix' ] )
-
-__get_ensemble_optional   = ( OPTIONAL, [ 'alt-hmc-name',
-                                            'alt-hmc-ipv4-address',
-                                            'alt-hmc-ipv6-address',
-                                          'cpu-perf-mgmt-enabled-x-hyp',
-                                            'cpu-perf-mgmt-enabled-x-hyp',  #temporarily resumed by lv, for zHelixGA2 testing, but notice it is not running on lower version
-
-                                            'load-balancing-enabled',
-                                            'load-balancing-ip-addresses',
-                                            'load-balancing-port',
-                                            'max-nodes',
-                                            'max-cpc-nodes',
-                                            'max-zbx-nodes' ] )
-
-# Validate response from 'List Ensembles' operation
-WSA_LIST_ENSEMBLES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_ensembles_required, OPTIONAL_EMPTY ] )
-
-# Required keys for each ensemble returned by 'List Ensembles' operation
-WSA_LIST_ENSEMBLE_REQUIRED  = [ 'name', 'object-uri', 'status' ]
-
-# Validate response from 'Get Ensemble Properties' operation
-WSA_GET_ENSEMBLE_VALIDATE   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required,   __get_ensemble_optional ] )
-
-
-# CPCs ######################################################################
-
-__list_cpcs_required = ( REQUIRED, [ 'cpcs' ] )
-
-# Validate response from 'List CPCs' operation
-WSA_LIST_CPCS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_cpcs_required, OPTIONAL_EMPTY ] )
-
-# Required keys for each cpc returned by 'List CPCs' operation
-WSA_LIST_CPC_REQUIRED  = [ 'name', 'object-uri', 'status' ]
-
-# Required keys for 'Get CPC Properties' operation
-__get_cpc_properties_required  = ( REQUIRED, [ 'name',
-                                               'object-uri',
-                                               'type',
-                                               'status' ] )
-
-# Validate response from 'Get CPC Properties' operation
-WSA_GET_CPC_PROPERTIES_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __get_cpc_properties_required, OPTIONAL_EMPTY ] )
-
-
-# Virtualization Hosts ######################################################
-
-__list_virt_hosts_required = ( REQUIRED, [ 'virtualization-hosts' ] )
-
-# Validate response from 'List Virtualization Hosts' operation
-WSA_LIST_VIRT_HOSTS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_hosts_required, OPTIONAL_EMPTY ] )
-
-# Required keys for each virtualization host returned by 'List Virtualization Hosts' operation
-WSA_LIST_VIRT_HOST_REQUIRED  = [ 'name', 'object-uri', 'status', 'type' ]
-
-# Wait period for all zvm tests
-WAIT_PERIOD_FOR_ZVM_TEST = 30 
-
-# These are the properties of a notification message that are not of type string.
-# When an incoming message is received, it is used to populate a dictionary of
-# key-value pairs.  Most of the properties are strings, but some are not and require
-# special handling.  Identify them here along with their datatype.  The addition of
-# a new type here will require corresponding changes where this list is processed.
-if Z9474_applied:
-    nonstring_message_properties = [
-                                    ('global-sequence-nr', 'long'), 
-                                    ('session-sequence-nr', 'long'),
-                                   ]
-else:
-    nonstring_message_properties = [
-                                   ]
-
-
-#added by lv start
-APA_TESTENV_CPC_UNDER_TEST = 'BLUECORE'
-
-__list_virt_servers_required = ( REQUIRED, [ 'virtual-servers' ] )
-
-# Validate response from 'List Virtualization Hosts' operation
-WSA_LIST_VIRT_SERVERS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_servers_required, OPTIONAL_EMPTY ] )
-
-__list_virt_server_groups_required = ( REQUIRED, [ 'virtual-server-groups' ] )
-
-WSA_LIST_VIRT_SERVER_GROUPS_VALIDATE = dict( [ STATUS_200, CONTENT_JSON, __list_virt_server_groups_required, OPTIONAL_EMPTY ] )
-#added by lv end
-
-#adding the constants need for Ensemble properties for node properties
-__get_ensemble_required_nodes   = ( REQUIRED, [ 'acceptable-status',
-                                            'class',
-                                            'cpu-perf-mgmt-enabled-power-vm',
-                                            'cpu-perf-mgmt-enabled-zvm',
-                                            'description',
-                                            'has-unacceptable-status',
-                                            'is-locked',
-                                            'mac-prefix',
-                                            'management-enablement-level',
-                                            'name',
-                                            'object-id',
-                                            'object-uri',
-                                            'parent',
-                                            'power-consumption',
-                                            'power-rating',
-                                            'reserved-mac-address-prefixes',
-                                            'status',
-                                            'unique-local-unified-prefix',
-                                            'max-cpc-nodes',
-                                            'max-nodes',
-                                            'max-zbx-nodes' ] )
-
-
-WSA_GET_ENSEMBLE_VALIDATE_NODES   = dict( [ STATUS_200, CONTENT_JSON, __get_ensemble_required_nodes,   __get_ensemble_optional ] )
-WSA_DEFAULT_ZBX_NAME = 'ZBX2'
\ No newline at end of file
diff --git a/src/utils/wsaglobals.py b/src/utils/wsaglobals.py
deleted file mode 100755
index 65e6f61..0000000
--- a/src/utils/wsaglobals.py
+++ /dev/null
@@ -1,33 +0,0 @@
-# Global variables for use by wsaconst and friends
-# 
-# Change history:
-# - 2014/07/17 L. Brocious      Initial version.  Added for "temporary object" support.
-# - 2015/02/16 L. Brocious      Add "temporary session" support.
-
-# This is the list of additional command line options (those defined in addition
-# to the "standard" options) defined for the current testcase execution.  This is
-# saved when the Session is created and is used only to allow successful re-parsing
-# of the command line when additional sessions are created during testcase execution
-# (typically during scenario setup and cleanup).
-global global_saved_additional_options
-global_saved_additional_options = None
-
-# The list of all registerd "temporary objects".  This list is managed by the 
-# register_temporary_object() and deregister_temporary_object() methods.  All
-# objects in this list are deleted by default during session shutdown.
-global global_temporary_objects_list
-global_temporary_objects_list = []
-
-# The list of all known "admin" sessions.  Such privileged sessions are typically needed
-# during scenario setup and cleanup.  For performance reasons, they are cached here and
-# reused if needed.  This list is managed by get_admin_session() and delete_all_admin_sessions().
-global global_admin_sessions
-global_admin_sessions = dict()
-
-
-# The list of all registerd "temporary sessions".  A temporary session is associated
-# with a temporary user and is intended for testcase scripts that perform authorization
-# testing.  All sessions in this list are deleted by default during shutdown of the
-# testcase's main session (via the standard session_shutdown(session) call before exit).
-global global_temporary_sessions
-global_temporary_sessions = []
diff --git a/src/utils/wsautils.py b/src/utils/wsautils.py
deleted file mode 100755
index 5a578dc..0000000
--- a/src/utils/wsautils.py
+++ /dev/null
@@ -1,2902 +0,0 @@
-#############################################################################
-#
-# Some utility classes and functions that may be useful for API Testing
-#
-# In order to import this module for use in testcases, set the PYTHONPATH
-# environment variable to point to the directory where the modules are
-# located.
-#
-# from wsaconst import *
-# from wsautils import *
-#
-# The call to os.getenv can be used to retrieve any environment variable, so
-# defining a variable that points to the Python common utilities directory
-# could be established in a test environment startup script, then referenced
-# above in the sys.path.append method call ...
-#
-#############################################################################
-
-from wsaconst import *
-import wsaglobals  # True global variables
-
-import httplib
-import pprint
-import json
-import optparse  # use argparse with Python 2.7.x ...
-from optparse import make_option
-from optparse import OptionGroup
-import string
-
-import sys
-import threading
-import time
-import traceback
-import types
-import ssl
-import os
-import re
-import __main__
-
-import logging
-import logging.config
-
-class progress_bar_loading(threading.Thread):
-
-    def run(self):
-            global stop
-            global kill
-            global progress_str
-            print progress_str + '....  ',
-            sys.stdout.flush()
-            i = 0
-            while stop != True:
-                    if (i % 4) == 0: 
-                        sys.stdout.write('\b/')
-                    elif (i % 4) == 1: 
-                        sys.stdout.write('\b-')
-                    elif (i % 4) == 2: 
-                        sys.stdout.write('\b\\')
-                    elif (i % 4) == 3: 
-                        sys.stdout.write('\b|')
-
-                    sys.stdout.flush()
-                    time.sleep(0.2)
-                    i += 1
-
-            if kill == True: 
-                print '\b\b\b\b ABORT!'
-            else: 
-                print '\b\b done!'
-            return
-        
-    def stop(self):
-        global stop
-        stop = True
-        
-    def configure(self,progress_string='Processing'):
-        global progress_str
-        progress_str = progress_string
-        global stop
-        stop = False
-        
-        
-
-progress_str = "Processing"
-kill = False      
-stop = False
-
-def initializeLogging():
-    logging.basicConfig(level=logging.DEBUG,
-                        format='%(asctime)s %(levelname)-8s %(message)s',
-                        datefmt='%a, %d %b %Y %H:%M:%S',
-                        filename='logs/console.log',
-                        filemode='w')
-
-
-
-
-
-WSA_UTILS_VERSION = "1.1"  # Current version of the API utilities
-
-#############################################################################
-# Determine which, if any, ActiveMQ clients are installed.  Set global flags
-# for later use.
-#############################################################################
-# Try STOMP
-try:
-    import stomp
-    stomp_present = True
-except ImportError:
-    # print "STOMPPY not installed or not supported"
-    stomp_present = False
-
-# Try PyActiveMQ
-try:
-    import pyactivemq
-    pyactivemq_present = True
-except ImportError:
-    # print "Pyactivemq not installed or not supported"
-    pyactivemq_present = False
-
-#############################################################################
-# Exceptions
-#############################################################################
-
-# General exception raised when api errors occur ...
-class ApiException(Exception) :
-
-    def __init__(self, text, response=None, keys=None) :
-        Exception.__init__(self, text)
-        self.text = text  # Message text of exception
-        self.response = response  # Response object, if applicable
-        self.keys = keys  # Keys in error, only used by validate_response and
-                                 # validate_dictionary methods
-
-    def __str__(self) :
-
-        text = self.text
-        keys = self.keys
-        resp = self.response
-
-        result = []
-        result.append('ApiException caught ...\n\n')
-        result.append('MESSAGE :\n')
-        result.append(text)
-        result.append('\n')
-
-        if resp is None or not hasattr(resp, 'body'):
-            if keys is not None :
-                result.append(keys)
-        else :
-            body = resp.body
-            message = body[ 'message' ]     if 'message'     in body else None
-            status = body[ 'http-status' ] if 'http-status' in body else None
-            reason = body[ 'reason' ]      if 'reason'      in body else None
-            uri = body[ 'request-uri' ] if 'request-uri' in body else None
-            result.append('\nReturn Code = ')
-            if status is not None and reason is not None :
-                result.append(status)
-                result.append('.')
-                result.append(reason)
-            else :
-                result.append(str(resp.status))
-            result.append(' ')
-            result.append(resp.reason)
-            if message is not None :
-                result.append('\nResponse Message = ')
-                result.append(message)
-            if keys is not None :
-                result.append(' : ')
-                result.append(keys)
-            if uri is not None :
-                result.append('\nRequest URI = ')
-                result.append(uri)
-            result.append('\n\n')
-            result.append(resp)
-
-        result.append('\n\nStack Trace :\n')
-        stack = traceback.format_tb(sys.exc_info()[2])
-        result.append(''.join([ s for s in stack ]))
-
-        return ''.join([ str(s) for s in result ])
-
-
-#############################################################################
-#
-# Fatal exception ... used for non-API errors ...
-#
-# @parm text      - message text
-# @parm response  - response from HTTP request.  This can be either an
-#                   httplib.HTTPResponse or wsautils.Response object
-# @parm traceback - stack trace, usually taken from a caught exception
-#                   since it will differ from the stack trace created
-#                   when the ApiFatalException is created.
-# @parm request   - a wsautils.Request object representing the information
-#                   sent via an HTTP request.  Since testcase writers do not
-#                   generally have access to the HTTP request, this parameter
-#                   should be considered internal to wsautils only.
-# @parm other     - additional, relevant data provided by the testcase writer
-#                   that may help with diagnostics.
-#
-#############################################################################
-
-class ApiFatalException(Exception) :
-
-    def __init__(self, text, response=None, traceback=None, other=None, request=None) :
-        Exception.__init__(self, text)
-        self.text = text  # Message text for exception
-        self.response = response
-        self.traceback = traceback
-        self.other = other
-        self.request = request
-
-    def __str__(self) :
-
-        result = []
-        result.append('ApiFatalException caught\n\n')
-        result.append('MESSAGE :\n')
-        result.append(self.text)
-        result.append('\n\n')
-
-        if self.response is None and self.request is not None :
-            result.append('REQUEST :\n')
-            result.append(self.request)
-            result.append('\n\n')
-
-        if self.response is not None :
-            result.append('RESPONSE :\n')
-            if isinstance(self.response, httplib.HTTPResponse) :
-                result.append(Response(self.response.status,
-                                         self.response.reason,
-                                         self.response.getheaders(),
-                                         self.response.read()))
-            else :
-                result.append(self.response)
-
-            result.append('\n\n')
-
-        # Append the stack trace created when raising this exception ...
-        result.append('TRACEBACK (most recent stack) :\n')
-        stack = traceback.format_tb(sys.exc_info()[2])
-        result.append(''.join([ s for s in stack ]))
-        result.append('\n')
-
-        # If present, this should be the stack trace created by the
-        # 'caught' exception that was wrapped inside the ApiFatalException
-        if self.traceback is not None :
-            result.append('TRACEBACK (from caught exception) :\n')
-            stack = traceback.format_tb(self.traceback)
-            result.append(''.join([ s for s in stack ]))
-            result.append('\n')
-
-        if self.other is not None :
-            result.append('OTHER :\n')
-            result.append(self.other)
-            result.append('\n')
-
-        return ''.join([ str(s) for s in result ]).strip()
-
-
-#############################################################################
-# Request Class
-#############################################################################
-
-class Request :
-
-    """This class encapsulates an HTTP request"""
-
-    def __init__(self, operation, uri, headers, body) :
-        self.operation = operation
-        self.uri = uri
-        self.headers = headers
-        self.body = body
-
-    def __str__(self) :
-        l = []
-        l.append('Request Operation : ')
-        l.append(str(self.operation))
-        l.append('\nRequest URI       : ')
-        l.append(str(self.uri))
-
-        l.append('\nRequest Headers   : ')
-        if self.headers == None:
-            l.append('None')
-        else:
-            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
-
-        l.append('\nRequest Body      : ')
-        if self.body == None:
-            l.append('None')
-        else:
-            l.append(json.dumps(json.loads(self.body), sort_keys=True, indent=1, separators=(',', ':')))
-
-        return ''.join([ s for s in l ])
-
-
-#############################################################################
-#
-# Response Class
-#
-# This class models an HTTP response object.  The response headers will be
-# converted to a Python dictionary and the response body will be processed
-# through the JSON parser if the content-type header is 'application/json'.
-#
-# If the 'content-type' indicates the body is a json-formatted string and
-# the subsequent call to json.loads fails to parse the body, an
-# ApiFatalException with be raised.  The response will be added to the
-# exception, but the body will the unparse HTTP response body.
-#
-#############################################################################
-
-class Response :
-
-    """This class encapsulates an HTTP response"""
-
-    #########################################################################
-    # Init
-    #########################################################################
-
-    # Initialize a response
-    def __init__(self, status, reason, headers, body, request=None) :
-
-        # ##print '====================== begin body ====================================================='
-        # ##print body
-        # ##print '====================== end body ======================================================='
-        self.status = status  # HTTP response status
-        self.reason = reason  # HTTP response reason
-        self.headers = dict(headers)  # HTTP response headers
-        self.body = body  # HTTP response body
-        self.request = request  # HTTP request
-        self.bodyIsJSON = False  # Indicates whether the saved response body is a parsed JSON string
-
-        if body is not None and len(body) > 0 :
-            if self.headers[ CONTENT_TYPE ].startswith(WSA_CONTENT_JSON) :
-                try :
-                    # Parse the body and save the parsed version
-                    self.body = json.loads(body)
-                    self.bodyIsJSON = True  # Body is now a parsed JSON string
-                except :
-                    raise ApiFatalException(''.join([ str(s) for s in sys.exc_info()[1].args ]), response=self)
-            else :
-                self.body = body
-        else :
-            self.body = '{}'
-            self.bodyIsJSON = True  # Body is a parsed JSON string (an empty body)
-
-    # Print out a string representation of the response
-    def __str__(self) :
-        l = []
-        if self.request is not None :
-            l.append(self.request)
-            l.append('\n\n')
-        l.append('Response Status  : ')
-        l.append(self.status)
-        l.append('\nResponse Reason  : ')
-        l.append(self.reason)
-
-        l.append('\nResponse Headers : ')
-        if self.headers == None:
-            l.append('None')
-        else:
-            l.append(json.dumps(self.headers, sort_keys=True, indent=1, separators=(',', ':')))
-
-        l.append('\nResponse Body    : ')
-        if self.bodyIsJSON:
-            l.append(json.dumps(self.body, sort_keys=True, indent=1, separators=(',', ':')))
-            if 'stack' in self.body:
-                l.append('\n\nstack (again, but in a more programmer-friendly format):\n')
-                l.append(self.body[ 'stack' ])
-        else:
-            l.append(str(self.body))
-
-
-        return ''.join([ str(s) for s in l ])
-
-
-#############################################################################
-#
-# Session Class
-#
-# This class represents a persistent HTTP connection to an HMC.  As such,
-# when the test code is finished with the HTTP connection, the close
-# method should be called to ensure resources are cleaned up.
-#
-# Currently, only JSON-formatted request bodies are supported.  Addtional
-# formats can be added in the future, as needed.
-#
-# The additional_options argument may be used to define any additional command
-# line options to be permitted for this Session.  See parse_standard_options()
-# for more details.  The option values may be referenced via the "opts" member
-# of the Session object.  For example, if an option was defined with dest='sr_name':
-#      name = session.opts.sr_name
-#
-# If the testcase script defines any positional arguments, their Usage information
-# should be specified on the additional_arguments_usage_info argument.  See
-# parse_standard_options() for more details.  The command line arguments can
-# be referenced via the "args" member of the Session object, for example,
-# to access the first testcase-specific positional argument:
-#      property_name = session.args[session.arg_start_index + 0]
-#
-# Note that the __init__ method calls parse_standard_options(), which uses os._exit(rc)
-# in some cases rather than the more common sys.exit(rc).  See the prolog of
-# parse_standard_options for more details.
-#############################################################################
-
-class Session :
-
-    """This class supports connecting to an Ensemble HMC via HTTP"""
-
-    #########################################################################
-    # Init
-    #########################################################################
-
-    def __init__(self, host=None, port=None, user=None, pwd=None, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
-        """Initialize an instance of the Session class"""
-        # Save any additional command line option definitions so that they're available
-        # when the command line is re-parsed if another session is established.
-        wsaglobals.global_saved_additional_options = additional_options
-#       print 'in Session init: global_saved_additional_options=%s' % wsaglobals.global_saved_additional_options
-        opts, args = parse_standard_options(additional_options, additional_arguments_usage_info)  # Read in command line arguments and options, if any ...
-        self.opts = opts  # Keep all parsed options for anyone that might need them
-        self.args = args  # Keep all parsed arguments for anyone that might need them
-        self.arg_start_index = 0  # The index of the first test-case specific argument, if any.
-                                    # There are currently no "standard" arguments, so all arguments
-                                    # are, in effect, test-case specific; thus this index is 0.
-
-        # Save values from the command line or our caller, as appropriate
-        self.__host = opts.host if host is None else host
-        self.__port = opts.port if port is None else port
-        self.__user = opts.user if user is None else user
-        self.__pass = opts.pwd  if pwd  is None else pwd
-        self.__amq_client = opts.amq_client if amq_client is None else amq_client
-        self.__amq_socket_type = opts.amq_socket_type if amq_socket_type is None else amq_socket_type
-        self.__api_version_override = opts.api_version_override
-        self.__get_properties = opts.get_properties
-        self.__check_properties = opts.check_properties
-        self.__run_if_applicable = opts.run_if_applicable
-        self.__required_version = opts.required_version
-        self.__required_capabilities = opts.required_capabilities
-        self.__required_components = opts.required_components
-        self.__required_scenario_types = opts.required_scenario_types
-        self.__required_execution_types = opts.required_execution_types
-
-        self.__args = args
-
-        self.__connection = None  # Persistent HTTP connection
-        self.__session = None  # Session id
-        self.__topic = None  # Topic id for ActiveMQ notifications
-                                   #
-        self.__api_version = None  # WSA API version supported by HMC
-        self.__hmc_name = None  # Name of the connected HMC
-        self.__hmc_version = None  # Version of the connected HMC
-        self.__jobtopic = None  # Topic id for ActiveMQ JOB Notifications
-        self.__api_features = None  # List of available WS API features
-                                   #
-        self.__consumer = None  # ActiveMQ notification consumer
-        self.__callback = None  # Callback method for notification messages
-
-
-        #########################################################################
-        # If no ActiveMQ client was specified, choose one based on what's installed
-        # and available if possible.  Then, if no SSL preference was specified,
-        # select a sensible one based on the ActiveMQ client.  Then, set the ActiveMQ
-        # port to the appropriate port number.
-        #########################################################################
-        # Determine the client type
-        if self.__amq_client is None:
-            if stomp_present == True:  # STOMP is installed; use it
-                self.__amq_client = AMQ_CLIENT_STOMP
-            elif pyactivemq_present == True:  # No STOMP, but PyActiveMQ is installed; use it
-                self.__amq_client = AMQ_CLIENT_PYACTIVEMQ
-            else:  # None installed, so just go with the default here; errors will be surfaced later if an AMQ client is actually required.
-                self.__amq_client = WSA_DEFAULT_AMQ_CLIENT
-
-        # Use PyActiveMQ ActiveMQ client
-        if self.__amq_client == AMQ_CLIENT_PYACTIVEMQ:
-            if self.__amq_socket_type is None:
-                self.__amq_socket_type = SOCKET_TYPE_NON_SSL  # Not specified, so set default
-
-            if self.__amq_socket_type == SOCKET_TYPE_SSL:  # Sensible?  Current versions of pyactivemq don't support SSL
-                self.__amq_port = WSA_ACTIVEMQ_PORT_SSL
-            else:
-                self.__amq_port = WSA_ACTIVEMQ_PORT_NON_SSL
-
-        # Use STOMP ActiveMQ client
-        else:
-            if self.__amq_socket_type is None:
-                self.__amq_socket_type = SOCKET_TYPE_SSL  # Not specified, so set default
-
-            if self.__amq_socket_type == SOCKET_TYPE_SSL:
-                self.__amq_port = WSA_STOMP_PORT_SSL
-            else:
-                self.__amq_port = WSA_STOMP_PORT_NON_SSL
-
-#       print "pyactivemq_present = " + str(pyactivemq_present)
-#       print "stomp_present = " + str(stomp_present)
-#       print "leaving parse_standard_options() with"
-#       print "\t self.__amq_client=" + str(self.__amq_client)
-#       print "\t self.__amq_socket_type=" + str(self.__amq_socket_type)
-#       print "\t self.__amq_port=" + str(self.__amq_port)
-#       print "\t self.__get_properties=" + str(self.__get_properties)
-
-
-    #########################################################################
-    # Open connection to HMC
-    #########################################################################
-
-    def open(self) :
-
-        """Create a persistent HTTP connection to an HMC, then logon"""
-
-        body = json.dumps({ 'userid':self.__user, 'password':self.__pass })
-
-        # Issue the Logon request
-        response = self.__executeRequest(WSA_COMMAND_POST, WSA_URI_LOGON, body, WSA_CONTENT_JSON)
-
-        # Check the status code to be sure logon succeeded before trying to validate
-        # the response details.  For example, the response body might not even be a dictionary.
-        if response.status != 200:
-            raise ApiFatalException('Logon failed', response)
-
-
-#       print '****************'
-#       print response.request
-#       print '****************'
-#       print response.request.headers
-#       print '****************'
-#       print response.headers
-#       print '****************'
-
-
-
-        # Parse and validate the response to the Logon request.  Save info for later use.
-
-        if 'job-notification-topic' in response.body.keys():
-            self.__jobtopic = str(response.body[ 'job-notification-topic' ])
-            validate_response(response, WSA_LOGON_VALIDATE_JOB)
-        else :
-            validate_response(response, WSA_LOGON_VALIDATE)
-
-        self.__session = str(response.body[ 'api-session'        ])
-        self.__topic = str(response.body[ 'notification-topic' ])
-
-        if 'api-features' in response.body.keys():
-            self.__api_features = response.body[ 'api-features' ]  # List of strings
-        
-        # Now issue an API Version request and validate the response
-        response = self.get(WSA_URI_VERSION)
-        validate_response(response, WSA_VERSION_VALIDATE)
-
-        # Parse and save this session's version information
-        ver = []
-        ver.append(str(response.body[ 'api-major-version' ]))
-        ver.append('.')
-        ver.append(str(response.body[ 'api-minor-version' ]))
-
-        self.__api_version = "".join(ver)
-        self.__hmc_name = response.body[ 'hmc-name' ]
-        self.__hmc_version = response.body[ 'hmc-version' ]
-
-        # print "Topic ID: \t%s"     % self.__topic
-        # print "Job Topic ID: \t%s" % self.__jobtopic
-        # print "API version: \t%s"  % self.__api_version
-        # print "API features: \t%s" % self.__api_features
-
-        return self.__connection
-
-
-    #########################################################################
-    # Close connection to HMC
-    #########################################################################
-
-    def close(self) :
-        """Logoff from the HMC, then close the HTTP connection"""
-
-# # TODO : Close ActiveMQ consumer, too?
-
-        if self.__connection is not None :
-            try :
-                # Logoff active session, if needed ...
-                if self.__session is not None :
-                    response = self.delete(WSA_URI_LOGOFF)
-                    if response.status != 204 :
-                        raise ApiFatalException('Unexpected response status during logoff', response=response)
-            finally :
-                try :
-                   # Close the HTTP session
-                   self.__connection.close()
-                finally :
-                    if self.__consumer is not None and self.__consumer.isRunning() :
-                        self.__consumer.stop()
-
-
-    #########################################################################
-    # Get
-    #
-    # Note : If the headers parameter is passed, ALL the required HTTP
-    #        request headers must be included.  No defaults will be added.
-    #      : Specify return_full_response=False to prevent this method from
-    #        reading the response body and closing the HTTP(S) connection.
-    #        See __executeRequest for more information.
-    #########################################################################
-
-    def get(self, uri, headers=None, return_full_response=True) :
-        """Execute an HTTP GET operation"""
-        return self.__executeRequest(WSA_COMMAND_GET, uri, None, None, headers, return_full_response)
-
-
-    #########################################################################
-    # Put
-    #
-    # Note : If the headers parameter is passed, ALL the required HTTP
-    #        request headers must be included.  No defaults will be added.
-    #      : Specify return_full_response=False to prevent this method from
-    #        reading the response body and closing the HTTP(S) connection.
-    #        See __executeRequest for more information.
-    #########################################################################
-
-    def put(self, uri, body, headers=None, return_full_response=True) :
-        """
-        Execute an HTTP PUT operation
-        NOTE: Request body is assumed to be JSON format
-        """
-        return self.__executeRequest(WSA_COMMAND_PUT, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
-
-
-    #########################################################################
-    # Post
-    #
-    # Note : If the headers parameter is passed, ALL the required HTTP
-    #        request headers must be included.  No defaults will be added.
-    #      : Specify return_full_response=False to prevent this method from
-    #        reading the response body and closing the HTTP(S) connection.
-    #        See __executeRequest for more information.
-    #########################################################################
-
-    def post(self, uri, body, headers=None, return_full_response=True) :
-        """
-        Execute an HTTP POST operation
-        NOTE: Request body is assumed to be JSON format
-        """
-        return self.__executeRequest(WSA_COMMAND_POST, uri, body, WSA_CONTENT_JSON, headers, return_full_response)
-
-
-    #########################################################################
-    # Delete
-    #
-    # Note : If the headers parameter is passed, ALL the required HTTP
-    #        request headers must be included.  No defaults will be added.
-    #      : Specify return_full_response=False to prevent this method from
-    #        reading the response body and closing the HTTP(S) connection.
-    #        See __executeRequest for more information.
-    #########################################################################
-
-    def delete(self, uri, headers=None, return_full_response=True) :
-        """Execute an HTTP DELETE operation"""
-        return self.__executeRequest(WSA_COMMAND_DELETE, uri, None, None, headers, return_full_response)
-
-
-    #########################################################################
-    # Host
-    #########################################################################
-
-    def host(self) :
-        """Return the host"""
-        return self.__host
-
-
-    #########################################################################
-    # Port
-    #########################################################################
-
-    def port(self) :
-        """Return the port"""
-        return self.__port
-
-
-    #########################################################################
-    # Userid
-    #########################################################################
-
-    def userid(self) :
-        """Return the userid"""
-        return self.__user
-
-
-    #########################################################################
-    # Password
-    #########################################################################
-
-    def password(self) :
-        """Return the password"""
-        return self.__pass
-
-
-    #########################################################################
-    # Session
-    #########################################################################
-
-    def session(self) :
-        """Return the active session identifier"""
-        return self.__session
-
-
-    #########################################################################
-    # Topic and job topic
-    #########################################################################
-
-    def topic(self) :
-        """Return the active topic identifier"""
-        return self.__topic
-
-
-    def jobtopic(self) :
-        """Return the active job topic identifier"""
-        return self.__jobtopic
-
-
-    #########################################################################
-    # Values related to the FVT regression tools
-    #########################################################################
-
-    def api_version_override(self) :
-        """Return the API version value from the command line"""
-        return self.__api_version_override
-
-    def get_properties(self) :
-        """Return the OPTION_GET_PROPERTIES setting"""
-        return self.__get_properties
-    def check_properties(self) :
-        """Return the OPTION_CHECK_PROPERTIES setting"""
-        return self.__check_properties
-    def run_if_applicable(self) :
-        """Return the OPTION_RUN_IF_APPLICABLE setting"""
-        return self.__run_if_applicable
-
-    def required_version(self) :
-        """Return the testcase required_version"""
-        return self.__required_version
-
-    def required_capabilities(self) :
-        """Return the testcase required_capabilities"""
-        return self.__required_capabilities
-    def required_components(self) :
-        """Return the testcase required_components"""
-        return self.__required_components
-    def required_scenario_types(self) :
-        """Return the testcase required_scenario_types"""
-        return self.__required_scenario_types
-    def required_execution_types(self) :
-        """Return the testcase required_execution_types"""
-        return self.__required_execution_types
-
-
-    #########################################################################
-    # API Version
-    #########################################################################
-
-    def api_version(self) :
-        """Return the reported API version supported by the HMC"""
-        return self.__api_version
-
-
-    #########################################################################
-    # API Features
-    #########################################################################
-
-    def api_features(self) :
-        """Return the reported API features supported by the HMC"""
-        return self.__api_features
-
-
-    #########################################################################
-    # HMC Name
-    #########################################################################
-
-    def hmc_name(self) :
-        """Return the name of the connected HMC"""
-        return self.__hmc_name
-
-
-    #########################################################################
-    # HMC Version
-    #########################################################################
-
-    def hmc_version(self) :
-        """Return the version of the connected HMC"""
-        return self.__hmc_version
-
-
-    #########################################################################
-    # Register and start receiving general notification messages
-    #########################################################################
-
-    def start_receiving_messages(self, callback=None) :
-        # print "in start_receiving_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
-        self.start_message_consumer(self.__topic, callback)  # Start receiving messages for the general notification topic
-
-
-    #########################################################################
-    # Register and start receiving job notification messages
-    #########################################################################
-
-    def start_receiving_job_messages(self, callback=None) :
-        # print "in start_receiving_job_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
-        self.start_message_consumer(self.__jobtopic, callback)  # Start receiving messages for the job notification topic
-
-
-    #########################################################################
-    # Register and start receiving audit log notification messages
-    #########################################################################
-
-    def start_receiving_audit_messages(self, callback=None) :
-        # print "in start_receiving_audit_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
-        topic = get_notification_topic(self, 'audit')  # Get the topic name and make sure user is authorized to connect to it
-        if topic == None:  # User is not authorized to connect to this topic
-            raise ApiException('The API user is not authorized to connect to the audit notification topic')
-        self.start_message_consumer(topic, callback)  # Start receiving messages for the audit notification topic
-
-
-    #########################################################################
-    # Register and start receiving security log notification messages
-    #########################################################################
-
-    def start_receiving_security_messages(self, callback=None) :
-        # print "in start_receiving_security_messages(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
-        topic = get_notification_topic(self, 'security')  # Get the topic name and make sure user is authorized to connect to it
-        if topic == None:  # User is not authorized to connect to this topic
-            raise ApiException('The API user is not authorized to connect to the security notification topic')
-        self.start_message_consumer(topic, callback)  # Start receiving messages for the security notification topic
-
-
-    #########################################################################
-    # Register and start receiving messages for the specified topic
-    #########################################################################
-
-    def start_message_consumer(self, topic, callback=None) :
-        try :
-            # print "in start_message_consumer(); amq_client=" + str(self.__amq_client)+ "; port=" + str(self.__amq_port)
-
-            if (self.__amq_client == AMQ_CLIENT_PYACTIVEMQ):  # Use PyActiveMQ ActiveMQ consumer.  It supports only non-SSL connections
-                if pyactivemq_present == False:
-                    raise ApiFatalException("Cannot use PyActiveMQ ActiveMQ client - pyactivemq module is not installed")
-                self.__consumer = PyActiveMQ_Consumer(self.__host,
-                                            self.__amq_port,
-                                            self.__user,
-                                            self.__pass,
-                                            topic,
-                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
-                                            callback)
-            else:  # Use STOMP ActiveMQ consumer.  It supports both SSL and non-SSL connections
-                if stomp_present == False:
-                    raise ApiFatalException("Cannot use STOMP ActiveMQ client - stomp module is not installed")
-                self.__consumer = STOMP_Consumer(self.__host,
-                                            self.__amq_port,
-                                            self.__user,
-                                            self.__pass,
-                                            topic,
-                                            (True if self.__amq_socket_type == SOCKET_TYPE_SSL else False),
-                                            callback)
-
-            # print "About to start() the message consumer"
-            self.__consumer.start()
-        except :
-            raise ApiFatalException(sys.exc_info()[1].args)
-
-
-
-    #########################################################################
-    # Stop receiving notification messages
-    #########################################################################
-
-    def stop_receiving_messages(self) :
-        self.__consumer.stop()
-
-
-    #########################################################################
-    # Determine whether any notification messages have been received
-    #########################################################################
-
-    def has_messages(self) :
-        return self.__consumer.has_messages()
-
-    #########################################################################
-    # Retrieve existing notification messages ... empty message queue
-    #########################################################################
-
-    def get_received_messages(self) :
-        return self.__consumer.get_messages()
-
-
-    #########################################################################
-    # Retrieve raw notification messages ... empty message queue
-    # Should be used for debug only ...
-    #########################################################################
-
-    def get_raw_messages(self) :
-        return self.__consumer.get_raw_messages()
-
-
-    #########################################################################
-    #
-    # __executeRequest (package private method)
-    #
-    # This method is private to the class and NOT called directly.
-    #
-    # Currently, the supported content types are :
-    #
-    #    None and 'application/json'
-    #
-    # Specify return_full_response=False to prevent this method from reading
-    # response body and closing the HTTP(S) connection.  This allows the
-    # caller to read the response as it sees fit, for example, one byte at a
-    # time.  In this case, the caller is responsible for closing the HTTP(S)
-    # connection.  The read_response_streamed method in this class can be used
-    # to read the response body one byte at a time and then close the connection.
-    #
-    #########################################################################
-
-    def __executeRequest(self, operation, uri, body, content, headers=None, return_full_response=True) :
-
-        """Execute an HTTP request"""
-
-        request = None
-        response = None
-
-        try :
-
-            # Build up the default HTTP headers
-            if headers is None :
-                requestHeaders = {}
-                requestHeaders[ 'Accept' ] = '*/*'
-                if content in WSA_SUPPORTED_CONTENT :
-                    requestHeaders[ WSA_HEADER_CONTENT ] = content
-                if body is not None :
-                    requestHeaders[ WSA_HEADER_CONTENT_LENGTH ] = len(body)
-                if self.__session is not None :
-                    requestHeaders[ WSA_HEADER_RQ_SESSION ] = self.__session
-            else :
-                requestHeaders = headers.copy()
-
-            request = Request(operation, uri, requestHeaders, body)
-
-            # **MHB**
-            # Persistent connections, both SSL and non-SSL, are being closed after sitting
-            # idle for 15-30 seconds.  As a workaround, create a new HTTP connection for
-            # each request until a solution can be found ...
-            if self.__port == WSA_PORT_SSL :
-                # Beginning with Python 2.7.9, SSL connections are more secure and require a valid
-                # X509 certificate signed by a trusted CA.  Since the HMC uses a self-signed certificate,
-                # we revert to previous Python behavior by explicitly requesting an unverified context.
-                # This is generally not advisable, for obvious reasons, but it is acceptable in the
-                # development and test environments in which these API test utilities are intended to
-                # be used.
-                if sys.hexversion < 0x020709F0:  # Prior to 2.7.9; use default behavior
-                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port)
-                else:  # 2.7.9 or later; specifically request prior behavior
-                    self.__connection = httplib.HTTPSConnection(self.__host, self.__port, context=ssl._create_unverified_context())
-                    print ""
-                    
-            else :
-                self.__connection = httplib.HTTPConnection(self.__host, self.__port)
-
-            try :
-                self.__connection.request(operation, uri, body, requestHeaders)
-                response = self.__connection.getresponse()
-                # If we're returning the full Response object, then read the response body and construct a Response object;
-                # otherwise, we just return the response from the HTTP(S)Connection object.
-                if return_full_response is True :
-                    result = Response(response.status, response.reason, response.getheaders(), response.read(), request)
-                else :
-                    result = response
-            finally :
-                # If we're returning the full Response object, then we've already read the response and can close out HTTP(S) connection.
-                # Otherwise, leave it open for later reading by, for example, read_response_streamed().  Callers that specify
-                # return_full_response=False are responsible for closing this connection.
-                if return_full_response is True :
-                    self.__connection.close()
-
-        except (ApiFatalException, ApiFatalException) :
-            raise
-        except :
-            text = self.buildExceptionMessage()
-            raise ApiFatalException(text, response=response, traceback=sys.exc_info()[2])
-
-        return result
-
-
-    def buildExceptionMessage(self) :
-        name = sys.exc_info()[0]
-        args = []
-        for arg in sys.exc_info()[1].args :
-            if len(str(arg)) > 0 :
-                args.append(arg)
-                args.append(' ')
-        text = ''.join([ str(s) for s in args ]).strip()
-        return str(name) + ' ' + text
-
-
-    #########################################################################
-    #
-    # read_response_streamed method
-    #
-    # Use this method to read the response to a request that was issued via
-    # __executeRequest with return_full_response==False.  This method will
-    # read the response one byte at a time and then close the connection.
-    #
-    # The response argument is the response as returned from
-    # self.__connection.getresponse().
-    #
-    #########################################################################
-
-    def read_response_streamed(self, response):
-        try :
-            print "\nAbout to read the response one byte at a time...\n"
-            responseString = ""
-            chunk = response.read(1)
-            while (chunk != ""):
-                responseString += chunk
-                sys.stdout.write(chunk)
-                chunk = response.read(1)
-
-        finally :
-            self.__connection.close()
-
-        return responseString
-
-
-#############################################################################
-#
-# Class PyActiveMQ_Consumer - Private class ... do not use directly ...
-#
-# This class sets up an ActiveMQ message consumer using a PyActiveMQ client.
-#
-# It requires a callback function that will be invoked upon receiving each
-# new message from the ActiveMQ server.  The callback function takes exactly
-# two arguments, the topic registered when the Consumer is created and the
-# incoming message from the server.
-#
-# Typical usage :
-#
-#    Create a Consumer object.
-#    Call Consumer.start to begin consuming messages.
-#    Cause one or more notification events to fire.
-#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
-#    Verify the accuracy of the notification messages.
-#
-#############################################################################
-
-class PyActiveMQ_Consumer() :
-    # Only define the internals of this class if PyActiveMQ is installed, due to references to the pyactivemq module
-    if (pyactivemq_present == True):
-        """Private class ... do not use directly"""
-
-        class __MessageListener(pyactivemq.MessageListener):
-
-            def __init__(self, topic, callback):
-                pyactivemq.MessageListener.__init__(self)
-                self.topic = topic
-                self.callback = callback
-
-            def onMessage(self, message):
-                try :
-                    self.callback(self.topic, message)
-                except :
-                    print traceback.print_exc()
-
-
-        def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
-
-            """This is the constructor ... all parameters required, exception callback"""
-
-            self.messageLock = threading.Lock()  # Control access to message queue
-
-            self.running = False
-
-            self.host = host
-            self.port = port
-            self.username = username
-            self.password = password
-            self.topic = topic
-            self.use_ssl = use_ssl
-
-            if callback is None :
-                self.callback = self.__callback
-                self.messages = []
-                self.raw_messages = []
-            else :
-                self.callback = callback
-
-            self.url = 'tcp://' + str(self.host) + ':' + str(self.port)
-
-            self.factory = pyactivemq.ActiveMQConnectionFactory(self.url)
-            self.factory.username = self.username;
-            self.factory.password = self.password;
-            print("Creating PyActiveMQ consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
-            self.connection = self.factory.createConnection()
-            self.session = self.connection.createSession()
-            self.consumer = self.session.createConsumer(self.session.createTopic(self.topic), "")
-            self.listener = self.__MessageListener(self.topic, self.callback)
-            self.consumer.messageListener = self.listener
-
-
-        def start(self) :
-            """Start consuming messages from the ActiveMQ server.  Returns immediately"""
-            self.connection.start()
-
-
-            self.running = True
-
-        def stop(self) :
-            """Stop consuming messages from the ActiveMQ server"""
-            time.sleep(2)
-
-            self.connection.close()
-            self.running = False
-
-        def isRunning(self) :
-            """Connection still active?"""
-            return self.running
-
-        def has_messages(self) :
-            """Test whether any messages have been received"""
-            self.messageLock.acquire()
-            try :
-                return len(self.messages) > 0
-            finally :
-                self.messageLock.release()
-
-        def get_messages(self) :
-            """Get the current list of received messages ... the list is cleared"""
-            self.messageLock.acquire()
-            try :
-                result = list(self.messages)
-                self.messages = []
-                return result
-            finally :
-                self.messageLock.release()
-
-        def get_raw_messages(self) :
-            """Get the list of raw messges received so far ... the list is cleared"""
-            self.messageLock.acquire()
-            try :
-                result = list(self.raw_messages)
-                self.raw_messages = []
-                return result
-            finally :
-                self.messageLock.release()
-
-        def __toDictionary(self, message) :
-            """Convert a raw message to a dictionary"""
-            if message is None : return None
-
-            result = {}
-            result[ 'expiration' ] = message.expiration
-            result[ 'timestamp'  ] = message.timestamp
-            result[ 'text'       ] = message.text if len(message.text) > 0 else None
-
-            # Fetch each property in the message and put it into the dictionary.  Treat each
-            # property as a string, unless specifically identified otherwise.  Use the 
-            # appropriate getXXXProperty() method to fetch the value from the raw message.
-            for property in message.propertyNames :
-                string_type = True  # Assume a standard string type, not handled yet
-                # See if this is one of the non-string properties
-                for property_name, property_type in nonstring_message_properties:
-                    if not string_type:  # Known not to be a string; already handled
-                        break
-                    if property == property_name:  # Some non-string type; handle specially
-                        # ##print "Fetching " + property_name + " as type " + property_type
-                        if property_type == 'long':
-                            try:
-                                result[ property ] = message.getLongProperty(property)
-                                string_type = False  # Non-string type; handled
-                            except :  # Failed conversion; ignore and leave it as a string...
-                                print "\n********** error fetching '" + property + "' property as type " + property_type + " from incoming notification message! ***********"
-                                print "Treating it as type string\n"
-                                traceback.print_exc()
-                                # (Allow this code path to continue and attempt to fetch it as a string...)
-                if string_type:
-                    try :
-                        # ##print "Fetching " + property_name + " as type string"
-                        result[ property ] = message.getStringProperty(property)
-                    except :
-                        print "\n********** error fetching '" + property + "' property as type string from incoming notification message! ***********\n"
-                        traceback.print_exc()
-                        result[ property ] = None
-
-                # ##print "property name: " + property + "; value=" + str(result[property]) + "; type=" + str(type(result[property]))
-
-            return result
-
-        def __callback(self, topic, message) :
-            """The default callback method to receive incoming messages"""
-            self.messageLock.acquire()
-            try :
-                if message is not None :
-                    self.messages.append(self.__toDictionary(message))
-                    self.raw_messages.append(message)
-            finally :
-                self.messageLock.release()
-
-        def __execute(self, connection) :
-            """Start listening for messages - deprecated"""
-            try :
-                self.running = True
-                connection.start()
-                while self.running :
-                    time.sleep(1)
-            finally :
-                self.running = False
-                connection.close()
-
-
-#############################################################################
-#
-# Class STOMP_Consumer - Private class ... do not use directly ...
-#
-# This class sets up an ActiveMQ message consumer using a STOMP client.
-#
-# It requires a callback function that will be invoked upon receiving each
-# new message from the ActiveMQ server.  The callback function takes exactly
-# two arguments, the topic registered when the Consumer is created and the
-# incoming message from the server.
-#
-# Typical usage :
-#
-#    Create a Consumer object.
-#    Call Consumer.start to begin consuming messages.
-#    Cause one or more notification events to fire.
-#    Loop on Consumer.isRunning to wait for consumer thread to timeout.
-#    Verify the accuracy of the notification messages.
-#
-#############################################################################
-
-class STOMP_Consumer() :
-    """Private class ... do not use directly"""
-
-    class __STOMPInternalListener():
-
-            def __init__(self, topic, callback):
-                self.callback = callback
-                self.topic = topic
-
-            def on_connecting(self, host_and_port):
-
-                print "Started connecting to broker..."
-
-            def on_connected(self, headers, message):
-
-                print "Now connected to broker: %s" % message
-
-            def on_disconnected(self, headers, message):
-
-                print "No longer connected to broker: %s" % message
-
-            def on_error(self, headers, message):
-
-                print "Received an error: %s" % message
-
-            def on_message(self, headers, message):
-                # This method processes an HMC APi notificaiton message which
-                # always have header fields, and may optionally contain a body
-                # that is a string containing a JSON object.
-
-                try :
-                    # print "inside on_message block"
-                    # print "H is", headers
-                    # print "M is",message
-                    
-                    # If this is a Property Change notification or a Status Change notification, put the body into
-                    # a header named 'text'.  That's where PyActiveMQ puts it, and this hides that difference from
-                    # other places in our Test utilities and the testcase programs themselves.
-                    if (headers['notification-type'] == 'property-change' or headers['notification-type'] == 'status-change' or headers['notification-type'] == 'log-entry'):
-                        headers['text'] = message
-
-                    self.callback(self.topic, headers)
-                except :
-                    print traceback.print_exc()
-
-
-
-
-    def __init__(self, host, port, username, password, topic, use_ssl, callback=None) :
-
-        """This is the constructor ... all parameters required, exception callback"""
-
-        self.messageLock = threading.Lock()  # Control access to message queue
-
-        self.running = False
-
-        self.host = host
-        self.port = port
-        self.username = username
-        self.password = password
-        self.topic = topic
-        self.use_ssl = use_ssl
-
-        if callback is None :
-            self.callback = self.__callback
-            self.messages = []
-            self.raw_messages = []
-        else :
-            self.callback = callback
-
-        self._dest = "/topic/" + self.topic
-        print("Creating STOMP consumer over " + ("SSL" if self.use_ssl is True else "non-SSL") + " socket " + (str(port)) + " to %s for topic %s" % (self.host, self.topic))
-        self.connection = stomp.Connection([(self.host, self.port)], self.username,
-                                            self.password, use_ssl=self.use_ssl,
-                                            ssl_version=ssl.PROTOCOL_SSLv23)
-
-        self._internal_listener = self.__STOMPInternalListener(self.topic, self.callback)
-        self.connection.set_listener('', self._internal_listener)
-
-
-    def start(self) :
-        """Start consuming messages from the ActiveMQ server.  Returns immediately"""
-        self.connection.start()
-        self.connection.connect(wait=True)
-        time.sleep(10)
-        self.connection.subscribe(destination=self._dest, ack="auto")
-
-        self.running = True
-
-    def stop(self) :
-        """Stop consuming messages from the ActiveMQ server"""
-        time.sleep(2)
-
-        self.connection.stop()
-        self.running = False
-
-    def isRunning(self) :
-        """Connection still active?"""
-        return self.running
-
-    def has_messages(self) :
-        """Test whether any messages have been received"""
-        self.messageLock.acquire()
-        try :
-            return len(self.messages) > 0
-        finally :
-            self.messageLock.release()
-
-    def get_messages(self) :
-        """Get the current list of received messages ... the list is cleared"""
-        self.messageLock.acquire()
-        try :
-            result = list(self.messages)
-            self.messages = []
-            return result
-        finally :
-            self.messageLock.release()
-
-    def get_raw_messages(self) :
-        """Get the list of raw messges received so far ... the list is cleared"""
-        self.messageLock.acquire()
-        try :
-            result = list(self.raw_messages)
-            self.raw_messages = []
-            return result
-        finally :
-            self.messageLock.release()
-
-    def __toDictionary(self, message) :
-        """Convert a raw message to a dictionary"""
-        if message is None : return None
-        result = message
-        return result
-
-    def __callback(self, topic, message) :
-        """The default callback method to receive incoming messages"""
-        self.messageLock.acquire()
-        try :
-            if message is not None :
-
-                # Regardless of the type specified by the HMC code that builds the JMS message, 
-                # the properties always seem to arrive as strings.  Convert the non-string
-                # properties to their proper type here.
-                for property_name, property_type in nonstring_message_properties:
-                    try:
-                        if property_type == 'long':
-                            # ##print "Converting " + property_name + " to " + property_type
-                            message[property_name] = long(message[property_name])
-                    except ValueError:  # Failed conversion; ignore and leave it as a string...
-                        print "\n********** error converting '" + property_name + "' property to type " + property_type + " from incoming notification message! ***********"
-                        print "Leaving it as type " + str(type(message[property_name])) + "\n"
-
-                self.messages.append(self.__toDictionary(message))
-                self.raw_messages.append(message)
-        finally :
-            self.messageLock.release()
-
-    def __execute(self, connection) :
-        """Start listening for messages - deprecated"""
-        try :
-            self.running = True
-            connection.start()
-            while self.running :
-                time.sleep(1)
-        finally :
-            self.running = False
-            connection.close()
-
-#############################################################################
-# Miscellaneous Functions
-#############################################################################
-
-#############################################################################
-#
-# Function parse_standard_options
-#
-# Parses command line options
-#
-# Standard options available to all testcases are :
-#
-#    --addr = IP address of the target HMC
-#    --port = Port number to connect to on the target HMC
-#    --user = Logon userid to use on the target HMC
-#    --pass = Logon password to use on the target HMC
-#    --amq-client = ActiveMQ client to use for notification messages
-#    --amq-socket-type = Type of socket to use for ActiveMQ messages; either ssl or non-ssl
-#    --api-version = Version of the API being tested.  Use this to override the version 
-#                    information reported by the API framework.
-#    
-#    These options are provided primarily to support the FVT regression testing tools.  They are
-#    available to all testcases:
-#    --get-properties = a request to return the testcase's properties
-#    --check-properties = a request to check the testcase's properties against the specified required properties
-#    --run-if-applicable = a request to check the testcase's properties and then run the testcase if all requirements are met
-#    --min-version = required minimum version
-#    --max-version = required maximum version
-#    --capability = required capability; may be specified multiple times
-#    --component = required component; may be specified multiple times
-#    --scenario  = required scenario type; may be specified multiple times
-#    --execution-type = required execution type; may be specified multiple times
-#
-# NOTE : Currently, if ommitted, these values will default to :
-#
-#    Logon to R32 HMC ( 9.60.15.48 ) on the default WSA SSL port with user ensadmin
-#    An ActiveMQ client is chosen based on what is installed; STOMP over SSL is preferred.
-#
-# The additional_options argument may be used to define any additional command
-# line options to be permitted.  It is a list of Option objects created via
-# the make_option() function in the optparse library.  For example:
-#     additional_opts = [
-#         make_option("--srname", dest="storage_resource_name", type="string", default="tempSR", help='The name of the storage resource to be created.  Default is %default.'),
-#         make_option("--count", dest="iteration_count", metavar="COUNT", type="int", help='The number of iterations to run'),
-#         make_option("--treat", dest="dessert", type="choice", choices=["candy", "soda", "fudge"], help='Your dessert choice')
-#         make_option("--verbose", "-v", dest="verbose", action="store_true", default=False, help="Specify this option to get lots of output.  Default is %default."),
-#         ]
-#         
-# Those option definitions are then passed to session_startup():
-#       # Create a session and parse the command line, including our additional options
-#       session = session_startup(additional_options=additional_opts)
-#
-# Note that it is permissible to override any of the standard options by specifying them in additional_options.
-#
-# If the testcase script defines any positional arguments, their Usage information
-# should be specified on the additional_arguments_usage_info argument.  For example,
-#      my_args_usage_info = "property_name timeout_seconds"
-#
-# To see the usage and help information on the command line, issue:
-#         "<script_name> -h" or "<script_name> --help"
-#               
-# Note that this method uses os._exit(rc) in some cases rather than the more
-# common sys.exit(rc).  os._exit(rc) makes a quick exit from the testcase
-# script without raising any exception, including SystemExit.  This makes
-# for a cleaner exit sequence in these special situations.  Note, however,
-# that it also bypasses any finally block; this should be OK, since no
-# session has been created yet and there is most likely no resource cleanup
-# necessary at this point in testcase execution.
-#
-#############################################################################
-
-def parse_standard_options(additional_options=None, additional_arguments_usage_info=None) :
-    # Define the standard options
-    option_list = [
-       make_option(OPTION_ADDR, dest='host', type='string', default=DEFAULT_ADDR,
-           help='The IP address or hostname of the target HMC.  Default=%default'),
-       make_option(OPTION_PORT, dest='port', type='int', default=DEFAULT_PORT,
-           help='The TCP/IP port number on which to connect to the target HMC for Web Services API requests.  Default=%default'),
-       make_option(OPTION_USER, dest=OPTION_USER_DEST, type='string', default=WSA_DEFAULT_USERID,
-           help='The HMC userid to use for the API request.  Default=%default'),
-       make_option(OPTION_PASS, dest=OPTION_PASS_DEST, type='string', default=WSA_DEFAULT_PASSWORD,
-           help='The login password for the HMC userid to use for the API request.  Default is the default user\'s standard password.'),
-       make_option('--amq-client', dest='amq_client', type='choice', choices=[AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP],
-           help='ActiveMQ client: %s or %s.  Default is %s unless it is not installed and %s is installed.'
-               % (AMQ_CLIENT_PYACTIVEMQ, AMQ_CLIENT_STOMP, AMQ_CLIENT_STOMP, AMQ_CLIENT_PYACTIVEMQ)),
-       make_option('--amq-socket-type', dest='amq_socket_type', type='choice', choices=[SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL],
-           help='ActiveMQ socket type: %s or %s.  Default depends on the ActiveMQ client: %s for %s; %s for %s.'
-               % (SOCKET_TYPE_SSL, SOCKET_TYPE_NON_SSL, SOCKET_TYPE_SSL, AMQ_CLIENT_STOMP, SOCKET_TYPE_NON_SSL, AMQ_CLIENT_PYACTIVEMQ)),
-       make_option(OPTION_API_VERSION, dest='api_version_override', metavar='API_VERSION', type='string',
-           help='The version information for the API implementation being tested.  Specify this to override the version level reported by the API framework on the target HMC.'),
-       # for force tags
-       make_option("--include", type='string', default=""),
-       make_option("--exclude", type='string', default=""),
-       make_option("--variablefile", type='string', default=""),
-       make_option("--outputdir", type='string', default=""),
-        
-       ]
-
-    # Define our usage statement
-    usage_info = "%prog [options]"  # There are no standard command line arguments, only options
-
-    # Add any additional testcase-specific options
-    if additional_options is not None:
-        option_list.extend(additional_options)
-    
-
-    # Add any additional testcase-specific usage information
-    if additional_arguments_usage_info is not None:
-        usage_info += " " + additional_arguments_usage_info
-    # Create a parser with the options
-    parser = optparse.OptionParser(option_list=option_list, usage=usage_info, conflict_handler="resolve")
-
-    # Define a group of options intended for use by the FVT regression bucket and then add the specific option definitions to the group.
-    # This group will appear separate from the other command line options in the usage and help information.
-    FVT_option_group = OptionGroup(parser, 'Function Verification Test (FVT) regression test options', 'These options are intended primarily for use by the FVT regression tools.'
-        + '  Only one of %s, %s or %s may be specified.' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
-        + '  Some options may each be specified more than once.  If so, a testcase need only support one of the specified values in order to satisfy that requirement.'
-        + '  These options are: %s, %s, %s and %s' % (OPTION_CAPABILITY, OPTION_COMPONENT, OPTION_SCENARIO, OPTION_EXECUTION_TYPE))
-    
-    # The type of operation to perform.  Only 1 of these should be specified.
-    FVT_option_group.add_option(make_option(OPTION_GET_PROPERTIES, dest='get_properties', action='store_true', default=False,
-        help='Denotes a request to return the testcase properties.  These are defined by the %s variable in the testcase source code.' % TESTCASE_PROPERTIES_VARIABLE_NAME))
-    FVT_option_group.add_option(make_option(OPTION_CHECK_PROPERTIES, dest='check_properties', action='store_true', default=False,
-        help='Denotes a request to check testcase properties against the required testcase properties specified on the command line.'))
-    FVT_option_group.add_option(make_option(OPTION_RUN_IF_APPLICABLE, dest='run_if_applicable', metavar='APPLICABLE', action='store_true', default=False,
-        help='Denotes a request to check properties as if %s were specified and then, if the testcase meets the specified requirements, actually execute the testcase.' % OPTION_CHECK_PROPERTIES))
-    # Required API version
-    FVT_option_group.add_option(make_option(OPTION_REQUIRED_VERSION, dest='required_version', metavar='VERSION', type='choice', choices=TC_API_VERSION_LIST,
-        help='A required testcase property: the required API version.  The testcase must support this API level.'
-             '  That is, this level must be between the testcase\'s supported minimum and maximum levels, inclusive.  Valid values are: %s' % TC_API_VERSION_LIST))
-    # Testcase properties that can have multiple values.  If a property is specified more than once on the command line, a testcase is
-    # considered to meet that criterion if it includes at least one of the specified values.  That is, they are logically OR'd together.
-    # Then the different properties are AND'd together.
-    FVT_option_group.add_option(make_option(OPTION_CAPABILITY, dest='required_capabilities', metavar='CAPABILITY', action='append', choices=TC_CAPABILITY_LIST,
-        help='A required testcase property: a capability.  May be specified multiple times.  Valid values are: %s' % TC_CAPABILITY_LIST))
-    FVT_option_group.add_option(make_option(OPTION_COMPONENT, dest='required_components', metavar='COMPONENT', action='append', choices=TC_COMPONENT_LIST,
-        help='A required testcase property: a component.  May be specified multiple times.  Valid values are: %s' % TC_COMPONENT_LIST))
-    FVT_option_group.add_option(make_option(OPTION_SCENARIO, dest='required_scenario_types', metavar='SCENARIO_TYPE', action='append', choices=TC_SCENARIO_TYPE_LIST,
-        help='A required testcase property: a scenario.  May be specified multiple times.  Valid values are: %s' % TC_SCENARIO_TYPE_LIST))
-    FVT_option_group.add_option(make_option(OPTION_EXECUTION_TYPE, dest='required_execution_types', metavar='EXECUTION_TYPE', action='append', choices=TC_EXECUTION_TYPE_LIST,
-        help='A required testcase property: an execution type.  May be specified multiple times.  Valid values are: %s' % TC_EXECUTION_TYPE_LIST))
-
-    # Add the group of FVT regression bucket options
-    parser.add_option_group(FVT_option_group)
-
-    (opts, args) = parser.parse_args()
-
-    #
-    # The command line options have been parsed and validated.  Some of them will be handled
-    # here.  These are the FVT regression run options.  Individual testcases don't even need
-    # to know that these options exist.  Handle them and then exit the testcase directly (not
-    # even "finally:" blocks are executed).  If none of these special options was specified,
-    # return the option and argument collections to the caller for handling of the other
-    # options and arguments, if any.
-    #
-
-    # Determine and validate the type of request specified on the command line, if any
-    get_properties_request = opts.get_properties
-    check_properties_request = opts.check_properties
-    run_if_applicable_request = opts.run_if_applicable
-    option_count = ((1 if get_properties_request else 0)
-                  + (1 if check_properties_request else 0)
-                  + (1 if run_if_applicable_request else 0))
-
-    if (option_count > 1):  # Only 0 (they're all optional) or 1 of these options may be specified at a time
-        print 'At most 1 of the following options may be specified: %s, %s, %s' % (OPTION_GET_PROPERTIES, OPTION_CHECK_PROPERTIES, OPTION_RUN_IF_APPLICABLE)
-        os._exit(WSA_EXIT_INVALID_COMMAND_LINE)  # Make a direct exit
-
-    # Fetch the testcase properties from the testcase source code itself
-    testcase_props = getattr(__main__, TESTCASE_PROPERTIES_VARIABLE_NAME, None)
-
-    # Certain requests need the testcase properties.  Make sure they are defined.
-    if get_properties_request or check_properties_request or run_if_applicable_request:
-        if testcase_props is None:
-            print "The testcase source code does not define the %s variable" % TESTCASE_PROPERTIES_VARIABLE_NAME
-            os._exit(WSA_EXIT_MISSING_TESTCASE_PROPERTIES)  # Make a direct exit
-
-    # Handle a request to display the testcase properties
-    if get_properties_request:
-        print GET_PROPERTIES_BEGIN_MARKER
-        print "%s=\n%s" % (TESTCASE_PROPERTIES_VARIABLE_NAME, pprint.pformat(testcase_props))
-        print GET_PROPERTIES_END_MARKER
-        os._exit(WSA_EXIT_GET_PROPERTIES_SUCCESS)  # Make a direct exit
-
-    # Handle requests that need to check the testcase properties against the required properties.
-    if check_properties_request or run_if_applicable_request:
-        # Check all simple string properties.  Some may have been specified multiple times on the command line.
-        properties_to_check = [(testcase_props, TC_CAPABILITIES, opts.required_capabilities),
-                               (testcase_props, TC_COMPONENT, opts.required_components),
-                               (testcase_props, TC_SCENARIO_TYPE, opts.required_scenario_types),
-                               (testcase_props, TC_EXECUTION_TYPE, opts.required_execution_types),
-                              ]
-
-        for property in properties_to_check:
-            # print 'checking %s' % property[1]
-            if check_testcase_requirement(property[0], property[1], property[2]) is False:
-                print "The testcase does not support any required value for the '%s' property, supplied values are " % (property[1]), (property[2])
-                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Doesn't meet this requirement, so exit.  Make a direct exit.
-    
-        # If a required API version was specified, check it now by making sure it is within the
-        # range defined by the testcase's minimum supported version and its maximum supported version
-        # (if defined).  First make sure its minimum supported version is <= the requirement.
-        required_version = opts.required_version
-        if required_version is not None:
-            if TC_MINIMUM_API_VERSION not in testcase_props.keys():
-                print "The testcase properties do not define the %s property" % (TC_MINIMUM_API_VERSION)
-                os._exit(WSA_EXIT_PROPERTY_NOT_DEFINED)  # Make a direct exit
-
-            available_minimum_version = testcase_props[TC_MINIMUM_API_VERSION]  # Get the value of this testcase property
-            # print "required & supported min versions: %s, %s" % (required_version, available_minimum_version)
-            # if required_minimum_version < available_minimum_version:
-            if not is_version_at_most(required_version, available_minimum_version):  # required < supported min
-                print "The testcase does not support the %s required API version; the testcase supports a minimum version of %s" % (required_version, available_minimum_version)
-                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
-
-        # If a required maximum version was specified and the testcase provides it, check it now.  This is
-        # an optional property that is not expected to be used very often.  It is intended to denote a
-        # testcase that has become obsolete at a certain API level.  Make sure the testcase's maximum
-        # supported version is >= the requirement.
-        if required_version is not None and TC_MAXIMUM_API_VERSION in testcase_props.keys():
-            available_maximum_version = testcase_props[TC_MAXIMUM_API_VERSION]  # Get the value if this testcase property
-            # print "required & supported max versions: %s, %s" % (required_maximum_version, available_maximum_version)
-            # if required_version > available_maximum_version:
-            if not is_version_at_most(available_maximum_version, required_version):  # required > supported max
-                print "The testcase does not support the %s required API version; the testcase supports a maximum version of %s" % (required_version, available_maximum_version)
-                os._exit(WSA_EXIT_REQUIREMENT_NOT_MET)  # Make a direct exit
-
-        # If we're only checking testcase requirements, all requirements are met and we're done!
-        # If this is a run-if-applicable request, all requirements have been met, so continue and
-        # actually execute the testcase.
-        if check_properties_request:   
-            print "The testcase meets the specified requirements"
-            os._exit(WSA_EXIT_CHECK_PROPERTIES_SUCCESS)  # Make a direct exit
-
-    return (opts, args)
-
-
-#############################################################################
-#
-# This method provides a simple method to validate the response from an HTTP
-# request.
-#
-# @param rs - the Response object returned by one of the Session methods,
-#             such as Session.get, for example.
-# @param vm - validation map that can contain on or more of the following:
-#             status       : the expected status code from the operation
-#             content-type : the expected content type in the response
-#             required     : a list of required properties in the
-#                            response body
-#             optional     : a list of optional properties in the
-#                            response body
-#
-# An example validation map :
-#  { 'status':200,
-#    'content-type':'application/json',
-#    'required':[],
-#    'optional':[] }
-#
-# All validation map parameters are optional.  Parameters that are not
-# present in the map will not be used as part of the validation test.
-#
-# @return True is validation is successful, False otherwise
-#
-#############################################################################
-
-def validate_response(rs, vm) :
-
-    if vm is None : return True  # Nothing to validate in this case ...
-
-    if rs is None or not isinstance(rs, Response) :
-        raise ApiFatalException('Response missing or invalid', response=rs)
-
-    # Validate the status
-    if 'status' in vm and rs.status != vm[ 'status' ] :
-        raise ApiException('Invalid status ' + str(rs.status) + ' ' + str(rs.reason), response=rs)
-
-    # Validate the content type
-    content = rs.headers[ WSA_HEADER_CONTENT ] if WSA_HEADER_CONTENT in rs.headers else None
-    if WSA_HEADER_CONTENT in vm :
-        if content is None or not content.startswith(vm[ WSA_HEADER_CONTENT ]) :
-            raise ApiException('Invalid content type ' + str(content), response=rs)
-
-    if content is not None and content.startswith(WSA_CONTENT_JSON) :
-        req = vm[ 'required' ] if 'required' in vm else None
-        opt = vm[ 'optional' ] if 'optional' in vm else None
-        try :
-            validate_dictionary(rs.body, req, opt)
-        except ApiException as exception :
-            exception.response = rs
-            raise exception
-
-    return True
-
-
-
-
-# Verify the response is consistent with No Content (204)
-# @param response Response object
-def validate_no_content_response (response) :
-    print
-    print 'Validating that Response is a proper No Content (204) response'
-    if response.status != 204 :
-        print_response(response)
-        raise Exception('Failed: Expected No Content status 204, got ' + str(response.status))
-    if response.headers.get(WSA_HEADER_CONTENT) != None :
-        print_response(response)
-        raise Exception('Failed: Expected no content-type header for 204 response, got ' + str(response.headers.at(WSA_HEADER_CONTENT)))
-    if (response.body != None) and (response.body != '') and (response.body != '{}') :  # Response object returns {} for no content?
-        print_response(response)
-        raise Exception('Failed: Expected no content in body, got ' + str(response.body))
-# end validate_no_content_response
-
-#############################################################################
-#
-#############################################################################
-
-def validate_dictionary(dict, req, opt) :
-
-    if dict is None or type(dict) is not types.DictType :
-        raise ApiFatalException('Dictionary missing or invalid type')
-
-    if req is None : req = []
-    if opt is None : opt = []
-
-    if req == [] and opt == [] : return True
-
-    allKeys = set(dict.keys())
-    reqKeys = set(req)
-    result = reqKeys.difference(allKeys)
-    if len(result) > 0 :
-        raise ApiException('Missing required keys', keys=sorted(list(result)))
-
-    optKeys = set(opt)
-    result = allKeys.difference(reqKeys).difference(optKeys)
-    if len(result) > 0 :
-        raise ApiException('Extraneous keys found', keys=sorted(list(result)))
-
-    return True
-
-
-#############################################################################
-# Return a list of all ensembles, after first validating the response
-#############################################################################
-
-def list_ensembles(session) :
-    ensembles = None
-    response = session.get(WSA_URI_ENSEMBLES)
-    validate_response(response, WSA_LIST_ENSEMBLES_VALIDATE)
-    for ensemble in response.body[ 'ensembles' ] :
-        validate_dictionary(ensemble, WSA_LIST_ENSEMBLE_REQUIRED, [])
-    return response.body[ 'ensembles' ]
-
-
-#############################################################################
-# Update the ensemble properties 
-# ensemble_uri : the uri of the ensemble to be updated (str)
-# request_body : request body containing the fields to update (dict)
-#############################################################################
-
-def update_ensemble(session, ensemble_uri, request_body):
-    response = None
-    print 'ensemble update body: ' + json.dumps(request_body)
-    response = session.post(ensemble_uri, json.dumps(request_body))
-    print 'Ensemble update response status: ' + str(response.status)
-    return response
-
-
-#############################################################################
-# Return information about the ensemble on the system
-#############################################################################
-
-def get_ensemble_info(session) :
-    print '\nGet the ensemble information'
-    ensembles = list_ensembles(session)
-    if len(ensembles) == 0 :
-        raise Exception('No ensemble defined on system')
-    ensemble_info = ensembles[0]
-    ensemble_uri = ensemble_info['object-uri']
-    print 'Ensemble uri is [' + ensemble_uri + ']'
-    return ensemble_uri, ensemble_info
-
-
-#############################################################################
-# Return all the properties of the specified ensemble
-#############################################################################
-
-def get_ensemble_properties(session, ensemble) :
-    response = session.get(ensemble[ 'object-uri' ])
-    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
-        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
-    else :
-        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
-    return response.body
-
-
-#############################################################################
-# Return all the properties of the ensemble identified by its URI
-#############################################################################
-
-def get_ensemble_properties_by_uri(session, ensemble_uri) :
-    response = session.get(ensemble_uri)
-    if api_effective_version(session) == TC_API_VERSION_ZSPHINX_GA1 :
-        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE_NODES)
-    else :
-        validate_response(response, WSA_GET_ENSEMBLE_VALIDATE)
-    return response.body
-
-
-#############################################################################
-# Return a list of all cpcs, afer first validating the response
-#############################################################################
-
-def list_cpcs(session) :
-    cpcs = None
-    response = session.get(WSA_URI_CPCS)
-    if response.status != 200:
-        raise ApiException("ERROR: status=" + response.status + ", uri=" + WSA_URI_CPCS)
-    strCPCs = str(response)
-    cpcCount = strCPCs.count('object-uri')
-    if cpcCount == 0 :
-        raise ApiException('No cpcs defined on system')
-    validate_response(response, WSA_LIST_CPCS_VALIDATE)
-    for cpc in response.body[ 'cpcs' ] :
-        validate_dictionary(cpc, WSA_LIST_CPC_REQUIRED, [])
-    cpcs = response.body['cpcs']
-    return cpcs
-    
-
-#############################################################################
-# Return either the default CPC or the first cpc found in the operating state
-#############################################################################
-
-def get_operating_cpc(session) :
-    print '\nGet the operating cpc'
-    cpcs = list_cpcs(session)
-    if len(cpcs) == 0 :
-        raise Exception('No cpcs defined on system')
-    # # See how many cpcs we have
-    strCPCs = str(cpcs)
-    n = strCPCs.count('object-uri')
-    cpc_name = ''
-    # # See if we have a default CPC name to find
-    if DEFAULT_CPC_NAME != '' :
-        # # Find the default cpc
-            for i in range(0, n):
-                if (cpcs[i]['name'] == DEFAULT_CPC_NAME) & (cpcs[i]['status'] == 'operating') :
-                    cpc_uri = cpcs[i]['object-uri']
-                    cpc_name = cpcs[i]['name']
-                    print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
-                    break
-    # # If default CPC is not found and operating, look for the first operating CPC
-    if cpc_name == '' :
-        # # Find an operating cpc
-        for i in range(0, n):
-            if (cpcs[i]['status'] == 'operating') :
-                cpc_uri = cpcs[i]['object-uri']
-                cpc_name = cpcs[i]['name']
-                print '------> cpc name: ' + cpc_name + '   uri:  ' + cpc_uri
-                break
-    # # Make sure we found an operating cpc
-    if cpc_name == '' :
-        raise Exception('No operating cpcs defined on system')
-    else :
-        # cpc_uri = cpcs[0]['object-uri']
-        return cpc_uri
-    
-    
-#############################################################################
-# Return either the default CPC or the first cpc found
-#############################################################################
-
-def get_cpc_new(session) :
-    print '\nGet the operating cpc'
-    cpcs = list_cpcs(session)
-    if len(cpcs) == 0 :
-        raise Exception('No cpcs defined on system')
-    targetCpc = None
-    for cpc in cpcs :
-        if cpc['name'] == APA_TESTENV_CPC_UNDER_TEST :
-            targetCpc = cpc
-            break
-    if targetCpc is None :
-        raise ApiFatalException("Unable to find a required CPC, exiting")    
-    cpc_uri = targetCpc['object-uri']
-    return cpc_uri
-
-
-##########################################################################################
-# Return either the default virtualization host or the first found in the operating state
-##########################################################################################
-
-def get_operating_virtualization_host(session, virtualization_hosts) :
-    print '\nGet the operating virtualization host'
-    virtualization_host_name = None
-    for virtualization_host in virtualization_hosts :
-        if virtualization_host[ 'name' ] == DEFAULT_VIRTUALIZATION_HOST_NAME :
-            if  virtualization_host[ 'status' ] == 'operating' :
-                virtualization_host_name = virtualization_host[ 'name' ]
-                break
-    if virtualization_host_name is None :
-        for virtualization_host in virtualization_hosts :
-            if (virtualization_host[ 'status' ] == 'operating') & (virtualization_host[ 'type' ] == 'zvm')  :
-                virtualization_host_name = virtualization_host[ 'name' ]
-                break
-    # # Make sure we found an operating virtualization host
-    if virtualization_host_name is None :
-        raise ApiFatalException('No zvm virtualization host present in the Ensemble or is not in the right state to perform this test')
-    else :
-        return virtualization_host
-
-
-#############################################################################
-# Return a list of virtualization-host-info objects for all virtualization
-# hosts managed by the specified ensemble that match the optional query
-# filter, after first validating the response
-#############################################################################
-
-def list_virtualization_hosts_by_ensemble(session, ensemble_info, query=None) :
-    return list_virtualization_hosts_by_ensemble_uri(session, ensemble_info['object-uri'], query)
-
-
-#############################################################################
-# Return a list of virtualization-host-info objects for all virtualization
-# hosts managed by the specified ensemble that match the optional query
-# filter, after first validating the response
-#############################################################################
-
-def list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=None) :
-    response = None
-    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
-    nodes = response.body['nodes']
-    node_uri = nodes[0]['element-uri']
-    if query is None :
-        response = session.get(node_uri + '/virtualization-hosts')
-    else :
-        response = session.get(node_uri + '/virtualization-hosts?' + query)
-    validate_response(response, WSA_LIST_VIRT_HOSTS_VALIDATE)
-    for host in response.body[ 'virtualization-hosts' ] :
-        validate_dictionary(host, WSA_LIST_VIRT_HOST_REQUIRED, [])
-    return response.body[ 'virtualization-hosts' ]
-
-
-#############################################################################
-# Returns the URI and a virtualization-host-info object for an arbitrary
-# (or specific, if virtualization_host_name is specified) virtualization
-# host of the specified type, managed by the specified ensemble.  Raises
-# an Exception if none is found.
-#############################################################################
-
-def find_virtualization_host(session, virtualization_host_type, ensemble_uri=None, virtualization_host_name=None):
-    print '\nSearching the ensemble for a virtualization_host of type ' + virtualization_host_type
-    typefilter = 'type=%s' % (virtualization_host_type)
-
-    # Get the ensemble name, and uri if not provided
-    if ensemble_uri is None:
-        ensemble_uri, ensemble_info = get_ensemble_info(session)
-        ensemble_name = ensemble_info['name']
-    else:
-        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
-        ensemble_name = ensemble_properties['name']
-    
-    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, 'name=ZBX51.*&'+typefilter)
-    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
-    nodes = response.body['nodes']
-    if len(nodes) == 0 :
-        raise Exception('No suitable node (name=' + WSA_DEFAULT_ZBX_NAME + ') is defined in ensemble ' + ensemble_name)
-    node_uri = nodes[0]['element-uri']
-    response = session.get(node_uri + "/virtualization-hosts?" + typefilter)
-    virtualization_hosts = response.body['virtualization-hosts']
-    if len(virtualization_hosts) == 0 :
-        raise Exception('No ' + virtualization_host_type + ' virtualization hosts defined in ensemble ' + ensemble_name)
-
-    # Set the virtualization host name to search for, if any
-    vh_name = None
-    if virtualization_host_name is None:
-        # If we're looking for a zvm virtualization host on the R32 ensemble, restrict Test usage to a specific virtualization host
-        if virtualization_host_type == 'zvm':
-            if ensemble_name == ENSEMBLE_NAME_R32:
-                vh_name = PREFERRED_ZVM_VIRTUALIZATION_HOST_R32
-    else:
-        vh_name = virtualization_host_name
-
-    virtualization_host_info = None  # Assume no appropriate virtualization host will be found
-    if vh_name is None:
-        virtualization_host_info = virtualization_hosts[0]  # Use the first one (arbitrary choice)
-    else:
-        for virtualization_host in virtualization_hosts:  # Iterate over all vh info objects that match the desired vh type
-            if virtualization_host['name'] == vh_name:  # Found it
-                virtualization_host_info = virtualization_host
-        if virtualization_host_info is None:
-            raise Exception('No ' + virtualization_host_type + ' virtualization host with name ' + vh_name + ' is defined in ensemble ' + ensemble_name)
-
-    virtualization_host_uri = virtualization_host_info['object-uri']
-    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
-    return virtualization_host_uri, virtualization_host_info
-
-
-#############################################################################
-# Returns the URI and a virtualization-host-info object for a specified
-# virtualization host managed by the specified ensemble.  Raises
-# an Exception if none is found.
-#############################################################################
-
-def find_virtualization_host_by_name(session, virtualization_host_name, ensemble_uri=None):
-    print '\nSearching the ensemble for a virtualization_host of name ' + virtualization_host_name
-    namefilter = 'name=%s' % (virtualization_host_name)
-
-    # Get the ensemble name, and uri if not provided
-    if ensemble_uri is None:
-        ensemble_uri, ensemble_info = get_ensemble_info(session)
-        ensemble_name = ensemble_info['name']
-    else:
-        ensemble_properties = get_ensemble_properties_by_uri(session, ensemble_uri)
-        ensemble_name = ensemble_properties['name']
-
-    # virtualization_hosts = list_virtualization_hosts_by_ensemble_uri(session, ensemble_uri, query=namefilter)
-    response = session.get(ensemble_uri + "/nodes?name=" + WSA_DEFAULT_ZBX_NAME)
-    nodes = response.body['nodes']
-    node_uri = nodes[0]['element-uri']
-    response = session.get(node_uri + "/virtualization-hosts?" + namefilter)
-    virtualization_hosts = response.body['virtualization-hosts']
-    if len(virtualization_hosts) == 0 :
-        raise Exception('No ' + virtualization_host_name + ' virtualization hosts defined in ensemble ' + ensemble_name)
-
-    virtualization_host_info = virtualization_hosts[0]
-    virtualization_host_uri = virtualization_host_info['object-uri']
-
-    print 'Virtualization host uri is [' + virtualization_host_uri + ']; name is [' + virtualization_host_info['name'] + ']'
-    return virtualization_host_uri, virtualization_host_info
-
-
-#############################################################################
-# Returns the URI of a virtual server object with the specified name owned
-# by the specified virtualization host.  If return_response is True, then
-# the response object is always returned; otherwise, the URI is returned
-# or an exception is raised.
-#############################################################################
-
-def find_virtual_server_in_virtualization_host(session, virtualization_host_uri, virtual_server_name, return_response=False) :
-    # Find the VS within the specified VH
-    response = session.get(virtualization_host_uri + "/virtual-servers?name=" + virtual_server_name)
-    if response.status != 200:
-        msg = "An error occurred fetching virtual server information for the virtualization host"
-        print msg
-        if return_response :
-            return response
-        else :
-            print response
-            raise Exception(msg)
-
-    virtual_servers = response.body["virtual-servers"]
-    if len(virtual_servers) == 0 :
-        msg = "The virtualization host has no virtual server with name " + virtual_server_name
-        print msg
-        if return_response :
-            return response
-        else :
-            print response
-            raise Exception(msg)
-
-    if return_response :
-        return response
-    else :
-        return virtual_servers[0]["object-uri"]
-
-
-#############################################################################
-# Startup method to create session and logon ...
-# Connection parameters (host, port, user, and pwd) should not be overridden
-# by test scripts unless there is an explicit need (eg log in under different
-# users to verify access permission)
-# @param host - IP address of the target HMC (str)
-# @param port - Port number to connection on the target HMC (int)
-# @param user - Logon userid to use on the target HMC (str)
-# @param pwd  - Logon password to use on the target HMC(str)
-# @param additional_options - any additional command line option definitions.
-#               See parse_standard_options() and the Session class for more details.
-#               (list of Option objects created via make_option())
-# @param additional_arguments_usage_info - Usage information for any additional
-#               command line arguments.  See parse_standard_options() and the
-#               Session class for more details. (str)
-# @param amq-client - ActiveMQ client to use for notification messages
-# @param amq-socket-type - Type of socket to use for ActiveMQ messages;
-#               either ssl or non-ssl
-#
-# Note that the Session __init__ method calls parse_standard_options(), which 
-# uses os._exit(rc) in some cases rather than the more common sys.exit(rc).
-# See the prolog of parse_standard_options for more details.
-#############################################################################
-
-#############################################################################
-# Find the object with a given name from a list of objects
-#############################################################################
-def find_object_by_name(session, object_list, object_name) :
-    result = None
-    for obj in object_list :
-        if type(obj['name']) is unicode :
-            obj_name = obj['name'].encode('utf-8')
-        if (obj_name == object_name) :
-            result = obj
-    return result
-
-
-def session_startup(host=None, port=None, user=None, pwd=None, verbose=False, additional_options=None, additional_arguments_usage_info=None, amq_client=None, amq_socket_type=None) :
-    session = Session(host, port, user, pwd, additional_options, additional_arguments_usage_info, amq_client, amq_socket_type)
-
-    # Now open the session by establishing an HTTP connection to the target HMC
-    if verbose :
-        print 'Connecting to', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
-    session.open()
-    if verbose :
-        print 'Session ID: \t%s' % session.session()
-
-    return session
-
-
-#############################################################################
-# Determine if the API version being tested is at least as recent (high) as
-# the specified API version.  The version information for the API implementation
-# being tested comes from the API framework itself (GET /api/version) unless it
-# has been overridden via the --api-version command line option.  The version
-# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
-#
-# This method is intended for use by testcases that test function that was
-# added or changed in an incompatible fashion after the initial API release.
-# The testcase can use this function in order to know what behavior to expect
-# from the API(s) it is testing.
-# 
-# Returns:
-#    True if it is; False otherwise
-#############################################################################
-
-def is_api_version_at_least(session, version_to_check):
-    api_version = api_effective_version(session)
-    # print 'api version = %s' % api_version
-    # return (api_version >= version_to_check)  #??? Need to do a real implementation of this that can handle all valid version formats!  (For example, need to be able to compare "1.2" and "1.12")
-    return is_version_at_least(version_to_check, api_version)
-
-
-# See is_api_version_at_least() above for description
-def is_version_at_least(version_to_check, api_version):
-    # Split each version string into its numeric parts
-    api_version_parts = api_version.split('.')
-    version_to_check_parts = version_to_check.split('.')
-
-    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
-    # a meaningful numeric comparison, so just do a straight string comparison.
-    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
-    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
-        print "is_version_at_least: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
-        return (api_version >= version_to_check)
-
-    # Iterate over the numeric parts of the input version number and compare them to the
-    # corresponding parts of the session's API version number.  Once an inequality is found,
-    # we know which is greater.
-    for i in xrange(len(version_to_check_parts)):
-        version_to_check_part = int(version_to_check_parts[i])
-        if len(api_version_parts) >= i + 1:
-            api_version_part = int(api_version_parts[i])
-        else:  # Not enough parts in api_version; supply a 0
-            api_version_part = 0
-        if version_to_check_part < api_version_part:
-            return True
-        elif version_to_check_part > api_version_part:
-            return False
-        # Equal, need to look at next part, if any
-
-
-    # We checked all of the numeric parts of the input version number without finding
-    # an inequality.  This means that either the versions are completely equal or 
-    # version_to_check has fewer parts, which means that it cannot be greater than
-    # api_version.  Thus it must be <=, so we return True.
-    return True
-
-
-#############################################################################
-# Determine if the API version being tested is exactly the same as
-# the specified API version.  The version information for the API implementation
-# being tested comes from the API framework itself (GET /api/version) unless it
-# has been overridden via the --api-version command line option.
-# 
-# Returns:
-#    True if it is; otherwise, False.
-#############################################################################
-
-def is_api_version_exactly(session, version_to_check):
-    api_version = api_effective_version(session)
-    # print 'api version = %s' % api_version
-    return (api_version == version_to_check)
-
-
-#############################################################################
-# Determine if the API version being tested is at most as recent (high) as
-# the specified API version.  The version information for the API implementation
-# being tested comes from the API framework itself (GET /api/version) unless it
-# has been overridden via the --api-version command line option.  The version
-# strings are expected to be in dotted decimal notation (e.g., '1.1', '1.3.2').
-#
-# This method is intended for use by testcases that test function that was
-# removed or changed in an incompatible fashion at some point.  The testcase
-# can use this function in order to know what behavior to expect from the
-# API(s) it is testing.
-# 
-# Returns:
-#    True if it is; False otherwise
-#############################################################################
-
-def is_api_version_at_most(session, version_to_check):
-    api_version = api_effective_version(session)
-    return is_version_at_most(version_to_check, api_version)
-
-
-# See is_api_version_at_most() above for description
-def is_version_at_most(version_to_check, api_version):
-    # Split each version string into its numeric parts
-    api_version_parts = api_version.split('.')
-    version_to_check_parts = version_to_check.split('.')
-
-    # Make sure both version strings are in dotted decimal format.  If not, we can't perform
-    # a meaningful numeric comparison, so just do a straight string comparison.
-    pattern = '[0-9]+(\.[0-9]+)*$'  # n[.n]*   e.g. '1.2', '2.3.25.7', '2.0'
-    if re.match(pattern, version_to_check) is None or re.match(pattern, api_version) is None:
-        print "is_version_at_most: ill-formed version number; must be dotted decimal format.  Using a simple string comparison."
-        return (api_version <= version_to_check)
-
-    # Iterate over the numeric parts of the session's API version number and compare them to the
-    # corresponding parts of the input version number.  Once an inequality is found,
-    # we know which is greater.
-    for i in xrange(len(api_version_parts)):
-        api_version_part = int(api_version_parts[i])
-        if len(version_to_check_parts) >= i + 1:
-            version_to_check_part = int(version_to_check_parts[i])
-        else:  # Not enough parts in version_to_check; supply a 0
-            version_to_check_part = 0
-        if api_version_part < version_to_check_part:
-            return True
-        elif api_version_part > version_to_check_part:
-            return False
-        # Equal, need to look at next part, if any
-
-
-    # We checked all of the numeric parts of the API version number without finding
-    # an inequality.  This means that either the versions are completely equal or 
-    # api_version has fewer parts, which means that it cannot be greater than
-    # version_to_check.  Thus it must be <=, so we return True.
-    return True
-
-# Return the "effective" version (the version reported by the HMC itself, or the override
-# value from the command line (if specified).
-def api_effective_version(session):
-    return session.api_version() if session.api_version_override() is None else session.api_version_override()
-
-#############################################################################
-# Determine if the specified WS API feature is available to the current session.
-# 
-# Returns:
-#    True if the feature is available; otherwise, False.
-#############################################################################
-
-def is_feature_available(session, feature):
-    features = session.api_features()
-    return (features is not None and feature in features)
-
-
-#############################################################################
-# Check the supplied testcase properties to see if they meet at least one of
-# the required values for the specified property.  This is effectively a
-# logical OR of the required property values.
-# 
-# Returns:
-#    True if the testcase supports at least one of the required property
-#    values; otherwise, False.
-#############################################################################
-
-def check_testcase_requirement(testcase_properties, property_name, required_properties):
-    if required_properties is None:
-        required_found = True
-    else:
-        # Check required property; these are OR'd together
-        required_found = False  # Something is required; assume we don't have it
-
-        if property_name in testcase_properties.keys():
-            available = testcase_properties[property_name]
-            for r in required_properties :
-                # Many requirement values are accepted in upper or lower case, so 
-                # convert everything to lowercase before looking for a match.
-                # We currently support testcase properties whose values are of
-                # type string or list.
-                # if r.upper() in available:
-                if type(available) is types.StringType:  # A string
-                    if r.lower() == available.lower():
-                        required_found = True
-                        break
-                else:  # Assume a list
-                    if r.lower() in make_lowercase_copy(available):
-                        required_found = True
-                        break
-        else:
-            print "The testcase properties do not define the %s property" % (property_name)
-
-    return required_found
-
-
-#############################################################################
-# Exit test code cleanly ...
-# By default, all "temporary" objects are deleted, and any "admin sessions"
-# and "temporary sessions" are shutdown after the specified session is shutdown.
-#############################################################################
-
-def session_shutdown(session, verbose=True, delete_temporary_objects=True, delete_admin_sessions=True, delete_temporary_sessions=True) :
-    if session is not None :
-        if verbose :
-            print 'Disconnecting from', session.hmc_name(), 'at', session.host(), session.port(), 'as', session.userid(), 'at', get_time_stamp()
-        try :
-            session.close()
-        except (ApiException, ApiFatalException) as exception :
-            print
-            print 'Exception raised during shutdown ...'
-            print exception
-            print
-
-
-    # Delete temporary sessions first, in case one is for a temporary user that we're
-    # about to delete in delete_all_temporary_objects().
-    if delete_temporary_sessions:
-        delete_all_temporary_sessions()
-
-    if delete_temporary_objects:
-        delete_all_temporary_objects()
-
-    if delete_admin_sessions:
-        delete_all_admin_sessions()
-
-
-#############################################################################
-# This function returns True if value is a number, False otherwise.
-#############################################################################
-
-def isNumeric(value) :
-    try :
-        float(value)
-    except (ValueError) :
-        return False
-    return True
-
-
-#############################################################################
-#
-# This function prints out data as formatted columns.
-#
-# Formatting is simple : Strings will be left-justified
-#                        Numbers will be right-justified
-#
-# Input :
-#
-#   The keys parameter is a list of keys whose values should be printed
-#   The data parameter is a list of dictionaries
-#
-# No error checking is done currently ...
-#
-# Example :
-#
-#    keys = [ 'name', 'status', 'type' ]
-#    data = [ { 'name':'abc',     'type':'foo',    'status':'operating',     'count':1    },
-#             { 'name':'abcde',   'type':'bar',    'status':'not_operating', 'count':10   },
-#             { 'name':'ab',      'type':'foobar', 'status':'status_check',  'count':100  },
-#             { 'name':'abcdefg', 'type':'fubar',  'status':'starting',      'count':1000 } ]
-#
-#    prettyPrint( data, keys ) will print ...
-#
-#       abc     operating     foo
-#       abcde   not_operating bar
-#       ab      status_check  foobar
-#       abcdefg starting      fubar
-#
-#############################################################################
-
-def prettyPrint(data, keys) :
-    if data is None or len(data) == 0 : return
-    if keys is None or len(keys) == 0 : return
-    width = {}
-    for key in keys :
-        width[ key ] = max([ len(str(row[ key ])) for row in data ])
-    for row in data :
-        for key in keys :
-            if isNumeric(row[ key ]) :
-                print str(row[ key ]).rjust(width[ key ]),
-            else :
-                print str(row[ key ]).ljust(width[ key ]),
-        print
-
-
-# Print a Response object with formatted headers and body
-# @param response - API response (Response)
-def print_response(response, sort_body=True) :
-    if response is None or response.__class__ is not Response :
-        raise ApiFatalException('response is missing or invalid type')
-    print 'Response Status  : ' + str(response.status)
-    print 'Response Reason  : ' + str(response.reason)
-    print 'Response Headers :'
-    print json.dumps(response.headers, sort_keys=sort_body, indent=1, separators=(',', ':'))
-    print 'Response Body    :'
-    print json.dumps(response.body, sort_keys=sort_body, indent=1, separators=(',', ':'))
-    if 'stack' in response.body:
-        print 'stack (again, but in a more programmer-friendly format):'
-        print response.body['stack']
-    return
-# end print_response
-
-
-# Print information in a formatted fashion from a response object and an optional response body.
-# This is useful for streamed responses; see return_full_response in wsautils.py and the 
-# read_response_streamed() function.
-def print_response_info(response, response_body=None) :
-    print 'Response Status  : ' + str(response.status)
-    print 'Response Reason  : ' + str(response.reason)
-    print 'Response Headers :'
-    print json.dumps(dict (response.getheaders()), indent=1, separators=(',', ':'))
-    print 'Response Body    :'
-    if response_body is None:
-        print json.dumps(response.read(), indent=1, separators=(',', ':'))
-    else:
-        body = json.loads(response_body)
-        print json.dumps(body, indent=1, separators=(',', ':'))
-    return
-   # end print_response_info
-
-
-# Print a line(s) between separator lines so that they stand out among the testcase output.
-# Optional text can be included in the separator line that precedes the lines and the one 
-# that follows the lines.  The length and composition of the separator line can by customized
-# with input parameters.
-def print_between_separator_lines(lines, header_text=None, footer_text=None, length=90, box_char="=", blank_lines=1):
-    if header_text == None:
-        line = ""
-    else:
-        box_char_count = (length - len(header_text) - 2) / 2
-        line = "%s %s " % (box_char * box_char_count, header_text)  # Leading box chars and header text
-
-    header_line = "%s%s%s" % ("\n"*blank_lines, line, box_char * (length - len(line)))  # Add the blank lines and trailing box chars
-    print header_line
-
-    # Write all of the input lines
-    for line in lines:
-        print line
-    
-    if footer_text == None:
-        line = ""
-    else:
-        box_char_count = (length - len(footer_text) - 2) / 2
-        line = "%s %s " % (box_char * box_char_count, footer_text)  # Leading box chars and footer text
-
-    footer_line = "%s%s%s" % (line, box_char * (length - len(line)), "\n"*blank_lines)  # Add the trailing box chars and blank lines
-    print footer_line
-
-
-#############################################################################
-#
-# Filter a list of dictionaries based on keys and values
-#
-# This function is a "generator", meaning its output should be wrapped
-# in a list in order to iterate over the results.
-#
-# The following snippet will return all the dictionaries in the list that
-# contain the key 'foo'.
-#
-# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
-# func = lambda k, v : k == 'foo'
-# print list( filter_dictionary( data, func ) )
-#
-# The following snippet will return all the dictionaries in the list that
-# contain the key 'bar' with the value of 'bar2'
-#
-# data = [ { 'foo':'foo1', 'bar':'bar1' }, { 'bar':'bar2', 'baz':'baz1' } ]
-# func = lambda k, v : k == 'bar' and v == 'bar2'
-# print list( filter_dictionary( data, func ) )
-#
-#############################################################################
-
-def filter_list(data, predicate=lambda k, v: True) :
-    for d in data:
-         for k, v in d.items():
-               if predicate(k, v):
-                    yield d
-
-#########################################################################
-# Determine the Output body, response, and reason code
-#
-# NOTE : The Response object has been updated to raise an
-# ApiFatalException if the HTTP headers indicate a content type of json,
-# but the response body fails to parse with json.loads.
-# This negates the need for 'determine' to check for a malformed body
-# with a subsequent return code of '2'.
-#########################################################################
-
-def determine(response, status_code, reason_code) :
-
-    status = response.status
-    if 'http-status' in response.body :
-        status = response.body[ 'http-status' ]
-    reason = None
-    if 'reason' in response.body :
-        reason = response.body[ 'reason' ]
-    if status == status_code and reason == reason_code :
-        return(0)
-    else :
-        return(1)
-    
-# added by lv start
-def determine_with_raise_exception(response, status_code, reason_code) :
-
-    status = response.status
-    if 'http-status' in response.body :
-        status = response.body[ 'http-status' ]
-    reason = None
-    if 'reason' in response.body :
-        reason = response.body[ 'reason' ]
-    if status == status_code :
-        if reason == reason_code :
-            return (0)
-        else: 
-            raise ApiException('expected reason code' + str(reason_code) + ' not seen')
-    else :
-        raise ApiException('expected status code' + str(status_code) + ' not seen')
-# added by lv end
-
-
-#########################################################################
-# Get the current time, formatted
-#########################################################################
-def get_time_stamp() :
-    return time.strftime("%Y%m%d %H:%M:%S %z", time.localtime())
-# end get_time_stamp
-
-
-#########################################################################
-# Get the fully-qualified filename of the current testcase
-#########################################################################
-
-def get_testcase_full_filename ():
-    return sys.argv[0]
-
-
-#########################################################################
-# Get the testcase ID for the current testcase, based on its filename,
-# or for a specified filename.
-# The expected format for testcase filenames is
-#           <comp>_<id>.py
-# where <comp> is the component (e.g., svm, vsm, lpar) and <id> is the
-# testcase ID number.  For example, vsm_3588.py
-#########################################################################
-
-def get_testcase_id (filename=None):
-    name = get_testcase_full_filename() if filename == None else filename
-    basename = os.path.basename(name)  # Just the filename, no path
-    (name, ext) = os.path.splitext(basename)  # Separate name from extension (e..g, svm_3588)
-    parts = string.split(name, '_')  # Split at underscore (e.g., 'svm', '3588')
-    id = parts[len(parts) - 1]  # ID is the last one of the parts
-    return id
-
-
-
-
-def get_files_from_se(remote_files, local_zip_file):
-    return
-# Get the name of the user's notification topic for a specified topic type
-#
-# Inputs:
-# - requested_topic_type: the type of topic to find.  Must be a valid topic type as
-#                         returned by the Get Notification Topics operation:
-#                         'object', 'job', 'audit' or 'security'.
-#
-# Returns: the name of the topic, or None if there is no such topic for the user (e.g.,
-#          the user is not authorized to connect to it).
-#
-# Any failure is reported via an exception
-def get_notification_topic(session, requested_topic_type):
-    """Get the name of the user's notification topic for the specified topic type"""
-
-    # Make sure the targetted HMC supports the request required to fetch the notification topics
-    if not is_api_version_at_least(session, TC_API_VERSION_ZSPHINX_GA1):
-        raise ApiFatalException('The targetted HMC (effective version %s) does not support audit or security notifications; must be version %s or later' % (api_effective_version(session), TC_API_VERSION_ZSPHINX_GA1))
-
-    valid_topic_types = ['object', 'job', 'audit', 'security']
-    if requested_topic_type not in valid_topic_types:
-        raise ApiException("get_notification_topic(): Invalid topic type: " + requested_topic_type)
-    true_topic_type = requested_topic_type + "-notification"  # The name returned by Get Notification Topics
-
-    # Issue a Get Notification Topics request to get all of the user's authorized topics
-    uri = "/api/sessions/operations/get-notification-topics"
-    response = session.get(uri)
-    if response.status != 200:
-        raise ApiException("Get Notification Topics operation failed", response)
-    topics = response.body['topics']
-
-    if len(topics) == 0:  # No topics!  Should never happen, per the doc
-        print 'User is not authorized for any notification topics - this should never happen!'
-        return None
-
-    # Iterate over the user's authorized topics looking for the specified one
-    for topic in topics:
-        topic_type = topic['topic-type']
-        topic_name = topic['topic-name']
-#       print 'Topic type: %s, topic_name: %s' % (topic_type, topic_name)
-        if topic_type == true_topic_type:  # Found it
-            return topic_name
-
-    # Not found
-    return None
-
-
-# Issue the provided request and return the response along with a string containing 
-# the formatted request and response.  This formatted version is suitable for inclusion
-# in the HMC Web Services API external customer publication.  It contains:
-# - the caption text for the request example
-# - the HTTP method and full request URI
-# - certain request headers
-# - the request body, if any, alphabetized, nicely formatted and indented
-# - the caption text for the response example
-# - the HTTP status code and its meaning (e.g., "201 (Created)")
-# - certain response headers
-# - the response body, if any, alphabetized, nicely formatted and indented
-#
-# The operation_name should be the full name by which the operation is known in the external book
-# The URI may contain query parms.  This is handy for limiting the size of the response body
-# for List <class> operations.  It is OK to publish these, but not necessary.
-# The request_body is a dictionary (and is optional).
-def capture_example_for_book(session, operation_name, uri, method="get", request_body=None):
-    indent_amount = 3
-    request_headers_to_publish_get = [WSA_HEADER_RQ_SESSION]
-    request_headers_to_publish_post = [WSA_HEADER_RQ_SESSION,
-                                       WSA_HEADER_CONTENT_TYPE,
-                                       WSA_HEADER_CONTENT_LENGTH]
-    request_headers_to_publish_delete = [WSA_HEADER_RQ_SESSION]
-    response_headers_to_publish = [WSA_HEADER_RESP_SERVER,
-                                   WSA_HEADER_RESP_TRANSFER_ENCODING,  # "chunked" is of interest
-                                   WSA_HEADER_RESP_LOCATION,
-                                   WSA_HEADER_RESP_CACHE_CONTROL,
-                                   WSA_HEADER_RESP_DATE,
-                                   WSA_HEADER_CONTENT_TYPE,
-                                   WSA_HEADER_CONTENT_LENGTH]
-
-    if method == 'get':
-        request_headers_to_publish = request_headers_to_publish_get
-        response = session.get(uri)
-    elif method == 'post':
-        request_headers_to_publish = request_headers_to_publish_post
-        response = session.post(uri, json.dumps(request_body))
-    elif method == 'delete':
-        request_headers_to_publish = request_headers_to_publish_delete
-        response = session.delete(uri)
-
-    request_headers = response.request.headers
-    response_headers = response.headers
-
-    # First format the request URI, filtered headers and body
-    formatted_request_response = "\n\n%s: Request\n\n" % operation_name
-    formatted_request_response += "\n%s %s %s" % (method.upper(), uri, "HTTP/1.1")
-
-    for header_name in request_headers_to_publish:
-        formatted_request_response += "\n%s: %s" % (header_name, request_headers[header_name])
-
-    if request_body != None:
-        formatted_request_body = json.dumps(request_body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
-        formatted_request_response += "\n" + formatted_request_body
-
-    #------- end request, begin response --------
-    # Noe format the filtered response headers and the response body
-    formatted_request_response += "\n\n%s\n\n%s: Response\n\n" % (20 * '-', operation_name)
-    formatted_request_response += "\n%s %s" % (response.status, response.reason)
-
-    for header_name in response_headers_to_publish:
-        if header_name in response_headers.keys():
-            formatted_request_response += "\n%s: %s" % (header_name, response_headers[header_name])
-
-    if response.status == 204 or response.body == None:
-        formatted_response_body = "\n<No response body>"
-    else:  # There is a response body; make it look pretty
-        formatted_response_body = json.dumps(response.body, sort_keys=True, indent=indent_amount, separators=(',', ':'))
-    formatted_request_response += "\n" + formatted_response_body
-
-    # Formatting is complete
-
-#   # Make sure the request succeeded; assume any 2xx indicates success
-#   if response.status < 200 or response.status > 299:
-#       print_response(response)
-#       raise ApiException("The request appears to have failed.  URI '%s' returned HTTP status code %d (%s)" % (uri, response.status, response.reason))
-
-    # Return the complete Response object and the formatted request/response string
-    return response, formatted_request_response
-
-
-#########################################################################
-#                  "Temporary object" support
-#########################################################################
-
-# Add a temporary object to the registry.  All objects in the registry will
-# be deleted by default when the session is shutdown.  The object must be
-# of a type that is supported by the "temporary object" support.
-# See the temporary_object_types_deletion_order and temporary_object_types_info
-# constants in wsaconst.py.
-def register_temporary_object(temporary_object_uri):
-    if temporary_object_uri is not None:
-        if is_supported_temporary_object_type(temporary_object_uri):
-            wsaglobals.global_temporary_objects_list.append(temporary_object_uri)
-        else:
-            raise ApiFatalException('URI "%s" does not designate an object of a type that is supported by the "temporary object" support in wsautils' % temporary_object_uri)
-
-
-# Remove a temporary object from the registry
-def deregister_temporary_object(temporary_object_uri):
-    if temporary_object_uri is not None:
-        wsaglobals.global_temporary_objects_list.remove(temporary_object_uri)
-
-
-# Gets a copy of the list of all registered temporary objects.
-# Use register_temporary_object() and deregister_temporary_object()
-# to update this list if needed.
-def get_temporary_objects_list():
-    return list(wsaglobals.global_temporary_objects_list)  # Return a copy
-
-
-# Determine if the specified URI designates an object of a type that is supported
-# by the "temporary object" support.
-def is_supported_temporary_object_type(uri):
-    if uri is None or not isinstance(uri, types.StringTypes):  # Not a string (likely to be a Response object from a failed request...)
-        return False
-    
-    for info_entry in temporary_object_types_info.values():
-        uri_prefix = info_entry[KEY_URI_PREFIX]
-        if uri.startswith(uri_prefix):  # It's a supported type
-            return True
-    return False
-
-
-# Delete all temporary objects in the registry.  This method is intended to be
-# called during session shutdown immediately before testcase exit.
-def delete_all_temporary_objects():
-    temporary_objects_list = get_temporary_objects_list()  # Get a copy to iterate over; the real list gets updated
-    if temporary_objects_list is not None and len(temporary_objects_list) > 0:  # There are temporary objects to be deleted
-        print '\nTemporary objects to delete: %d' % len(temporary_objects_list)
-
-        # Iterate over all supported object types and delete all instances of each type,
-        # then move on to the next type
-        for object_type in temporary_object_types_deletion_order:  # Go in a certain order, since it sometimes matters
-            info_entry = temporary_object_types_info[object_type]  # Get handling info about the current object type
-            uri_prefix = info_entry[KEY_URI_PREFIX]
-#           print 'Looking for temporary objects with a URI prefix of "%s"' % uri_prefix
-            
-            # Iterate over all temporary objects in the registry, searching for those
-            # of the type we're currently handling.  Delete each as it is found and 
-            # remove it from the registry.
-            for uri in temporary_objects_list:
-                if uri is not None and uri.startswith(uri_prefix):  # Its type matches the type we're handling now
-                    try:
-                        admin_user = info_entry[KEY_ADMIN_USERID]
-
-                        admin_session = get_admin_session(admin_user)
-
-                        print 'Using %s to delete temporary object: %s' % (admin_user, uri)
-                        response = admin_session.delete(uri)
-                        if response.status != 204:
-                            print '\nError deleting temporary object: %s\n%s' % (uri, response)
-
-                        deregister_temporary_object(uri)  # Remove it from the list of temporary objects, since we've deleted it
-#                       print 'There are %d temporary objects left to delete' % len(wsaglobals.global_temporary_objects_list)
-                    except:
-                        print 'Caught exception!!'
-                        traceback.print_exc()
-                        print 'Continuing with any remaining temporary objects...'
-        print
-
-    # Get a current copy of the list; check to see if it's empty (it should be)
-    temporary_objects_list = get_temporary_objects_list()
-    if len(temporary_objects_list) > 0:  # Hmmmm, must have had an error trying to delete something; tell the user
-        print '\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
-        print 'Not all temporary objects were deleted.  There are still %d temporary objects in the registry.' % len(temporary_objects_list)
-        print '\n%s\n' % temporary_objects_list
-        print '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n'
-
-
-# Get a Session authenticated as the specified userid.  This method is intended for use when
-# a priviledged (admin-type) user is required for performing scenario setup in the beginning
-# of a testcase (e.g., creating objects, setting properties)and at the end when that setup is
-# being undone (e.g., deleting temporary objects, resetting properties back to original values).
-# These sessions are cached and can be reused.  They are cleaned up automatically during testcase
-# exit.  There are constants for the standard system-defined  userids (e.g., 
-# ACCCES_ADMINISTRATOR, ENSEMBLE_ADMINISTRATOR) in wsaconst.py.
-def get_admin_session(admin_userid):
-    if admin_userid in wsaglobals.global_admin_sessions:
-        admin_session = wsaglobals.global_admin_sessions[admin_userid]
-#       print 'fetched cached session: %s' % admin_session
-    else:
-        admin_session = session_startup(user=admin_userid, additional_options=wsaglobals.global_saved_additional_options)
-        wsaglobals.global_admin_sessions.update({admin_userid : admin_session})
-#       print 'created and cached new session: %s' % admin_session
-
-#   print 'There are %d admin sessions' % len(wsaglobals.global_admin_sessions)
-#   print 'Returning admin session for admin user %s: %s' % (admin_userid, admin_session)
-    return admin_session
-
-
-# Get a Session object authenticated as the system-defined user that is appropriate for performing
-# administrative operations relative to the specified URI.  If no specific administrator has been
-# identified in the uri_admin_info map, then a session authenticated as PEDEBUG is returned.
-# These sessions are cached and can be reused.  They are cleaned up automatically during testcase exit.
-def get_admin_session_for_uri(uri):
-    admin_session = None
-    # See if the specified URI has an associated administrator userid
-    for uri_prefix in uri_admin_info:
-        if uri.startswith(uri_prefix):
-            admin_session = get_admin_session(uri_admin_info[uri_prefix])
-    if admin_session == None:
-        admin_session = get_admin_session(PEDEBUG)
-    return admin_session
-
-
-# Delete all (cached) admin sessions created by get_admin_session().
-# This method is intended to be called during session shutdown immediately before testcase exit.
-def delete_all_admin_sessions():
-    admin_sessions = dict(wsaglobals.global_admin_sessions)  # Make a copy to iterate over; the real list gets updated
-    if admin_sessions is not None and len(admin_sessions) > 0:  # There are admin sessions to be deleted
-        print '\nAdmin sessions to shutdown: %d' % len(admin_sessions)
-        for admin_user_name in admin_sessions.keys():
-            try:
-                admin_session = admin_sessions[admin_user_name]
-                print 'Shutting down session for admin user: %s' % admin_user_name
-                # Shutdown this admin session.  Specify options on the session_shutdown() call so that
-                # it only deletes this session and nothing else, because we don't want to interfere with
-                # the very deliberate order in which the various objects and sessions are cleaned up.
-                session_shutdown(admin_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)  # Delete just the session, and nothing else
-                del wsaglobals.global_admin_sessions[admin_user_name]  # Remove it from the list of admin sessions
-            except:
-                print 'Caught exception!!'
-                traceback.print_exc()
-                print 'Continuing with any remaining admin sessions...'
-
-#   print 'There are now %d admin sessions' % len(wsaglobals.global_admin_sessions)
-
-
-# Delete all temporary sessions in the registry.  This method is intended to be
-# called during session shutdown immediately before testcase exit.
-def delete_all_temporary_sessions():
-    temporary_sessions = get_temporary_sessions()  # Make a copy to iterate over; the real list gets updated
-    if temporary_sessions is not None and len(temporary_sessions) > 0:  # There are admin sessions to be deleted
-        print '\nTemporary sessions to shutdown: %d' % len(temporary_sessions)
-        for temporary_session in temporary_sessions:
-            try:
-                print 'Shutting down temporary session for user: %s' % temporary_session.userid()
-                # Shutdown this temporary session.  Specify options on the session_shutdown() call so that
-                # it only deletes this session and nothing else, because we don't want to interfere with
-                # the very deliberate order in which the various objects and sessions are cleaned up.
-                session_shutdown(temporary_session, delete_temporary_objects=False, delete_admin_sessions=False, delete_temporary_sessions=False)
-                wsaglobals.global_temporary_sessions.remove(temporary_session)  # Remove it from the list of temporary sessions
-            except:
-                print 'Caught exception!!'
-                traceback.print_exc()
-                print 'Continuing with any remaining temporary sessions...'
-
-
-
-# Gets a copy of the list of all registered temporary sessions.
-def get_temporary_sessions():
-    return list(wsaglobals.global_temporary_sessions)  # Return a copy
-
-def start_receiving_messages(session):
-    session.start_receiving_messages()
-    
-def stop_receiving_messages(session):
-    session.stop_receiving_messages()
-    msgs = session.get_received_messages()
-    print msgs
-    return msgs
-
-def create_python_list(item):
-    return [item]
-
-def create_python_dict(prop, value):
-    return {prop:value}
-
-"""
-Generic function that finds an object of type ObjectType by its attribute.    
-The function looks for a objectToFind which is a string type by it's attribute.
-Params: Field Name refers to properties like name, status etc
-        objectType refers to objects like cpcs, groups, members etc
-        FielddNameValue is the string that is searched for in the listOfDictionaries 
-"""
-def verify_object_in_list_by_attribute(listOfDictionaries, fieldNameValue, objectType, fieldName):
-    verifyIn = False
-    for myObject in listOfDictionaries.body[objectType]:
-        if myObject[fieldName] == fieldNameValue:
-            verifyIn = True
-            break
-    return verifyIn
-
-def get_partition_list(session, cpc):
-    response = session.get(cpc, '/partitions')
-    for partition in response.body['partitions']:
-        print partition['name']
-    return response.body['partitions']
-    
